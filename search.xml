<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SSD学习小结(二)</title>
      <link href="/posts/caa7.html"/>
      <url>/posts/caa7.html</url>
      
        <content type="html"><![CDATA[<h3 id="SLC、MLC、TLC、QLC"><a href="#SLC、MLC、TLC、QLC" class="headerlink" title="SLC、MLC、TLC、QLC"></a>SLC、MLC、TLC、QLC</h3><p>SLC：一个存储单元存储1bit数据</p><p>MLC：存储2bit数据</p><p>TLC：存储3bit数据</p><p>QLC: 存储4bit数据</p><a id="more"></a><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201207110416671.png" alt="image-20201207110416671"></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201207112003659.png" alt="image-20201207112003659"></p><p>上图是一个闪存块（Block）的组织架构。一个Wordline对应着一个或若干个Page，具体是多少取决于是SLC、MLC或者TLC。对SLC来说，一个Wordline对应一个Page; MLC则对应2个Page，这两个Page是一对（Lower Page和UpperPage）; TLC对应3个Page（Lower Page、Upper Page和Extra Page）</p><hr><p>一个闪存芯片有若干个DIE（或者叫LUN），每个DIE有若干个Plane，每个Plane有若干个Block，每个Block有若干个Page，每个Page对应着一个Wordline, Wordline由成千上万个存储单元构成。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201207112055793.png" alt="image-20201207112055793"></p><p>LUN、Plane、Block、Page</p><h4 id="闪存存在的问题"><a href="#闪存存在的问题" class="headerlink" title="闪存存在的问题"></a>闪存存在的问题</h4><p>1、闪存坏块</p><p>2、读干扰：当在读取一个闪存页（page）的时候，闪存块当中未被选取的闪存页的控制极都会加一个正电压，以保证未被选中的MOS管是导通的。但是频繁地在一个MOS管控制极加正电压，就可能导致电子被吸进浮栅极，形成轻微写，从而导致比特翻转，如图3-44所示。但是，这不是永久性损伤，重新擦除闪存块还能正常使用。<font color="orange"> 读干扰影响的是同一个闪存块中的其他闪存页，而非读取的闪存页本身。</font></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201207162433285.png" alt="image-20201207162433285"></p><p>3、写干扰：</p><p>写干扰也会导致比特反转，<font color="orange"> 与读干扰不同的是，写干扰影响的不仅是同一个闪存块当中的其他闪存页，自身闪存页也会受到影响。相同的是，都会因不期望的轻微写导致比特翻转，都会产生非永久性损伤，经擦除后，闪存块还能再次使用。</font></p><p>4、存储单元的耦合：存储单元之间存在耦合电容，这会使存储单元内的电荷发生意外变化，最终导致数据读取错误。</p><p>5、电荷泄漏问题：存储在闪存存储单元的电荷，如果长期不使用，会发生电荷泄漏。这同样会导致非永久性损伤，擦除后闪存块还能使用</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SSD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSD学习小结(三)FTL</title>
      <link href="/posts/41f4.html"/>
      <url>/posts/41f4.html</url>
      
        <content type="html"><![CDATA[<p>FTL是SSD固件的核心组成。</p><a id="more"></a><blockquote><p>FTL是Flash Translation Layer（闪存转换层）的缩写，完成主机（或者用户，Host）逻辑地址空间到闪存（Flash）物理地址空间的翻译（Translation），或者说映射（Mapping）。SSD每把一笔用户逻辑数据写入闪存地址空间，便记录下该逻辑地址到物理地址的映射关系。当主机想读取该数据时，SSD便会根据这个映射，从闪存读取这笔数据然后返回给用户。</p></blockquote><p>由于闪存的特性，Block不能覆盖写，需要先擦除才能写入，当写入一个新数据时，不能直接在老地方改写，（闪存不允许在一个闪存页（Page）上重复写入，一次擦除只能写入一次），必须写到一个新的位置。SSD的FW（firmware固件）会维护一张逻辑地址-&gt;物理地址转换的映射表。<font color="orange"> 往一个新的位置写入数据，则原有老位置上的数据会被标记为无效，这些数据自然就变成了垃圾数据。</font></p><blockquote><p>垃圾回收：垃圾数据会占用闪存空间，当闪存可用空间不够时，FTL需要做垃圾回收，即把若干个闪存块上的有效数据搬出，写到某个新的闪存块，然后把这些之前的闪存块擦除，得到可用的闪存块。</p></blockquote><hr><p>FTL分为Host Based（基于主机）和Device Based（基于设备）。Host Based表示的是，FTL是在Host（主机）端实现的，用的是自己计算机的CPU和内存资源。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201207164128520.png" alt="image-20201207164128520"></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201207164136356.png" alt="image-20201207164136356"></p><p>​     Device Based表示的是，FTL是在Device（设备）端实现的，用的是SSD上的控制器和RAM资源。目前主流的SSD中的FTL都是在设备端实现的。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收就是把某个闪存块上的有效数据（下图中的浅色方块）读出来，重新写入，然后把该闪存块擦除，就可以得到新的可用的闪存块。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201207170103120.png" alt="image-20201207170103120"></p><p>上图中Block x上面有效数据为A、B、C, Block y上面有效数据为D、E、F、G，其余方块为无效数据。垃圾回收机制就是先找一个可用Block z，然后把Blockx和Block y的有效数据搬移到Block z上面去，这样Block x和Block y上面就没有任何有效数据，可以擦除变成两个可用的闪存块</p><p>擦除垃圾数据块得到可用数据块：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201207170204183.png" alt="image-20201207170204183"></p><p>为什么SSD的随机写比较慢？</p><p>从上面描述的垃圾回收看，如果用户是顺序写，垃圾数据块会比较集中，有利于SSD做垃圾回收；但是如果是随机写的话，产生的无效数据块比较分散，SSD做垃圾回收相对就更慢。因此，SSD的GC性能跟用户写入数据的模式（随机写还是顺序写）也是密切相关的。</p><h2 id="写放大"><a href="#写放大" class="headerlink" title="写放大"></a>写放大</h2><p>由于GC的存在和闪存块本身的特性，Block不能覆盖写，往往导致SSD往闪存中写入的数据量比用户要写入SSD的数据量多。SSD中一个重要参数就是写放大：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201207170952212.png" alt="image-20201207170952212"></p><p>写放大越大，意味着额外写入闪存的数据越多，一方面磨损闪存，减少SSD寿命，另一方面，写入这些额外数据会占用底层闪存带宽，影响SSD性能。因此，SSD设计的一个目标是让WA尽量小。减小写放大，可以使用前面提到的压缩办法（主控决定），顺序写也可以减小写放大（垃圾集中，但顺序写可遇不可求，取决于用户Workload），还有就是增大OP（预留空间）。</p><p><font color="orange"> OP越大，每个闪存块有效数据越少，垃圾越多，因此需要重写更少的数据，写放大也越小</font></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201207191038289.png" alt="image-20201207191038289"></p><p>​                              OP大小对写放大和耐写度的影响</p><p><font color="orange">垃圾回收简单分为三步:</font></p><p>(1) 挑选源闪存块</p><p>(2) 从源闪存块中找到有效数据</p><p>(3) 把有效数据写入到目标闪存块</p><p>挑选源闪存块，一个常见的算法就是挑选有效数据最小的块。方法是通过固件i写用户数据时，记录和维护每个用户闪存块的有效数据量。即用户每往一个新的块上写入一笔用户数据，该闪存块上的有效数据数就+1，同时这个数据之前所在的块，有效数据量-1。</p><p>这样在GC的时候可以快速找到有效数据最少的那个块，挑选有效数据最少的那个块作为源闪存块，这种BPA算法叫作Greedy算法，是绝大多数SSD采用的一种策略。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SSD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSD学习小结(一)</title>
      <link href="/posts/a03.html"/>
      <url>/posts/a03.html</url>
      
        <content type="html"><![CDATA[<h3 id="SSDvsHDD"><a href="#SSDvsHDD" class="headerlink" title="SSDvsHDD"></a>SSDvsHDD</h3><p>传统的HDD是“马达+磁头+磁盘”的机械结构</p><p>SSD则是“闪存截止+主控”的半导体存储芯片结构</p><a id="more"></a><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201207085126089.png" alt="image-20201207085126089"></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201207085134371.png" alt="image-20201207085134371"></p><h3 id="SSD基本工作原理"><a href="#SSD基本工作原理" class="headerlink" title="SSD基本工作原理"></a>SSD基本工作原理</h3><p>​     从主机PC端开始，用户从操作系统应用层面对SSD发出请求，文件系统将读写请求经驱动转化为相应的符合协议的读写和其他命令，SSD收到命令执行相应操作，然后输出结果。</p><p>SSD的输入是命令（Command）</p><p>输出是数据（Data）和命令状态（Command Status）</p><p>SSD前端接收用户命令请求，经过内部计算和处理逻辑，输出用户所需要的数据或状态。</p><p><font color="orange"> SSD主要由三大功能模块组成：</font></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201207092242358.png" alt="image-20201207092242358"></p><p>①前端接口和相关的协议模块</p><p>②中间的FTL层（闪存翻译层）模块</p><p>③后端和闪存通信模块</p><p>SSD前端负责和主机直接通信，接收主机发来的命令和相关数据，命令经SSD处理后，最终交由前端返回命令状态或数据给主机。SSD通过诸如SATA、SAS和PCIe等接口与主机相连，实现对应的ATA、SCSI和NVMe等协议。</p><p>垃圾回收:</p><p>在Block x和Block y上有很多垃圾数据，其中Block x上的A、B、C为有效数据，Block y上的D、E、F、G为有效数据。垃圾回收就是把一个或者几个Block上的有效数据搬出来集中写到某个空闲Block上（比如Block z）。当这些Block上的有效数据都搬走后，FTL便能擦除这些Block，然后又能把这些Block拿出来供SSD写入新的数据了。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201207100753098.png" alt="image-20201207100753098"></p><p>磨损均衡（wear leveling）：FTL必须尽量让每个闪存块均衡写入，延长闪存颗粒寿命。</p><p>地址映射：将文件系统的逻辑地址映射到flash的物理地址上</p><h3 id="闪存的物理结构"><a href="#闪存的物理结构" class="headerlink" title="闪存的物理结构"></a>闪存的物理结构</h3><p>闪存是一种非易失性存储器，掉电数据不会丢失。闪存的即本存储单元（cell）是一种类NMOS的双层浮栅（floating gate）MOS管。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201207105703387.png" alt="image-20201207105703387"></p><p>​                                             浮栅晶体管结构</p><blockquote><p>在源极（Source）和漏极（Drain）之间电流单向传导的半导体上形成存储电子的浮栅，浮栅上下被绝缘层包围，存储在里面的电子不会因为掉电而消失</p></blockquote><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201207105757608.png" alt="image-20201207105757608"></p><p>写操作是在控制极加正电压，使电子通过绝缘层进入浮栅极。</p><p>擦除操作则正好相反，是在衬底加正电压，把电子从浮栅极中吸出来。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SSD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb学习记录-log文件</title>
      <link href="/posts/223d4dcc.html"/>
      <url>/posts/223d4dcc.html</url>
      
        <content type="html"><![CDATA[<p>log文件在leveldb的主要作用是防止系统宕机的时候，数据丢失。所以在将键值对写入位于内存的memtable之前，会先写入Log文件中，保证数据的持久化。这样即使系统发生故障，memtable中的数据没有及时Dump到磁盘上，LevelDB仍然可以根据log文件恢复数据。</p><a id="more"></a><h2 id="1-log结构"><a href="#1-log结构" class="headerlink" title="1.log结构"></a>1.log结构</h2><p>关于log的结构在leveldb源码中的doc/log_format.md中有详细的介绍。</p><p>LevelDB对于一个log文件，由以32K为单位的物理块构成，每次读取以一个Block作为基本读取单位。</p><p>下图展示的 log 文件由3个 Block 构成，所以从物理布局来讲，一个 log 文件就是由连续的 32K 大小 Block 构成的。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-03.png" alt="log文件布局"></p><p>每条record的结构如下图所示：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201216200910539.png" alt="image-20201216200910539"></p><p>leveldb中存放的键值对key和value的长度是可变的，所以需要length来记录record中保存的data长度（小端对齐）。checksum记录的是type和data字段的CRC循环校验，验证数据完整性和一致性。log文件是以Block为单位进行存放的，所以会存在某个key-value对过小不能占满一个block块，或者某个key-value对过大，单个block块放不下，需要存放在多个不同的block块中，type字段则是指出每条record的逻辑结构和log文件物理分块结构的关系。在leveldb源码的db/log_format.h文件中,定义了一个RecordType的枚举类。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> RecordType {</span><br><span class="line">  <span class="comment">// Zero is reserved for preallocated files</span></span><br><span class="line">  kZeroType = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  kFullType = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For fragments</span></span><br><span class="line">  kFirstType = <span class="number">2</span>,</span><br><span class="line">  kMiddleType = <span class="number">3</span>,</span><br><span class="line">  kLastType = <span class="number">4</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>主要有以下四种类型：<code>FULL</code>, <code>FIRST</code>, <code>MIDDLE</code>, <code>LAST</code></p><p>如果一个key-value对可以存放在一个block块中，则kFullType=1</p><p>如果某个key-value对过大，单个block块放不下，如上图的Record B就占了3个block块，在block1在Block 1的剩余部分放入Record B的开头一部分，类型标识为FIRST，代表了是一个记录的起始部分；Record B剩下的内容依次放在后续的物理Block里面Block 2全部用来放Record B，且标识类型为MIDDLE，意思是这是Record B中间一段数据；还不够，需要第三个block块 ，Record B剩下的部分可以完全放在Block 3中，类型标识为LAST，代表这是Record B的末尾数据。</p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h2><p>与log日志文件相关的源码：</p><p>db/log_format.h</p><p>db/log_reader.cc</p><p>db/log_reader.h</p><p>db/log_writer.cc</p><p>db/log_writer.h</p><h3 id="leveldb-log命名空间"><a href="#leveldb-log命名空间" class="headerlink" title="leveldb:log命名空间"></a>leveldb:log命名空间</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb {</span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">log</span> {</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RecordType {</span><br><span class="line">  <span class="comment">// Zero is reserved for preallocated files</span></span><br><span class="line">  kZeroType = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  kFullType = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For fragments</span></span><br><span class="line">  kFirstType = <span class="number">2</span>,</span><br><span class="line">  kMiddleType = <span class="number">3</span>,</span><br><span class="line">  kLastType = <span class="number">4</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxRecordType = kLastType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kBlockSize = <span class="number">32768</span>;<span class="comment">//32k</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Header is checksum (4 bytes), length (2 bytes), type (1 byte).</span></span><br><span class="line"><span class="comment">// 其中length最大为kBlockSize=0x8000 - kHeaderSize，因此只使用2个字节存储</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kHeaderSize = <span class="number">4</span> + <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}  <span class="comment">// namespace log</span></span><br><span class="line">}  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></tbody></table></figure><p>leveldb：log下定义的Writer类，封装对log的写入操作：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Write负责组织数据有格式的写入，成员变量dest_负责真正写入数据到文件系统</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span> {</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a writer that will append data to "*dest".</span></span><br><span class="line">  <span class="comment">// "*dest" must be initially empty.</span></span><br><span class="line">  <span class="comment">// "*dest" must remain live while this Writer is in use.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Writer</span><span class="params">(WritableFile* dest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a writer that will append data to "*dest".</span></span><br><span class="line">  <span class="comment">// "*dest" must have initial length "dest_length".</span></span><br><span class="line">  <span class="comment">// "*dest" must remain live while this Writer is in use.</span></span><br><span class="line">  Writer(WritableFile* dest, <span class="keyword">uint64_t</span> dest_length);</span><br><span class="line"></span><br><span class="line">  ~Writer();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//接收数据并调用dest完成写入</span></span><br><span class="line">  <span class="comment">//实现细节：</span></span><br><span class="line">  <span class="comment">//根据slice 及 block剩余大小，可能分成一个或者多个fragment分别写入</span></span><br><span class="line">  <span class="comment">//对于一个fragment格式如下：</span></span><br><span class="line">  <span class="comment">//|crc(4B)  |length(2B)  |type(1B)  |ptr(nB)...  |</span></span><br><span class="line">  <span class="comment">//|--------------header-------------|----data----|</span></span><br><span class="line">  <span class="comment">//其中 type 是一个枚举类型：RecordType</span></span><br><span class="line">  <span class="comment">//{kZeroType kFullType kFirstType kMiddleType kLastType}</span></span><br><span class="line">  <span class="function">Status <span class="title">AddRecord</span><span class="params">(<span class="keyword">const</span> Slice&amp; slice)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  WritableFile* dest_;</span><br><span class="line">  <span class="comment">//每kBlockSize记为一个block，block_offset_记录当前block已经写入的偏移量</span></span><br><span class="line">  <span class="keyword">int</span> block_offset_;       <span class="comment">// Current offset in block</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// crc32c values for all supported record types.  These are</span></span><br><span class="line">  <span class="comment">// pre-computed to reduce the overhead of computing the crc of the</span></span><br><span class="line">  <span class="comment">// record type stored in the header.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> type_crc_[kMaxRecordType + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">EmitPhysicalRecord</span><span class="params">(RecordType type, <span class="keyword">const</span> <span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  Writer(<span class="keyword">const</span> Writer&amp;);</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Writer&amp;);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="AddRecord函数，将数据写入底层文件"><a href="#AddRecord函数，将数据写入底层文件" class="headerlink" title="AddRecord函数，将数据写入底层文件"></a>AddRecord函数，将数据写入底层文件</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::AddRecord</span><span class="params">(<span class="keyword">const</span> Slice&amp; slice)</span> </span>{</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* ptr = slice.data();</span><br><span class="line">  <span class="keyword">size_t</span> left = slice.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fragment the record if necessary and emit it.  Note that if slice</span></span><br><span class="line">  <span class="comment">// is empty, we still want to iterate once to emit a single</span></span><br><span class="line">  <span class="comment">// zero-length record</span></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">bool</span> <span class="built_in">begin</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> {</span><br><span class="line">    <span class="comment">//leftover记录block当前可用大小</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> leftover = kBlockSize - block_offset_;<span class="comment">//当前32kb块的剩余量</span></span><br><span class="line">    assert(leftover &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//如果block可用大小已经无法写入header，那么补充\x00</span></span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) {</span><br><span class="line">      <span class="comment">// Switch to a new block</span></span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">        assert(kHeaderSize == <span class="number">7</span>);</span><br><span class="line">        <span class="comment">//Slice构造函数第二个参数表示字符串长度，因此效果上是leftover个'\x00'</span></span><br><span class="line">        <span class="comment">//leftover size最大为6，因此第一个参数指定6个'\x00'</span></span><br><span class="line">        dest_-&gt;Append(Slice(<span class="string">"\x00\x00\x00\x00\x00\x00"</span>, leftover));</span><br><span class="line">      }</span><br><span class="line">      block_offset_ = <span class="number">0</span>;<span class="comment">//更换新快</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span></span><br><span class="line">    <span class="comment">// block还有剩余可用空间让我们写入一部分数据</span></span><br><span class="line">    <span class="comment">// 如果 = 0，也就是剩余只能写入header，那也写入（只是此时不会写入slice里任何数据）</span></span><br><span class="line">    assert(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可用大小为kBlockSize - block_offset_，减去header大小即为可写的数据大小</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line">    <span class="comment">//能够全部写入则=left，否则等于可写大小</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line"></span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="built_in">end</span> = (left == fragment_length);<span class="comment">//相等表示本次可以全部写入</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">begin</span> &amp;&amp; <span class="built_in">end</span>) {</span><br><span class="line">      type = kFullType;<span class="comment">//数据能够一次写入</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">begin</span>) {</span><br><span class="line">      type = kFirstType;<span class="comment">//数据无法一次写入时，标记首次写入</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">end</span>) {</span><br><span class="line">      type = kLastType;<span class="comment">//数据无法一次写入时，标记最后一次写入</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      type = kMiddleType;<span class="comment">//数据无法一次写入时，标记中间写入</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    s = EmitPhysicalRecord(type, ptr, fragment_length);</span><br><span class="line">    ptr += fragment_length;<span class="comment">//下一次slice待写入位置</span></span><br><span class="line">    left -= fragment_length;<span class="comment">//slice还有多少没有写</span></span><br><span class="line">    <span class="built_in">begin</span> = <span class="literal">false</span>;</span><br><span class="line">  } <span class="keyword">while</span> (s.ok() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="EmitPhysicalRecord函数"><a href="#EmitPhysicalRecord函数" class="headerlink" title="EmitPhysicalRecord函数"></a>EmitPhysicalRecord函数</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写入header data到底层文件(调用flush确保写入)</span></span><br><span class="line"><span class="comment">//|crc(4B)  |length(2B)  |type(1B)  |ptr(nB)...  |</span></span><br><span class="line"><span class="comment">//|--------------header-------------|----data----|</span></span><br><span class="line"><span class="function">Status <span class="title">Writer::EmitPhysicalRecord</span><span class="params">(RecordType t, <span class="keyword">const</span> <span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> n)</span> </span>{</span><br><span class="line">  <span class="comment">//assert这里对应n要使用buf[4, 5]存储，一共两个字节，因此大小应当&lt;=0xffff</span></span><br><span class="line">  assert(n &lt;= <span class="number">0xffff</span>);  <span class="comment">// Must fit in two bytes</span></span><br><span class="line">  <span class="comment">//要写入的数据大小一定能够写入(不大于kBlockSize)</span></span><br><span class="line">  assert(block_offset_ + kHeaderSize + n &lt;= kBlockSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Format the header</span></span><br><span class="line">  <span class="keyword">char</span> buf[kHeaderSize];</span><br><span class="line">  <span class="comment">//长度使用两个字节(buf[4, 5])存储，其中4存储低两位，5存储高两位,小端序</span></span><br><span class="line">  <span class="comment">//例如n=0x6789，则buf[4]=0x89，buf[5]=0x67</span></span><br><span class="line">  buf[<span class="number">4</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(n &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">5</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(n &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  <span class="comment">//buf[6]存储类型</span></span><br><span class="line">  buf[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(t);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算crc: Extend(type_crc, ptr) -&gt; Mask -&gt; EncodeFixed32</span></span><br><span class="line">  <span class="comment">// Compute the crc of the record type and the payload.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> crc = crc32c::Extend(type_crc_[t], ptr, n);</span><br><span class="line">  crc = crc32c::Mask(crc);                 <span class="comment">// Adjust for storage</span></span><br><span class="line">  EncodeFixed32(buf, crc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write the header and the payload</span></span><br><span class="line">  <span class="comment">// 首先写入header: |crc    |length  |type |，大小为kHeaderSize</span></span><br><span class="line">  Status s = dest_-&gt;Append(Slice(buf, kHeaderSize));</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">    <span class="comment">//接着写入数据，大小为n</span></span><br><span class="line">    s = dest_-&gt;Append(Slice(ptr, n));</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">      s = dest_-&gt;Flush();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  block_offset_ += kHeaderSize + n;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个函数的函数体首先检查数据的大小是否小于等于2个字节，接着计算CRC，然后将header数据（|crc  |length |type |，大小为kHeaderSize）写入dest_中，接着写入数据，长度为n。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>本篇博客介绍了leveldb中的log日志文件的结构、逻辑布局和物理布局，分析其源码和主要的几个函数。弄清楚一次写入操作是如何执行的。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201216215542423.png" alt="image-20201216215542423"></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201216215741019.png" alt="image-20201216215741019"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb源码学习记录-整体架构</title>
      <link href="/posts/41b.html"/>
      <url>/posts/41b.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-开篇"><a href="#0-开篇" class="headerlink" title="0.开篇"></a>0.开篇</h2><p>leveldb是一个高性能、可靠的单机KV数据库。</p><p>一个高性能的单机数据库，往往是如何平衡读性能、写性能、存储大小的问题，思考这个问题，才能够理解 leveldb 的<code>write-ahead logging</code> <code>MemTable</code> <code>SSTable</code>等设计。leveldb 正是通过这一系列架构设计和代码技巧，提供了一个优秀的存储引擎解决这个问题。</p><p>本系列文章是自己阅读leveldb源码过程中记录的一些笔记，方便日后查看。</p><a id="more"></a><p>这篇文章转载自：<a href="https://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html" target="_blank" rel="noopener">https://www.cnblogs.com/haippy/archive/2011/12/04/2276064.html</a></p><h2 id="1-整体架构"><a href="#1-整体架构" class="headerlink" title="1.整体架构"></a>1.整体架构</h2><p> LevelDb作为存储系统，数据记录的存储介质包括内存以及磁盘文件，如果像上面说的，当LevelDb运行了一段时间，此时我们给LevelDb进行透视拍照，那么您会看到如下一番景象：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/2011121116344075.png" alt="leveldb结构"></p><p>从图中可以看出，构成 LevelDB 静态结构的包括六个主要部分：内存中的 <strong>MemTable</strong> 和 <strong>Immutable MemTable</strong> 以及磁盘上的几种主要文件：<strong>Current文件</strong>，<strong>Manifest文件</strong>，<strong>log文件</strong>以及 <strong>SSTable 文件</strong>。当然，LevelDB 除了这六个主要部分还有一些辅助的文件，但是以上六个文件和数据结构是 LevelDB 的主体构成元素。</p><p>当应用写入一条Key:Value记录的时候，LevelDb会先往log文件里写入，成功后将记录插进Memtable中，这样基本就算完成了写入操作，因为一次写入操作只涉及一次磁盘顺序写和一次内存写入，所以这是为何说LevelDb写入速度极快的主要原因。</p><p>SSTable 就是由内存中的数据不断导出并进行 Compaction 操作后形成的，而且 SSTable 的所有文件是一种层级结构，第一层为Level 0，第二层为Level 1，依次类推，层级逐渐增高。</p><p>SSTable 中的文件(后缀为.sst)是 key 有序的，就是说在文件中小 key 记录排在大 key 记录之前，除了 level 0，各个 level 的 SSTable 都是如此。</p><h2 id="2-mainfest文件"><a href="#2-mainfest文件" class="headerlink" title="2.mainfest文件"></a>2.mainfest文件</h2><p>SSTable 中的某个文件属于特定层级，而且其存储的记录是 key 有序的，那么必然有文件中的最小 key 和最大 key，这是非常重要的信息，LevelDB 应该记下这些信息。<strong>manifest</strong> 就是干这个的，它记载了 SSTable 各个文件的管理信息，比如属于哪个 level，文件名称叫啥，最小 key 和最大 key 各自是多少。下图是 manifest 所存储内容的示意：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-02.png" alt="Manifest存储示意图"></p><p>图中只显示了两个文件（manifest 会记载所有 SSTable 文件的这些信息），即 level 0 的 Test1.sst 和 Test2.sst 文件，同时记载了这些文件各自对应的 key 范围，比如 Test1.sst 的 key 范围是 “abc” 到 “hello”，而文件 Test2.sst 的 key 范围是 “bbc” 到 “world”，可以看出两者的 key 范围是有重叠的。</p><h2 id="3-current文件"><a href="#3-current文件" class="headerlink" title="3.current文件"></a>3.current文件</h2><p>这个文件的内容只有一个信息，就是记载当前的 manifest 文件名。因为在 LevleDB 的运行过程中，随着 compaction 的进行，SSTable 文件会发生变化，会有新的文件产生，老的文件被废弃，manifest 也会跟着反映这种变化，此时往往会新生成 manifest 文件来记载这种变化，而 current 则用来指出哪个 manifest 文件才是我们关心的那个 manifest文件。</p><h2 id="4-log文件"><a href="#4-log文件" class="headerlink" title="4.log文件"></a>4.log文件</h2><p>log 文件在 LevelDB 中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的 memtable 之前，会先写入 log 文件，这样即使系统发生故障，memtable 中的数据没有来得及 dump 到磁盘的 SSTable 文件，LevelDB 也可以根据 log 文件恢复内存的 Memtable 数据结构内容，不会造成系统丢失数据。</p><p>LevelDB 对于一个 log 文件，会把它切割成以 32K 为单位的物理 Block，每次读取以一个 Block 作为基本读取单位，下图展示的 log 文件由3个 Block 构成，所以从物理布局来讲，一个 log 文件就是由连续的 32K 大小 Block 构成的。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-03.png" alt="log文件布局"></p><p>log 文件中的数据是以 block 为单位组织，写日志时，处于一致性考虑并没有按 block 单位写，每次更新均对 log 文件进行 IO，每次更新写入作为一个 record，每条 record 的结构如下图所示：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-04.png" alt="记录结构"></p><p><code>checksum</code> 记录的是 “type” 和 “data” 字段的CRC校验，为了避免处理不完整或者是被破坏的数据，当 LevelDB 读取记录数据时候会对数据进行校验，如果发现和存储的 checksum 相同，说明数据完整无破坏，可以继续后续流程。</p><p><code>length</code> 记录的是 record 内保存的 data 长度(小端对齐)。</p><p><code>data</code> 记录的是 Key:Value 数值对.</p><p><code>type</code> 字段则指出了每条记录的逻辑结构和 log 文件物理分块结构之间的关系，具体而言，主要有以下四种类型：<code>FULL</code>, <code>FIRST</code>, <code>MIDDLE</code>, <code>LAST</code>。如果记录类型是FULL，代表了当前记录内容完整地存储在一个物理Block里，没有被不同的物理Block切割开；如果记录被相邻的物理Block切割开，则类型会是其他三种类型中的一种。我们以log文件布局所示的例子来具体说明。</p><p><font color="orange">&gt;假设目前存在三条记录，Record A，Record B 和 Record C，其中 Record A 大小为10K，Record B 大小为80K，Record C大小为12K</font>那么其在 log 文件中的逻辑布局会如上面的图所示。Record A是图中蓝色区域所示，因为大小为10K&lt;32K，能够放在一个物理Block中，所以其类型为FULL；Record B 大小为80K，而Block 1因为放入了Record A，所以还剩下22K，不足以放下Record B，所以在Block 1的剩余部分放入Record B的开头一部分，类型标识为FIRST，代表了是一个记录的起始部分；Record B还有58K没有存储，这些只能依次放在后续的物理Block里面，因为Block 2大小只有32K，仍然放不下Record B的剩余部分，所以Block 2全部用来放Record B，且标识类型为MIDDLE，意思是这是Record B中间一段数据；Record B剩下的部分可以完全放在Block 3中，类型标识为LAST，代表了这是Record B的末尾数据；图中黄色的Record C因为大小为12K，Block 3剩下的空间足以全部放下它，所以其类型标识为FULL。</p><p>   从这个小例子可以看出逻辑记录和物理Block之间的关系，LevelDB一次物理读取为一个Block，然后根据类型情况拼接出逻辑记录，供后续流程处理。</p><h2 id="5-sstable文件"><a href="#5-sstable文件" class="headerlink" title="5.sstable文件"></a>5.sstable文件</h2><p>    LevelDB 不同层级有很多 SSTable 文件（以后缀.sst为特征），所有 .sst 文件内部布局都是一样的。上节介绍 log 文件是物理分块的，SSTable也一样会将文件划分为固定大小的物理存储块，但是两者逻辑布局大不相同，根本原因是：log文件中的记录是 Key 无序的，即先后记录的 key 大小没有明确大小关系，而 .sst 文件内部则是根据记录的 Key 由小到大排列的。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-05.png" alt=".sst文件的分块结构"></p><p><font color="orange">上图展示了一个 .sst 文件的物理划分结构，同 log 文件一样，也是划分为固定大小的存储块，每个 Block 分为三个部分：<strong>数据存储区</strong>，<strong>Type 区</strong>用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩），<strong>CRC校验</strong>则是数据校验码，用于判别数据在生成和传输中是否出错。</font></p><p>以上是.sst的物理布局，下面介绍.sst文件的逻辑布局，所谓逻辑布局，就是说尽管大家都是物理块，但是每一块存储什么内容，内部又有什么结构等。下图展示了.sst文件的内部逻辑解释。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-06.png" alt="逻辑布局"></p><p>​         从上图可以看出，从大的方面，可以将 .sst文 件划分为<strong>数据存储区</strong>和<strong>数据管理区</strong>，数据存储区存放实际的 key-value 数据，数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储 KV 数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：<strong>Meta Block</strong>，<strong>MetaBlock 索引</strong>和<strong>数据索引块</strong>以及一个<strong>文件尾部块</strong>。</p><p><code>data_block</code>：实际存储的 KV 数据。<br><code>meta_block</code>：每个 data_block 对应一个 meta_block，保存 data_block 中的 key size/value size/kv counts 之类的统计信息，当前版本未实现。<br><code>metaindex_block</code>：保存 meta_block 的索引信息，当前版本未实现。<br><code>index_block</code>：保存每个 data_block 的 last_key 及其在 SSTable 文件中的索引。block 中 entry 的 key 即是 last_key(依赖于FindShortestSeparator()/FindShortSuccessor()的实现)，value即是该data_block的BlockHandler（offset/size）。<br><code>footer</code>：文件末尾固定长度的数据。保存着 metaindex_block 和 index_block 的索引信息(BlockHandler)，为达到固定的长度，添加 padding_bytes。最后有8个字节的 magic 校验。</p><hr><p>footer 的结构如下图所示：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-07.png" alt="Footer"></p><p><code>metaindex_block_handle</code> 指出了 metaindex block 的起始位置和大小；<code>index_block_handle</code> 指出了 index Block 的起始地址和大小；这两个字段可以理解为索引的索引，是为了正确读出索引值而设立的；为达到固定的长度，添加 <code>padding_bytes</code>。最后有8个字节的 <code>magic</code> 校验。</p><p>下图是数据索引块的内部结构示意图：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-08.png" alt="数据索引"></p><p>Data Block 内的 KV 记录是按照 key 由小到大排列的，数据索引区的每条记录是对某个 Data Block 建立的索引信息，每条索引信息包含三个内容。以上图所示的数据块 i 的索引 index i 来说：</p><p><strong>第一个字段</strong>：记录大于等于数据块i中最大的 key 值的那个 key。在索引里保存的这个 key 值未必一定是某条记录的 key，以上的例子来说，假设数据块i的最小key=“samecity”，最大key=“the best”；数据块i+1的最小key=“the fox”，最大key=“zoo”，那么对于数据块i的索引 index i 来说，其第一个字段记载大于等于数据块i的最大Key(“the best”) 同时要小于数据块i+1的最小Key(“the fox”)，所以例子中 index i 的第一个字段是 “the c”，这个是满足要求的；而 index i+1 的第一个字段则是 “zoo”，即数据块i+1的最大 key。</p><p><strong>第二个字段</strong>：指出数据块 i 在 .sst 文件中的起始位置。</p><p><strong>第三个字段</strong>：指出 Data Block i 的大小（有时候是有数据压缩的）。</p><p>上面主要介绍的是数据管理区的内部结构，下图是数据区的一个 Block 的数据部分布局。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-09.png" alt="img"></p><p>从图中可以看出，其内部也分为两个部分，前面是一个个 KV 记录，其顺序是根据 key 值由小到大排列的，在Block尾部则是一些“重启点”（Restart Point），其实是一些指针，指出 Block 内容中的一些记录位置。</p><p>“重启点”是干什么的呢？Block内容里的KV记录是按照 key 大小有序的，这样的话，相邻的两条记录很可能 key 部分存在重叠，比如 key i=“the Car”，Key i+1=“the color”，那么两者存在重叠部分 “the c”，为了减少 key 的存储量，Key i+1 可以只存储和上一条 key 不同的部分 “olor”，两者的共同部分从 key i 中可以获得。记录的 key 在 Block 内容部分就是这么存储的，主要目的是减少存储开销。“重启点”的意思是：在这条记录开始，不再采取只记载不同的 key 部分，而是重新记录所有的 key 值，假设 key i+1 是一个重启点，那么 key 里面会完整存储 “the color”，而不是采用简略的“olor”方式。Block尾部就是指出哪些记录是这些重启点的。</p><p>其中记录的格式如下所示：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-10.png" alt="记录格式"></p><p>每个记录包含5个字段：</p><p><strong>key共享长度</strong>：比如上面的 “olor” 记录， 其 key 和上一条记录共享的 key 部分长度是 “the c” 的长度，即5；</p><p><strong>key非共享长度</strong>：对于“olor”来说，是4；</p><p><strong>value长度</strong>：指出 key-value 中 value 的长度，在后面的 value 内容字段中存储实际的 value 值；</p><p><strong>key非共享内容</strong>：指实际存储 “olor” 这个 key 字符串；</p><p><strong>value内容</strong>：存储实际的 value 值。</p><h2 id="6-memtable"><a href="#6-memtable" class="headerlink" title="6.memtable"></a>6.memtable</h2><p>所有 KV 数据都是存储在 Memtable，Immutable Memtable 和 SSTable 中的，Immutable Memtable从结构上讲和 Memtable 是完全一样的，区别仅仅在于其是只读的，不允许写入操作，而 Memtable 则是允许写入和读取的。当 Memtable 写入的数据占用内存到达指定数量，则自动转换为 Immutable Memtable，等待 Dump 到磁盘中，系统会自动生成新的 Memtable 供写操作写入新数据，理解了 Memtable，那么 Immutable Memtable 自然不在话下。</p><p>LevelDB 的 MemTable 提供了将 KV 数据写入，删除以及读取 KV 记录的操作接口，但是事实上 Memtable 并不存在真正的删除操作,删除某个Key的Value在 Memtable 内是作为插入一条记录实施的，但是会打上一个 Key 的删除标记，真正的删除操作是Lazy的，会在以后的 Compaction 过程中去掉这个KV。</p><p>需要注意的是，LevelDB 的 Memtable 中KV对是根据key大小有序存储的，在系统插入新的KV时，LevelDB 要把这个KV插到合适的位置上以保持这种 Key 有序性。其实，LevelDB 的 Memtable 类只是一个接口类，真正的操作是通过背后的 SkipList 来做的，包括插入操作和读取操作等，所以 Memtable 的核心数据结构是一个 SkipList。</p><p>SkipList是由 William Pugh 发明。他在 Communications of the ACM June 1990, 33(6) 668-676 发表了 Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了SkipList的数据结构和插入删除操作。关于SkipList的详细介绍可以参考这篇文章：<a href="http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html。" target="_blank" rel="noopener">http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html。</a></p><h2 id="7-读操作"><a href="#7-读操作" class="headerlink" title="7.读操作"></a>7.读操作</h2><p>LevelDB 的读取流程如下所示：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-11.png" alt="LevelDB读取记录流程"></p><p>LevelDB 首先会去查看内存中的 Memtable，如果 Memtable 中包含 key 及其对应的value，则返回 value 值即可；</p><p>如果在 Memtable 没有读到key，则接下来到同样处于内存中的 Immutable Memtable 中去读取，类似地，如果读到就返回，若是没有读到,那么只能万般无奈下从磁盘中的大量SSTable文件中查找。</p><p>因为SSTable数量较多，而且分成多个level，所以在SSTable中读数据是相当蜿蜒曲折的一段旅程。总的读取原则是这样的：首先从属于 level 0 的文件中查找，如果找到则返回对应的value值，如果没有找到那么到 level 1 中的文件中去找，如此循环往复，直到在某层 SSTable 文件中找到这个 key 对应的 value 为止（或者查到最高level，查找失败，说明整个系统中不存在这个Key)。</p><p>如果给定一个要查询的 key 和某个 key range 包含这个key的 SSTable 文件，那么 LevelDB 是如何进行具体查找过程的呢？LevelDB 一般会先在内存中的Cache中查找是否包含这个文件的缓存记录，如果包含，则从缓存中读取；如果不包含，则打开SSTable文件，同时将这个文件的索引部分加载到内存中并放入Cache中。 这样Cache里面就有了这个SSTable的缓存项，但是只有索引部分在内存中，之后 LevelDB 根据索引可以定位到哪个内容Block会包含这条key，从文件中读出这个Block的内容，在根据记录一一比较，如果找到则返回结果，如果没有找到，那么说明这个level的 SSTable 文件并不包含这个key，所以到下一级别的 SSTable 中去查找。</p><h2 id="8-Compaction"><a href="#8-Compaction" class="headerlink" title="8.Compaction"></a>8.Compaction</h2><p>LevelDB 包含其中两种 compaction 模式：minor 和 major。所谓 <strong>minor Compaction</strong>，就是把 memtable 中的数据导出到 SSTable 文件中；<strong>major compaction</strong> 就是合并不同层级的 SSTable 文件。</p><p><strong>minor Compaction</strong></p><p>Minor compaction 的目的是当内存中的 memtable 大小到了一定值时，将内容保存到磁盘文件中。其机理如下图所示：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-12.png" alt="Minor compaction"></p><p>当 memtable 数量到了一定程度会转换为 immutable memtable，此时不能往其中写入记录，只能从中读取KV内容。之前介绍过，immutable memtable 其实是一个多层级队列SkipList，其中的记录是根据 key 有序排列的。所以这个 minor compaction 实现起来也很简单，就是按照 immutable memtable 中记录由小到大遍历，并依次写入一个 level 0 的新建 SSTable 文件中，写完后建立文件的 index 数据，这样就完成了一次minor compaction。</p><p>从上图中也可以看出，对于被删除的记录，在 minor compaction 过程中并不真正删除这个记录，原因也很简单，这里只知道要删掉 key 记录，但是这个 KV 数据在哪里？那需要复杂的查找，所以在 minor compaction 的时候并不做删除，只是将这个 key 作为一个记录写入文件中，至于真正的删除操作，在以后更高层级的 compaction 中会去做。</p><p><strong>major compaction</strong></p><p>当某个 level 下的 SSTable 文件数目超过一定设置值后，levelDB 会从这个 level 的 SSTable 中选择一个文件（level&gt;0），将其和高一层级的 level+1 的 SSTable 文件合并，这就是 major compaction。</p><p>在大于 0 的层级中，每个 SSTable 文件内的key都是由小到大有序存储的，而且不同文件之间的key范围（文件内最小key和最大key之间）不会有任何重叠。level 0 的 SSTable 文件有些特殊，尽管每个文件也是根据Key由小到大排列，但是因为 level 0 的文件是通过 minor compaction 直接生成的，所以任意两个 level 0下的两个 SSTable 文件可能再key范围上有重叠。所以在做 major compaction 的时候，对于大于 level 0 的层级，选择其中一个文件就行，但是对于 level 0 来说，指定某个文件后，本 level 中很可能有其他 SSTable 文件的 key 范围和这个文件有重叠，这种情况下，要找出所有有重叠的文件和 level 1 的文件进行合并，即 level 0 在进行文件选择的时候，可能会有多个文件参与 major compaction。</p><p>LevelDB 在选定某个 level 进行 compaction 后，还要选择是具体哪个文件要进行 compaction，LevelDB 在这里有个小技巧， 就是说轮流来，比如这次是文件A进行 compaction，那么下次就是在 key range 上紧挨着文件A的文件B进行 compaction，这样每个文件都会有机会轮流和高层的 level 文件进行合并。</p><p>如果选好了 level i 的文件A和 level i+1 层的文件进行合并，那么问题又来了，应该选择 level i+1 哪些文件进行合并？LevelDB 选择 i+1 层中和文件A在 key range 上有重叠的所有文件来和文件A进行合并。</p><p>也就是说，选定了 level i 的文件A，之后在 level i+1 中找到了所有需要合并的文件B,C,D… 等等。剩下的问题就是具体是如何进行 major 合并的？就是说给定了一系列文件，每个文件内部是key有序的，如何对这些文件进行合并，使得新生成的文件仍然Key有序，同时抛掉哪些不再有价值的 KV 数据。</p><p>下图所示的是合并过程：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-13.png" alt="SSTable compaction"></p><p>major compaction 的过程如下：对多个文件采用多路归并排序的方式，依次找出其中最小的key记录，也就是对多个文件中的所有记录重新进行排序。之后采取一定的标准判断这个key是否还需要保存，如果判断没有保存价值，那么直接抛掉，如果觉得还需要继续保存，那么就将其写入 level i+1 层中新生成的一个 SSTable 文件中。就这样对KV数据一一处理，形成了一系列新的 i+1 层数据文件，之前的 i 层文件和 i+1 层参与 compaction 的文件数据此时已经没有意义了，所以全部删除。这样就完成了 i 层和 i+1 层文件记录的合并过程。</p><p>那么在 major compaction 过程中，判断一个KV记录是否抛弃的标准是什么呢？其中一个标准是:对于某个key来说，如果在小于 i 层中存在这个key，那么这个KV在major compaction 过程中可以抛掉。因为，对于层级低于 i 的文件中如果存在同一 key 的记录，那么说明对于 key 来说，有更新鲜的 value 存在，那么过去的 value 就等于没有意义了，所以可以删除。</p><h2 id="9-cache"><a href="#9-cache" class="headerlink" title="9.cache"></a>9.cache</h2><p>读取操作如果没有在内存的 memtable 中找到记录，要多次进行磁盘访问操作。假设最优情况，即第一次就在 level 0 中最新的文件中找到了这个 key，那么也需要读取2次磁盘，一次是将 SSTable 的文件中的 index 部分读入内存，这样根据这个 index 可以确定 key 是在哪个 block 中存储；第二次是读入这个 block 的内容，然后在内存中查找 key 对应的 value。</p><p>LevelDB 中引入了两个不同的 Cache:Table Cache 和 Block Cache。其中 Block Cache 是配置可选的，即在配置文件中指定是否打开这个功能。</p><p>下图是 table cache 的结构：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-14.png" alt="SSTable compaction">!</p><p>在 Cache 中，key值是 SSTable 的文件名称，value 部分包含两部分，一个是指向磁盘打开的 SSTable 文件的文件指针，这是为了方便读取内容；另外一个是指向内存中这个 SSTable 文件对应的 Table 结构指针，table结构在内存中，保存了 SSTable 的 index 内容以及用来指示 block cache 用的 cache_id ，当然除此外还有其它一些内容。</p><p>比如在 get(key) 读取操作中，如果 LevelDB 确定了key在某个level下某个文件A的key range范围内，那么需要判断是不是文件A真的包含这个KV。此时，LevelDB 会首先查找 Table Cache，看这个文件是否在缓存里，如果找到了，那么根据 index 部分就可以查找是哪个 block 包含这个 key。如果没有在缓存中找到文件，那么打开 SSTable 文件，将其 index 部分读入内存，然后插入 Cache 里面，去 index 里面定位哪个 block 包含这个 key 。如果确定了文件哪个 block 包含这个 key，那么需要读入 block 内容，这是第二次读取。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-15.png" alt="SSTable compaction"></p><p>Block Cache是为了加快这个过程的。上图是block cache 的结构。其中的key是文件的cache_id加上这个block在文件中的起始位置block_offset。而value则是这个Block的内容。</p><p>如果 LevelDB发现这个 block 在 block cache 中，那么可以避免读取数据，直接在 cache 里的 block 内容里面查找key的value就行，如果没找到呢？那么读入 block 内容并把它插入 block cache 中。LevelDB 就是这样通过两个 cache 来加快读取速度的。从这里可以看出，如果读取的数据局部性比较好，也就是说要读的数据大部分在cache里面都能读到，那么读取效率应该还是很高的，而如果是对key进行顺序读取效率也应该不错，因为一次读入后可以多次被复用。但是如果是随机读取，您可以推断下其效率如何。</p><h2 id="10-Version"><a href="#10-Version" class="headerlink" title="10.Version"></a>10.Version</h2><p><strong>Version</strong> 保存了当前磁盘以及内存中所有的文件信息，一般只有一个 Version 叫做 “current” version（当前版本）。LevelDB还保存了一系列的历史版本，这些历史版本有什么作用呢？</p><p>当一个 Iterator 创建后，Iterator 就引用到了 current version(当前版本)，只要这个 Iterator 不被 delete 那么被 Iterator 引用的版本就会一直存活。这就意味着当你用完一个 Iterator 后，需要及时删除它。</p><p>当一次 Compaction 结束后（会生成新的文件，合并前的文件需要删除），LevelDB 会创建一个新的版本作为当前版本，原先的当前版本就会变为历史版本。</p><p><strong>VersionSet</strong> 是所有 Version的集合，管理着所有存活的 Version。</p><p><strong>VersionEdit</strong> 表示 Version 之间的变化，相当于 delta 增量，表示有增加了多少文件，删除了文件。他们之间的关系如下：</p><p><code>Version0 +VersionEdit--&gt;Version1</code></p><p>VersionEdit 会保存到 manifest 文件中，当做数据恢复时就会从 manifest 文件中读出来重建数据。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb性能测试</title>
      <link href="/posts/65b3.html"/>
      <url>/posts/65b3.html</url>
      
        <content type="html"><![CDATA[<h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p>CPU:   48 * Intel(R) Xeon(R) CPU E5-2678 v3 @ 2.50GHz</p><p>memory：64G</p><a id="more"></a><h3 id="开始测试"><a href="#开始测试" class="headerlink" title="开始测试"></a>开始测试</h3><p>A、一百万条记录测试</p><p>执行<code>./db_bench --num=1000000 --write_buffer_size=$((256*1024*1024))</code></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201206152943040.png" alt="image-20201206152943040"></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201206153009165.png" alt="image-20201206153009165"></p><p>B、一千万条记录测试</p><p>执行<code>./db_bench --num=10000000 --write_buffer_size=$((256*1024*1024))</code>     memtable的大小</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201206154938272.png" alt="image-20201206154938272"></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201206154950809.png" alt="image-20201206154950809"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb学习记录-编码</title>
      <link href="/posts/c42826bf.html"/>
      <url>/posts/c42826bf.html</url>
      
        <content type="html"><![CDATA[<p>计算机硬件有两种数据存储的方式：大端字节序和小端字节序</p><p>举例来说，数值<code>0x2211</code>使用两个字节储存：高位字节是<code>0x22</code>，低位字节是<code>0x11</code>。</p><blockquote><ul><li>大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。</li><li>小端字节序：低位字节在前，高位字节在后，即以<code>0x1122</code>形式储存。</li></ul></blockquote><p>编码分为变长的VarInt和固定大小的FixedInt两种，每种分32位和64位。</p><a id="more"></a><h3 id="变长编码"><a href="#变长编码" class="headerlink" title="变长编码"></a>变长编码</h3><p>为了节省空间，设计了一种varint变长编码方式来表示整型，越小的数字所占用的字节数越少。不采用变长编码，存放一个int类型的1，一般情况下需要4个字节，采用变长编码后，仅需要1个字节就可以保存。leveldb的变长编码也是采用小端序</p><blockquote><p>Varint 中的每个 byte 的最高位 bit 是标识位有特殊的含义。 如果该位为 1，表示后续的 byte 也是该数字的一部分，<br>如果该位为 0，则结束。 其他的 7 个 bit 都用来表示数字。</p></blockquote><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201215163019921.png" alt="image-20201215163019921"></p><p><font color="orange">编码过程和解码过程举例</font>：</p><h4 id="编码过程："><a href="#编码过程：" class="headerlink" title="编码过程："></a>编码过程：</h4><p>假设一个待表示的数为1000，二进制表示为==111== 1101000</p><p>字节1：取最右边的7bit，1101000，高位补0凑成一个字节：<font color="orange">0</font>110 1000</p><p>字节2：剩下的是==111==,同样高位补0，0000 0111</p><p>字节1最高bit位标识为1，表示后续的byte也是该数字的一部分。</p><p>字节2最高bit位标识为0。</p><p>故最终的编码结果为：</p><p><font color="red"> 1</font>110 1000 0000 0==111==</p><h4 id="解码过程："><a href="#解码过程：" class="headerlink" title="解码过程："></a>解码过程：</h4><p>读取第一个字节，发现其最高bit位为1，表示还有后续，与下一字节一同表示同一个数值。将最高bit位变为0后，第一个字节：0110 1000</p><p>下一个字节：0000 0==111==</p><p>按照小端序，字节交换后位置结果是：==111== 1101000 =》十进制为1000</p><h2 id="leveldb中的实现"><a href="#leveldb中的实现" class="headerlink" title="leveldb中的实现"></a>leveldb中的实现</h2><h4 id="【编码】"><a href="#【编码】" class="headerlink" title="【编码】"></a>【编码】</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>{</span><br><span class="line">  <span class="comment">// Operate on characters as unsigneds</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;<span class="comment">//0x80，用来设置一个字节的最高位</span></span><br><span class="line">  <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">7</span>)) {</span><br><span class="line">    *(ptr++) = v;</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">14</span>)) {</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = v&gt;&gt;<span class="number">7</span>;</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">21</span>)) {</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = v&gt;&gt;<span class="number">14</span>;</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">28</span>)) {</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">14</span>) | B;</span><br><span class="line">    *(ptr++) = v&gt;&gt;<span class="number">21</span>;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">14</span>) | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">21</span>) | B;</span><br><span class="line">    *(ptr++) = v&gt;&gt;<span class="number">28</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint64</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint64_t</span> v)</span> </span>{</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">while</span> (v &gt;= B) {</span><br><span class="line">    *(ptr++) = (v &amp; (B<span class="number">-1</span>)) | B;</span><br><span class="line">    v &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">  }</span><br><span class="line">  *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(v);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="【解码】"><a href="#【解码】" class="headerlink" title="【解码】"></a>【解码】</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetVarint32</span><span class="params">(Slice* input, <span class="keyword">uint32_t</span>* value)</span> </span>{</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* p = input-&gt;data();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* limit = p + input-&gt;<span class="built_in">size</span>();</span><br><span class="line">  <span class="comment">//encode后的值存储到value，返回剩余的字符串</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* q = GetVarint32Ptr(p, limit, value);</span><br><span class="line">  <span class="keyword">if</span> (q == <span class="literal">nullptr</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">//修改input，存储剩余的字符串</span></span><br><span class="line">    *input = Slice(q, limit - q);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetVarint32Ptr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span>* value)</span> </span>{</span><br><span class="line">  <span class="keyword">if</span> (p &lt; limit) {</span><br><span class="line">    <span class="keyword">uint32_t</span> result = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(p));</span><br><span class="line">    <span class="comment">//对小整数的优化，只有原整数&lt;128，编码后的result才满足result&amp;128 == 0</span></span><br><span class="line">    <span class="keyword">if</span> ((result &amp; <span class="number">128</span>) == <span class="number">0</span>) {<span class="comment">//与128相与为0表示待解码的result&lt;=127，所以长度就是一个字节直接赋值给*Value即可。</span></span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> GetVarint32PtrFallback(p, limit, value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetVarint32PtrFallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint32_t</span>* value)</span> </span>{</span><br><span class="line">    <span class="comment">//对于超过一个字节的长度编码，解码的过程就是按小端顺序，每7位取出，然后移位来组装最后的实际长度，组装结束的表示就是MSB位为0</span></span><br><span class="line">  <span class="keyword">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">28</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) {</span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">byte</span> = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p));  </span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">byte</span> &amp; <span class="number">128</span>) { <span class="comment">//后面还有字节</span></span><br><span class="line">      <span class="comment">// More bytes are present</span></span><br><span class="line">      result |= ((<span class="keyword">byte</span> &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">    } <span class="keyword">else</span> { <span class="comment">//最后的字节</span></span><br><span class="line">      result |= (<span class="keyword">byte</span> &lt;&lt; shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(p);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>leveldb封装了一个Put函数，便于用户调用</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutVarint32</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>{</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">char</span>* ptr = EncodeVarint32(buf, v);</span><br><span class="line">  <span class="comment">//写入encode后的值(大小为ptr - buf)</span></span><br><span class="line">  dst-&gt;append(buf, ptr - buf);<span class="comment">//将编码结果保存在dst中</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里申请的buffer缓冲区大小为5个字节，因为变长编码的范围，对于32位（<code>Varint32</code>）整形数经变长编码后占用1<del>5个Byte，小的数字用1个字节，大的数字0xffff ffff用5个字节。<br>对于64为（<code>Varint64</code>）整形数经变长编码后占用1</del>10个Byte，小的数字用1个字节，大的数字用10个字节。</p><h4 id="PutLengthPrefixedSlice函数"><a href="#PutLengthPrefixedSlice函数" class="headerlink" title="PutLengthPrefixedSlice函数"></a>PutLengthPrefixedSlice函数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutLengthPrefixedSlice</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">const</span> Slice&amp; value)</span> </span>{</span><br><span class="line">  <span class="comment">//首先写入encode后的value大小</span></span><br><span class="line">  PutVarint32(dst, value.<span class="built_in">size</span>());</span><br><span class="line">  <span class="comment">//其次写入data数据</span></span><br><span class="line">  dst-&gt;append(value.data(), value.<span class="built_in">size</span>());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>对于一个数据，调用PutLengthPrefixedSlice函数，将他的长度和数值放入dst中。</p><h4 id="GetLengthPrefixedSlice函数"><a href="#GetLengthPrefixedSlice函数" class="headerlink" title="GetLengthPrefixedSlice函数"></a>GetLengthPrefixedSlice函数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetLengthPrefixedSlice</span><span class="params">(Slice* input, Slice* result)</span> </span>{</span><br><span class="line">  <span class="keyword">uint32_t</span> len;</span><br><span class="line">  <span class="comment">//从input先解析出字符串长度</span></span><br><span class="line">  <span class="keyword">if</span> (GetVarint32(input, &amp;len) &amp;&amp;</span><br><span class="line">      input-&gt;<span class="built_in">size</span>() &gt;= len) {</span><br><span class="line">    <span class="comment">//再从input解析出字符串，记录到result</span></span><br><span class="line">    *result = Slice(input-&gt;data(), len);</span><br><span class="line">    <span class="comment">//调整input跳过已经解析的字符串</span></span><br><span class="line">    input-&gt;remove_prefix(len);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>将编码后的string中的字符串长度移除，得到原始的字符串。</p><p>还有一同名的重载函数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetLengthPrefixedSlice</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit,Slice* result)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"> <span class="comment">//对内存buffer按照varint解码，解码后的整数存储到value</span></span><br><span class="line"><span class="comment">// 内存buffer从p开始，最大不超过limit</span></span><br><span class="line"><span class="comment">// 返回已经解析的buffer的下一个字节，即p + len(varint编码)</span></span><br><span class="line">  <span class="keyword">uint32_t</span> len;</span><br><span class="line">  p = GetVarint32Ptr(p, limit, &amp;len);</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (p + len &gt; limit) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  *result = Slice(p, len);</span><br><span class="line">  <span class="keyword">return</span> p + len;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="编码解码模块的类图"><a href="#编码解码模块的类图" class="headerlink" title="编码解码模块的类图"></a>编码解码模块的类图</h3><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/7PPQ2%5DELHSO%5BI%5DRYT%5DD@%5BC1.png" alt="img"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb学习记录-文件</title>
      <link href="/posts/7f6d2289.html"/>
      <url>/posts/7f6d2289.html</url>
      
        <content type="html"><![CDATA[<h3 id="leveldb的文件命名"><a href="#leveldb的文件命名" class="headerlink" title="leveldb的文件命名"></a>leveldb的文件命名</h3><p>当运行一次leveldb来写入数据时，leveldb可能会生成很多个log文件和SSTable文件，而这些文件的命名都是类似的，都是固定前缀+文件编号+固定后缀的。这些文件的名称是调用函数MakeFileName()来生成的。</p><a id="more"></a><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201215195153429.png" alt="image-20201215195153429"></p><p>如上图，运行./db_bench后，输出很多由数字编号的文件。</p><p>一般可能会存在以下文件内容：</p><ul><li><code>LOCK</code> database文件锁，<code>leveldb</code>通过文件锁来避免同一个db被多次打开操作。调用<code>DB::Open()</code>时会先获取该文件锁。</li><li><code>MANIFEST-XXXXXX</code>，描述文件。XXXXX =&gt; [1, n)，以LOG的形式写入<code>VersionEdit</code>数据。</li><li><code>CURRENT</code> 表明当前正在使用哪个<code>MANIFEST</code>文件</li><li><code>LOG</code>，<code>LOG.old</code> 运行日志文件，当未指定<code>options.info_log</code>时，默认会将错误日志输出到该文件，每一次<code>DB::Open()</code>时，会将<code>LOG</code>重命名为<code>LOG.old</code></li><li><code>.log</code> 日志文件</li><li><code>.ldb</code> db ssttable 持久化文件，新版本的后缀为<code>.ldb</code>，老版本后缀为<code>.sst</code></li><li><code>.dbtmp</code> 变更文件内容，中间过程中的临时文件。</li></ul><h3 id="1-文件命名"><a href="#1-文件命名" class="headerlink" title="1.文件命名"></a>1.文件命名</h3><p>leveldb中与文件名创建相关的文件放在：</p><p>filename ：leveldb/db/filename.cc</p><p>leveldb/db/filename.h</p><p>database中的文件用文件名区分类型，有以下几种类型</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> FileType {</span><br><span class="line">  kLogFile,</span><br><span class="line">  kDBLockFile,</span><br><span class="line">  kTableFile,</span><br><span class="line">  kDescriptorFile,</span><br><span class="line">  kCurrentFile,</span><br><span class="line">  kTempFile,</span><br><span class="line">  kInfoLogFile  <span class="comment">// Either the current one, or an old one</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>1） kLogFile 日志文件： [0-9]+.log</p><p> leveldb 的写流程是先记 binlog，然后写 sstable，该日志文件即是 binlog。前缀数字为FileNumber。<br>2） kDBLockFile， lock 文件： LOCK<br>​ 一个 db 同时只能有一个 db 实例操作，通过对 LOCK 文件加文件锁（flock） 实现主动保护。<br>3） kTableFile， sstable 文件： [0-9]+.sst<br>​ 保存数据的 sstable 文件。前缀为 FileNumber。<br>4） kDescriptorFile， db 元信息文件： MANIFEST-[0-9]+<br>​ 每当 db 中的状态改变（VersionSet），会将这次改变（VersionEdit） 追加到 descriptor 文件中。后缀数字为 FileNumber。<br>5） kCurrentFile，： CURRENT<br>​ CURRENT 文件中保存当前使用的 descriptor 文件的文件名。<br>6） kTempFile，临时文件： [0-9]+.dbtmp<br>​ 对 db 做修复（Repairer）时，会产生临时文件。 前缀为 FileNumber。<br>7） kInfoLogFile， db 运行时打印日志的文件： LOG<br>​ db 运行时，打印的 info 日志保存在 LOG 中。 每次重新运行，如果已经存在 LOG 文件，会先将 LOG文件重名成 LOG.old</p><p><span style="color: orange;"> 文件命名的核心函数为MakeFileName</span></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回形如"$dbname/$number.$suffix"的文件名，其中number使用6位数字输出，不足则左边补0，例如 db/000006.log</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">MakeFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span>* suffix)</span> </span>{</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"/%06llu.%s"</span>,</span><br><span class="line">           <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(number),</span><br><span class="line">           suffix);</span><br><span class="line">  <span class="keyword">return</span> dbname + buf;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由上述代码得知文件名是由dbname+6位number+后缀名组成的。比如<code>db/000010.ldb</code>(leveldb1.14版本之前后缀名是.sst，1.14版本之后采用.ldb)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">LogFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number)</span> </span>{</span><br><span class="line">  assert(number &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> MakeFileName(dbname, number, <span class="string">"log"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">TableFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number)</span> </span>{</span><br><span class="line">  assert(number &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> MakeFileName(dbname, number, <span class="string">"ldb"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">SSTTableFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number)</span> </span>{</span><br><span class="line">  assert(number &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> MakeFileName(dbname, number, <span class="string">"sst"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>值得注意的是MAINIFEST文件没有像 <code>TableFileName</code>、<code>SSTTableFileName</code>、<code>LogFileName</code>调用MakeFileName函数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">DescriptorFileName</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, <span class="keyword">uint64_t</span> number)</span> </span>{</span><br><span class="line">  assert(number &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"/MANIFEST-%06llu"</span>,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(number));</span><br><span class="line">  <span class="keyword">return</span> dbname + buf;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-生成文件编号"><a href="#2-生成文件编号" class="headerlink" title="2.生成文件编号"></a>2.生成文件编号</h3><p>db/version_set.h中保存了多个编号：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> next_file_number_;<span class="comment">//用于生成系统下一个文件的编号</span></span><br><span class="line"><span class="keyword">uint64_t</span> manifest_file_number_;<span class="comment">//Manifest文件的编号，主要在Recover()时用到</span></span><br><span class="line"><span class="keyword">uint64_t</span> last_sequence_;</span><br><span class="line"><span class="keyword">uint64_t</span> log_number_;<span class="comment">//log文件编号</span></span><br><span class="line"><span class="keyword">uint64_t</span> prev_log_number_;</span><br></pre></td></tr></tbody></table></figure><hr><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> file_number = versions_-&gt;NewFileNumber();<span class="comment">//sstable文件的number</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">uint64_t</span> new_log_number = versions_-&gt;NewFileNumber(); <span class="comment">//log文件的number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate and return a new file number</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">NewFileNumber</span><span class="params">()</span> </span>{ <span class="keyword">return</span> next_file_number_++; }<span class="comment">//两者都调用的NewFileNumber函数</span></span><br></pre></td></tr></tbody></table></figure><p>所以由以上代码可以发现sstable文件和log文件的number都是由version_set中的函数NewFileNumber()获得的，变化的值是<code>next_file_number_</code>，leveldb中的文件编号都是逐渐递增的。不存在相同编号的.log或.ldb。也就是说不可能出现000003.ldb和000003.log文件的情况。</p><p>在versionset的构造函数中,next_file_number_被初始化为2.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">VersionSet::VersionSet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname,</span><br><span class="line">                       <span class="keyword">const</span> Options* options,</span><br><span class="line">                       TableCache* table_cache,</span><br><span class="line">                       <span class="keyword">const</span> InternalKeyComparator* cmp)</span><br><span class="line">    : env_(options-&gt;env),</span><br><span class="line">      dbname_(dbname),</span><br><span class="line">      options_(options),</span><br><span class="line">      table_cache_(table_cache),</span><br><span class="line">      icmp_(*cmp),</span><br><span class="line">      next_file_number_(<span class="number">2</span>),<span class="comment">//初始化为2</span></span><br><span class="line">      manifest_file_number_(<span class="number">0</span>),  <span class="comment">// Filled by Recover()</span></span><br><span class="line">      last_sequence_(<span class="number">0</span>),</span><br><span class="line">      log_number_(<span class="number">0</span>),</span><br><span class="line">      prev_log_number_(<span class="number">0</span>),</span><br><span class="line">      descriptor_file_(<span class="literal">nullptr</span>),</span><br><span class="line">      descriptor_log_(<span class="literal">nullptr</span>),</span><br><span class="line">      dummy_versions_(<span class="keyword">this</span>),</span><br><span class="line">      current_(<span class="literal">nullptr</span>) {</span><br><span class="line">  AppendVersion(<span class="keyword">new</span> Version(<span class="keyword">this</span>));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="文件编号1留给Mainifest使用"><a href="#文件编号1留给Mainifest使用" class="headerlink" title="文件编号1留给Mainifest使用"></a>文件编号1留给Mainifest使用</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::NewDB</span><span class="params">()</span> </span>{</span><br><span class="line">  VersionEdit new_db;</span><br><span class="line">  new_db.SetComparatorName(user_comparator()-&gt;Name());</span><br><span class="line">  new_db.SetLogNumber(<span class="number">0</span>);</span><br><span class="line">  new_db.SetNextFile(<span class="number">2</span>);</span><br><span class="line">  new_db.SetLastSequence(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> manifest = DescriptorFileName(dbname_, <span class="number">1</span>);<span class="comment">//编号设置为1</span></span><br><span class="line">  WritableFile* file;</span><br><span class="line">  Status s = env_-&gt;NewWritableFile(manifest, &amp;file);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) {</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  }</span><br><span class="line">  {</span><br><span class="line">    <span class="function"><span class="built_in">log</span>::Writer <span class="title">log</span><span class="params">(file)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">    new_db.EncodeTo(&amp;record);</span><br><span class="line">    s = <span class="built_in">log</span>.AddRecord(record);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">      s = file-&gt;Close();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">delete</span> file;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">    <span class="comment">// Make "CURRENT" file that points to the new manifest file.</span></span><br><span class="line">    s = SetCurrentFile(env_, dbname_, <span class="number">1</span>);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    env_-&gt;DeleteFile(manifest);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Manifest文件记录了leveldb的元信息，包括数据库使用的Comparator名，以及各SSTable文件的管理信息：如Level层数、文件名、最小key和最大key等等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>sstable, log, manifest 的编号都是由 versoinset 中NewFileNumber函数的 next_file_number_变量来指定。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb学习记录-YCSB测试</title>
      <link href="/posts/de979122.html"/>
      <url>/posts/de979122.html</url>
      
        <content type="html"><![CDATA[<h2 id="YCSB环境安装"><a href="#YCSB环境安装" class="headerlink" title="YCSB环境安装"></a>YCSB环境安装</h2><p>昨天在服务器上安装YCSB的测试环境，用来测试leveldb的性能，跑一下实验。本篇博客主要做一个记录，方便日后查看。</p><blockquote><p>ycsb英文全称为Yahoo! Cloud Serving Benchmark (YCSB) 。是Yahoo公司的一个用来对云服务进行基础测试的工具,leveldb的论文中实验测试评估这一章节，主要是采用提供的db_bench作为microbenchmark微基准测试工具，和YCSB作为macrobenchmarks宏基准测试工具，模仿实际的工作load。在运行YCSB的时候，可以配置不同的workload和DB，也可以指定线程数&amp;并发数等其他参数。</p></blockquote><p>主要参考博客：<a href="https://blog.csdn.net/NikoKVCS/article/details/88422307" target="_blank" rel="noopener">YCSB 测试 LevelDB 数据库</a></p><a id="more"></a><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h3><p>YCSB 是一种测试数据库的benchmark<br>它的使用原理是：</p><p>==A.== 目标数据库（待测试的数据库像Leveldb、Hbase等）作为服务端运行起来，并提供数据库操作相关的restful api，比如</p><figure class="highlight dts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span><span class="comment">//localhost:8080/put    </span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//localhost:8080/get</span></span><br><span class="line"><span class="symbol">http:</span><span class="comment">//localhost:8080/del</span></span><br></pre></td></tr></tbody></table></figure><p>==B.== YCSB Client 作为客户端，通过restful api调用数据库，从而测试数据库的性能。</p><h3 id="将leveldb数据库作为服务端运行起来"><a href="#将leveldb数据库作为服务端运行起来" class="headerlink" title="将leveldb数据库作为服务端运行起来"></a>将leveldb数据库作为服务端运行起来</h3><p>由于leveldb是不具有服务端的功能的，也就是无法提供数据库操作相关的restful api的。</p><p>因此，我们需要借助一个工具，<code>simplehttp</code>和<code>simpleleveldb</code></p><blockquote><p>由于leveldb不提供restful api，此处借用的simpleleveldb却可以提供一套restful api与leveldb数据库连接起来。所以ycsb调用restful api就会首先调用simpleleveldb提供的相关操作，然后simpleleveldb再调用leveldb的put、get等操作。所以simpleleveldb就起到一个中间件的作用，将ycsb和leveldb连接起来。</p></blockquote><h4 id="先用git命令获得simplehttp"><a href="#先用git命令获得simplehttp" class="headerlink" title="先用git命令获得simplehttp"></a>先用git命令获得simplehttp</h4><figure class="highlight crmsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/bitly/simplehttp.git</span><br><span class="line">cd simplehttp</span><br></pre></td></tr></tbody></table></figure><h4 id="接着安装simpleleveldb"><a href="#接着安装simpleleveldb" class="headerlink" title="接着安装simpleleveldb"></a>接着安装simpleleveldb</h4><p>首先进入你的leveldb数据库的源码文件夹，编译并拷贝至shared libraries folder</p><figure class="highlight crystal"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd leveldb</span><br><span class="line">make</span><br><span class="line">sudo cp libleveldb.a /usr/local/<span class="class"><span class="keyword">lib</span>/</span></span><br></pre></td></tr></tbody></table></figure><p>其次安装依赖库 JSON ：</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> libjson-c-dev</span><br></pre></td></tr></tbody></table></figure><p>由于simplehttp/simpleleveldb源码中，include的路径有错误，需要稍微改动一下源码，把<code>json</code>改为<code>json-c</code></p><figure class="highlight dts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">打开 simplehttp<span class="meta-keyword">/simpleleveldb/</span>str_list_set.c修改 </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;json/json.h&gt;</span> 为 #<span class="meta-keyword">include</span> <span class="meta-string">&lt;json-c/json.h&gt;</span></span></span><br><span class="line">打开 simplehttp<span class="meta-keyword">/simpleleveldb/</span>simpleleveldb.c修改 </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;json/json.h&gt;</span> 为 #<span class="meta-keyword">include</span> <span class="meta-string">&lt;json-c/json.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><p>同时makefile文件中，对json库的引用也是错误的，-ljson应改为-ljson-c。</p><p>打开 makefile，将</p><p><code>LIBS = -L. -L$(LIBSIMPLEHTTP_LIB) -L$(LIBEVENT)/lib -L/usr/local/lib -L$(LIBLEVELDB)/lib -levent -ljson -lsimplehttp -lleveldb -lm -lstdc++ -lsnappy -lpthread</code></p><p>更改为</p><p><code>LIBS = -L. -L$(LIBSIMPLEHTTP_LIB) -L$(LIBEVENT)/lib -L/usr/local/lib -L$(LIBLEVELDB)/lib -levent -ljson-c -lsimplehttp -lleveldb -lm -lstdc++ -lsnappy -lpthread</code></p><h5 id="其次安装依赖库Snappy"><a href="#其次安装依赖库Snappy" class="headerlink" title="其次安装依赖库Snappy"></a>其次安装依赖库<code>Snappy</code></h5><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt <span class="keyword">install</span> libsnappy-dev</span><br></pre></td></tr></tbody></table></figure><h5 id="安装依赖库Event"><a href="#安装依赖库Event" class="headerlink" title="安装依赖库Event"></a>安装依赖库<code>Event</code></h5><p>根据github的issure ： <a href="https://github.com/bitly/simplehttp/issues/14" target="_blank" rel="noopener">https://github.com/bitly/simplehttp/issues/14</a></p><p>里面提到simplehttp目前仅与libevent 1.4兼容</p><p>所以libevent的版本必须是1.4版本！！！注意</p><p>进入网页下载 <a href="http://libevent.org/" target="_blank" rel="noopener">http://libevent.org/</a>  选择libevent 1.4.14b版本下载</p><p>tar解压之后输入以下命令</p><figure class="highlight crystal"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd libevent-<span class="number">1.4</span>.<span class="number">14</span>b-stable</span><br><span class="line">./configure &amp;&amp; make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ln -s /usr/local/<span class="class"><span class="keyword">lib</span>/<span class="title">libevent</span>-1.4.<span class="title">so</span>.2 /<span class="title">usr</span>/<span class="title">lib</span>/<span class="title">libevent</span>-1.4.<span class="title">so</span>.2 (非必须，若出错可加)之前我没加此条软连接命令报错了，做好还是加上</span></span><br></pre></td></tr></tbody></table></figure><h5 id="安装依赖库simplehttp-（进入到-simplehttp-simplehttp）："><a href="#安装依赖库simplehttp-（进入到-simplehttp-simplehttp）：" class="headerlink" title="安装依赖库simplehttp （进入到 simplehttp/simplehttp）："></a>安装依赖库simplehttp （进入到 simplehttp/simplehttp）：</h5><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> simplehttp</span><br><span class="line"><span class="keyword">make</span></span><br><span class="line">sudo <span class="keyword">make</span> install</span><br></pre></td></tr></tbody></table></figure><h5 id="安装-simpleleveldb"><a href="#安装-simpleleveldb" class="headerlink" title="安装 simpleleveldb"></a>安装 simpleleveldb</h5><figure class="highlight gauss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd simpleleveldb</span><br><span class="line">env LIBLEVELDB=/usr/<span class="keyword">local</span> <span class="built_in">make</span></span><br><span class="line">sudo <span class="built_in">make</span> install</span><br></pre></td></tr></tbody></table></figure><h4 id="simpleleveldb-试运行"><a href="#simpleleveldb-试运行" class="headerlink" title="simpleleveldb 试运行"></a>simpleleveldb 试运行</h4><p>打开终端，输入</p><p><code>simpleleveldb --address=localhost --port=8080 --db-file=test</code></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20210107113625347.png" alt="image-20210107113625347"></p><p>打开浏览器，地址栏输入<br><a href="http://localhost:8080/put?key=name&amp;value=Niko" target="_blank" rel="noopener">http://localhost:8080/put?key=name&amp;value=Niko</a><br>然后会显示一段json，状态码是200</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20210107113722258.png" alt="image-20210107113722258"></p><p>再输入<br><a href="http://localhost:8080/get?key=name" target="_blank" rel="noopener">http://localhost:8080/get?key=name</a><br>会显示一个json，状态码是200，并且返回 Niko</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20210107145124950.png" alt="image-20210107145124950"></p><p>至此，LevelDB的服务端就运行成功了!</p><p>后面就可以下载编译YCSB客户端，运行./ycsb做测试了</p><h3 id="运行YCSB客户端"><a href="#运行YCSB客户端" class="headerlink" title="运行YCSB客户端"></a>运行YCSB客户端</h3><p>下载并编译YCSB客户端：</p><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/jtsui/ycsb-leveldb.git</span><br><span class="line"><span class="keyword">cd</span> ycsb-leveldb</span><br><span class="line">mvn -pl <span class="keyword">com</span>.yahoo.ycs<span class="variable">b:leveldb</span>-binding -<span class="keyword">am</span> clean package</span><br></pre></td></tr></tbody></table></figure><p>在输入<code>mvn -pl com.yahoo.ycsb:leveldb-binding -am clean package</code>命令，由于需要使用jdk环境，而由于ubuntu16.04自带了开源版本openjdk8，不知道为什么还是会报错，找不到java的compiler。故我又重新安装了jdk8.</p><h4 id="安装java开发环境jdk8"><a href="#安装java开发环境jdk8" class="headerlink" title="安装java开发环境jdk8"></a>安装java开发环境jdk8</h4><p>下载完安装包后解压得到jdk1.8.0_271文件夹，将其放在/opt目录下</p><h5 id="在-bin目录下创建java软链接"><a href="#在-bin目录下创建java软链接" class="headerlink" title="在/bin目录下创建java软链接"></a>在/bin目录下创建java软链接</h5><figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">cd</span> /<span class="keyword">bin</span></span><br><span class="line"><span class="keyword">sudo </span>ln -s /<span class="meta">opt</span>/jdk1.<span class="number">8</span>.<span class="number">0</span>_271/<span class="keyword">bin/java </span>java</span><br></pre></td></tr></tbody></table></figure><p>验证软链接的正确性。</p><h5 id="修改环境变量"><a href="#修改环境变量" class="headerlink" title="修改环境变量"></a>修改环境变量</h5><p>输入下面的命令打开环境变量配置文件：</p><figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi ~<span class="string">/.bashrc</span></span><br></pre></td></tr></tbody></table></figure><p>在最末尾添加如下内容（其中的jdk1.8.0_271是我安装的版本，如果你的版本不是jdk1.8.0_271，则需要修改一下）：</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_HOME</span>=/opt/jdk1.8.0_271</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">JRE_HOME</span>=<span class="variable">${JAVA_HOME}</span>/jre</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">CLASSPATH</span>=.:${JAVA_HOME}/lib:<span class="variable">${JRE_HOME}</span>/lib</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">${JAVA_HOME}</span>/bin:$PATH</span><br></pre></td></tr></tbody></table></figure><p>保存并退出，使用source命令使之生效：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></tbody></table></figure><h5 id="最后输入java-version查看是否安装成功"><a href="#最后输入java-version查看是否安装成功" class="headerlink" title="最后输入java -version查看是否安装成功"></a>最后输入java -version查看是否安装成功</h5><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20210107150826458.png" alt="image-20210107150826458"></p><p>至此，安装成功！</p><p>之后再输入<code>mvn -pl com.yahoo.ycsb:leveldb-binding -am clean package</code>就不会再报错啦！！！</p><p>现在就可以正式运行YCSB客户端测试数据库了，请注意，应该先启动LevelDB的服务端。</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/ycsb load leveldb -P workloads/</span>workloada</span><br><span class="line">.<span class="regexp">/ycsb run leveldb -P workloads/</span>workloada</span><br></pre></td></tr></tbody></table></figure><p>上面的实例是采用wordload a。ycsb还提供了workload a、b、c、d、e。</p><p>Running the <code>ycsb</code> command without any argument will print the usage.运行不带任何参数的ycsb命令可以打印用法。</p><figure class="highlight"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Usage</span>: ./ycsb command database [options]</span><br><span class="line"></span><br><span class="line"><span class="attribute">Commands:</span></span><br><span class="line">    load          Execute the load phase</span><br><span class="line">    run           Execute the transaction phase</span><br><span class="line">    shell         Interactive mode</span><br><span class="line"></span><br><span class="line"><span class="attribute">Databases:</span></span><br><span class="line">    basic         https://github.com/brianfrankcooper/YCSB/tree/master/basic</span><br><span class="line">    cassandra-10  https://github.com/brianfrankcooper/YCSB/tree/master/cassandra</span><br><span class="line">    cassandra-7   https://github.com/brianfrankcooper/YCSB/tree/master/cassandra</span><br><span class="line">    cassandra-8   https://github.com/brianfrankcooper/YCSB/tree/master/cassandra</span><br><span class="line">    dynamodb      https://github.com/brianfrankcooper/YCSB/tree/master/dynamodb</span><br><span class="line">    elasticsearch https://github.com/brianfrankcooper/YCSB/tree/master/elasticsearch</span><br><span class="line">    gemfire       https://github.com/brianfrankcooper/YCSB/tree/master/gemfire</span><br><span class="line">    hbase         https://github.com/brianfrankcooper/YCSB/tree/master/hbase</span><br><span class="line">    hypertable    https://github.com/brianfrankcooper/YCSB/tree/master/hypertable</span><br><span class="line">    infinispan    https://github.com/brianfrankcooper/YCSB/tree/master/infinispan</span><br><span class="line">    jdbc          https://github.com/brianfrankcooper/YCSB/tree/master/jdbc</span><br><span class="line">    leveldb       https://github.com/brianfrankcooper/YCSB/tree/master/leveldb</span><br><span class="line">    leveldbjni    https://github.com/brianfrankcooper/YCSB/tree/master/leveldbjni</span><br><span class="line">    mapkeeper     https://github.com/brianfrankcooper/YCSB/tree/master/mapkeeper</span><br><span class="line">    mongodb       https://github.com/brianfrankcooper/YCSB/tree/master/mongodb</span><br><span class="line">    nosqldb       https://github.com/brianfrankcooper/YCSB/tree/master/nosqldb</span><br><span class="line">    orientdb      https://github.com/brianfrankcooper/YCSB/tree/master/orientdb</span><br><span class="line">    redis         https://github.com/brianfrankcooper/YCSB/tree/master/redis</span><br><span class="line">    voldemort     https://github.com/brianfrankcooper/YCSB/tree/master/voldemort</span><br><span class="line"></span><br><span class="line"><span class="attribute">Options:</span></span><br><span class="line">    -P file       Specify workload file     指定工作负载文件</span><br><span class="line">    -p key=value  Override workload property  工作负载特征</span><br><span class="line">    -s            Print status to stderr 打印状态到stderr</span><br><span class="line">    -target n     Target ops/sec (default: unthrottled)   目标ops/sec,(默认值：无限制)</span><br><span class="line">    -threads n    Number of client threads (default: 1)   客户端线程数(默认：单线程) 写入过程是单线程的</span><br><span class="line"></span><br><span class="line">Workload Files:</span><br><span class="line">    There are various predefined workloads under workloads/ directory.</span><br><span class="line">    See https://github.com/brianfrankcooper/YCSB/wiki/Core-Properties</span><br><span class="line">    for the list of workload properties.</span><br></pre></td></tr></tbody></table></figure><p>有关如何运行工作负载的详细文档，请参阅<a href="https://github.com/brianfrankcooper/YCSB/wiki/Running-a-Workload。" target="_blank" rel="noopener">https://github.com/brianfrankcooper/YCSB/wiki/Running-a-Workload。</a></p><p><strong>运行工作负载有6个步骤:</strong></p><p>1、设置要测试的数据库</p><p>2、选择合适的DB接口层</p><p>3、选择合适的工作负载</p><p>4、选择合适的运行时参数（客户机线程数、目标吞吐量等）</p><p>5、load 数据</p><p>6、执行工作负载</p><p>这里描述的步骤假设您运行的是单个客户机服务器。这对于小型到中型集群(例如10台左右的机器)应该足够了。</p><h4 id="step1、设置要测试的数据库"><a href="#step1、设置要测试的数据库" class="headerlink" title="step1、设置要测试的数据库"></a>step1、设置要测试的数据库</h4><p>我们采用的就是LevelDB</p><h4 id="step2、选择合适的DB接口层"><a href="#step2、选择合适的DB接口层" class="headerlink" title="step2、选择合适的DB接口层"></a>step2、选择合适的DB接口层</h4><blockquote><p>DB接口层是一个java类，它将YCSB客户机生成的读、插入、更新、删除和扫描调用执行到针对数据库API的调用中。这个类是com.yahoo中的抽象DB类的子类。ycsb包。您将在运行YCSB客户机时在命令行上指定层的类名，客户机将动态加载您的接口类。命令行上或命令行上指定的参数文件中指定的任何属性都将传递给DB接口实例，并可用于配置层(例如，告诉它您正在进行基准测试的数据库的主机名)。</p><p>YCSB客户端带有一个简单的虚拟接口层com.yahoo.ycsb.BasicDB。这一层只是将它将要执行的操作打印到System.out。它对于确保客户机正常运行和调试工作负载非常有用。</p><p>您可以使用<code>ycsb</code>命令直接对数据库运行命令。这个客户端使用DB接口层向数据库发送命令。您可以使用这个客户机来确保DB层正常工作，数据库设置正确，DB层可以连接到数据库，等等。它还为各种数据库提供了一个公共接口，并可用于检查数据库中的数据。</p></blockquote><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20210107161336539.png" alt="image-20210107161336539"></p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/ycsb shell basic</span><br><span class="line">&gt; help</span><br><span class="line">Commands:</span><br><span class="line">  read key [field1 field2 <span class="built_in">..</span>.] - Read a record</span><br><span class="line">  scan key recordcount [field1 field2 <span class="built_in">..</span>.] - Scan starting at key</span><br><span class="line">  insert key <span class="attribute">name1</span>=value1 [<span class="attribute">name2</span>=value2 <span class="built_in">..</span>.] - Insert a new record</span><br><span class="line">  update key <span class="attribute">name1</span>=value1 [<span class="attribute">name2</span>=value2 <span class="built_in">..</span>.] - Update a record</span><br><span class="line">  delete key - Delete a record</span><br><span class="line">  table [tablename] - <span class="builtin-name">Get</span> <span class="keyword">or</span> [<span class="builtin-name">set</span>] the name of the table</span><br><span class="line">  quit - Quit</span><br></pre></td></tr></tbody></table></figure><h4 id="step3、选择合适的工作负载"><a href="#step3、选择合适的工作负载" class="headerlink" title="step3、选择合适的工作负载"></a>step3、选择合适的工作负载</h4><p>工作负载定义在load阶段将load到数据库中的数据，以及在事务<code>transaction</code>阶段将对数据集执行的操作。</p><p>a workload is a combination of:</p><ul><li>Workload java类(com.yahoo.ycsb.Workload的子类)</li><li>参数文件(Java属性格式)</li></ul><p>在运行ycsb命令时指定的参数 是load还是run，确定是load阶段还是run阶段</p><h4 id="step4、选择合适的运行时参数（客户机线程数、目标吞吐量等）"><a href="#step4、选择合适的运行时参数（客户机线程数、目标吞吐量等）" class="headerlink" title="step4、选择合适的运行时参数（客户机线程数、目标吞吐量等）"></a>step4、选择合适的运行时参数（客户机线程数、目标吞吐量等）</h4><p>尽管workload类和参数文件定义了特定的工作负载，但是您可能希望为基准测试的特定运行指定其他设置。当您运行YCSB客户端时，这些设置在命令行中提供。包括以下选项：</p><ul><li><code>-threads</code>：客户端线程数，ycsb客户端默认是使用单个工作线程。</li><li><code>-target</code>：每秒的目标操作数。默认情况下，YCSB客户端将尝试执行尽可能多的操作。例如，如果每个操作平均花费100毫秒，客户端将在每个工作线程上每秒执行10个操作。但是，您可以限制每秒操作的目标数量。例如，要生成延迟与吞吐量曲线，您可以尝试不同的目标吞吐量，并测量每个目标吞吐量的结果延迟。</li><li><code>-s</code>：status，对于长期运行的工作负载，让客户机报告状态可能是有用的，这只是为了确保它没有崩溃，并让您了解它的进度。通过在命令行中指定“-s”，客户端将每10秒向stderr报告一次状态。</li></ul><h4 id="step5、load数据"><a href="#step5、load数据" class="headerlink" title="step5、load数据"></a>step5、load数据</h4><p>工作负载有两个可执行阶段:load阶段(定义要插入的数据)和事务阶段(定义要对数据集执行的操作)。要加载数据，您需要运行YCSB客户机并告诉它执行加载部分。</p><p>输入以下命令<code>./ycsb load leveldb -P workloads/workloada</code></p><p>-p参数是用来load属性文件的，此处使用它来加载workload参数文件</p><h4 id="step6、执行工作负载"><a href="#step6、执行工作负载" class="headerlink" title="step6、执行工作负载"></a>step6、执行工作负载</h4><p><code>./ycsb run leveldb -P workloads/workloada</code></p><p>运行结束时，客户机将报告stdout上的性能统计数据。默认情况下，为每个操作类型(读取、更新等)生成平均、最小、最大、第95和99百分位延迟，每个操作的返回代码计数，以及每个操作的延迟柱状图。返回代码由数据库接口层定义，允许您查看工作负载期间是否有任何错误。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20210107165412376.png" alt="运行图"></p><p>这个输出显示：</p><ul><li>总的执行时间是3.799s</li><li>平均吞吐为263.2ops/s</li><li>有491个update操作，以及相关的平均、最小、最大、95和99百分位延迟</li><li>所有491次update操作的返回码都为0（在本例中是成功的）</li><li>xxx个操作在不到1毫秒内完成，xx个操作在1至2毫秒内完成。</li></ul><h3 id="YCSB的核心属性"><a href="#YCSB的核心属性" class="headerlink" title="YCSB的核心属性"></a>YCSB的核心属性</h3><p>所有工作负载文件都可以指定以下属性:</p><ul><li><strong>workload</strong>: 要使用的工作负载类别(例如com.yahoo.ycsb.workloads.CoreWorkload)</li><li><strong>recordcount</strong>: 工作负载开始时数据集 中的record数量。默认1000</li><li><strong>operationcount</strong>: 工作负载中要执行的操作数量 (default: 1000)</li><li><strong>db</strong>: 使用的数据库，也可以在命令行上指定 (default: com.yahoo.ycsb.BasicDB)</li><li><strong>exporter</strong>: measurements exporter class to use要使用的测量结果的输出类 (default: com.yahoo.ycsb.measurements.exporter.TextMeasurementsExporter)</li><li><strong>exportfile</strong>: path to a file where output should be written instead of to stdout 用于替代stdout的输出文件路径(default: undefined/write to stdout)</li><li><strong>threadcount</strong>: YCSB客户端线程数. Alternatively this may be specified on the command line. (default: 1)</li><li><strong>measurementtype</strong>: supported measurement types are hdrhistogram, 支持的测量结果类型有直方图和时间序列 (default: hdrhistogram)</li></ul><h3 id="核心工作负载包属性"><a href="#核心工作负载包属性" class="headerlink" title="核心工作负载包属性"></a>核心工作负载包属性</h3><ul><li><strong>fieldcount</strong>: the number of fields in a record (default: 10)</li><li><strong>fieldlength</strong>: the size of each field (default: 100)</li><li><strong>minfieldlength</strong>: the minimum size of each field (default: 1)</li><li><strong>readallfields</strong>: should reads read all fields (true) or just one (false) (default: true)</li><li><strong>writeallfields</strong>: should updates and read/modify/writes update all fields (true) or just one (false) (default: false)</li><li><strong>readproportion</strong>: 读操作的比例 (default: 0.95)</li><li><strong>updateproportion</strong>: 更新操作的比例 (default: 0.05)</li><li><strong>insertproportion</strong>: 插入操作的比例 (default: 0)</li><li><strong>scanproportion</strong>: scan操作的比例(default: 0)</li><li><strong>readmodifywriteproportion</strong>: 读-修改-写一条记录的操作比例 (default: 0)</li><li><strong>requestdistribution</strong>: 选择要操作的记录的分布– uniform(均匀), zipfian, hotspot, sequential, exponential or latest (default: uniform)</li><li><strong>minscanlength</strong>: for scans, what is the minimum number of records to scan (default: 1)</li><li><strong>maxscanlength</strong>: scan操作遍历的最大记录数，for scans, what is the maximum number of records to scan (default: 1000)</li><li><strong>scanlengthdistribution</strong>: 对于scan，应该使用哪个分布来选择要scan的记录数量, for each scan, between 1 and maxscanlength (default: uniform)</li><li><strong>insertstart</strong>: for parallel loads and runs, defines the starting record for this YCSB instance (default: 0)</li><li><strong>insertcount</strong>: for parallel loads and runs, defines the number of records for this YCSB instance (default: recordcount)</li><li><strong>zeropadding</strong>: for generating a record sequence compatible with string sort order by 0 padding the record number. Controls the number of 0s to use for padding. (default: 1)<br>For example for row 5, with zeropadding=1 you get ‘user5’ key and with zeropading=8 you get ‘user00000005’ key. In order to see its impact, zeropadding needs to be bigger than number of digits in the record number.</li><li><strong>insertorder</strong>: 记录是否应该有序插入（ordered），或者是哈希顺序（hashed) (default: hashed)</li><li><strong>fieldnameprefix</strong>: what should be a prefix for field names, the shorter may decrease the required storage size (default: “field”)</li></ul><h3 id="测量结果属性"><a href="#测量结果属性" class="headerlink" title="测量结果属性"></a>测量结果属性</h3><p>这些属性被应用于每一个测量结果类型：</p><p><strong>直方图</strong></p><ul><li>histogram.buckets：直方图输出的区间数（默认：1000）</li></ul><p><strong>时间序列</strong></p><ul><li>timeseries.granularity：时间序列输出的粒度（默认：1000）</li></ul><h3 id="YCSB六个核心工作负载"><a href="#YCSB六个核心工作负载" class="headerlink" title="YCSB六个核心工作负载"></a>YCSB六个核心工作负载</h3><table><thead><tr><th>Workload</th><th>Description</th></tr></thead><tbody><tr><td>YCSB A</td><td>write-intensive: 50% updates, 50% reads</td></tr><tr><td>YCSB B</td><td>read-intensive: 5% updates, 95% reads</td></tr><tr><td>YCSB C</td><td>read-only: 100% reads</td></tr><tr><td>YCSB D</td><td>read-latest: 5% updates, 95% reads</td></tr><tr><td>YCSB E</td><td>scan-intensive: 5% updates, 95% scans; average scan length 50 elements</td></tr><tr><td>YCSB F</td><td>50% read-modify-write, 50% reads</td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb学习记录-Version</title>
      <link href="/posts/21d4485b.html"/>
      <url>/posts/21d4485b.html</url>
      
        <content type="html"><![CDATA[<p>本篇博客主要讲解阅读leveldb源码的version版本管理相关内容，个人的一些笔记。</p><a id="more"></a><h2 id="1-version"><a href="#1-version" class="headerlink" title="1.version"></a>1.version</h2><p>==为什么要有版本管理？==</p><p>对于同一笔记录，如果读和写同一时间发生，reader可能读到不一致的数据或者是修改了一半的数据。对于这种情况，有三种常见的解决方法：</p><blockquote><p>悲观锁   最简单的处理方式，就是加锁保护，写的时候不许读，读的时候不许写。效率低。</p></blockquote><blockquote><p>乐观锁   它假设多用户并发的事物在处理时不会彼此互相影响，各食物能够在不产生锁的的情况下处理各自影响的那部分数据。        在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。        如果其他事务有更新的话，正在提交的事务会进行回滚;这样做不会有锁竞争更不会产生死锁，        但如果数据竞争的概率较高，效率也会受影响 。 </p></blockquote><blockquote><p>*<em>MVCC *</em>   MVCC是一个数据库常用的概念。Multiversion concurrency control多版本并发控制。每一个执行操作的用户，看到的都是数据库特定时刻的的快照(snapshot), writer的任何未完成的修改都不会被其他的用户所看到; 当对数据进行更新的时候并是不直接覆盖，而是先进行标记, 然后在其他地方添加新的数据，从而形成一个新版本,  此时再来读取的reader看到的就是最新的版本了。所以这种处理策略是维护了多个版本的数据的,但只有一个是最新的。</p></blockquote><p>sstable的多版本并发控制就是利用version来实现的。</p><ul><li>只有一个current version，持有最新的sstable集合。</li><li>VersionEdit 代表一次更新，新增了哪些sstable file，以及删除了哪些sstable file</li></ul><p>compaction操作简单来说就是新增与删除文件的过程，对于minor compaction是将不可变的memtable文件dump到磁盘形成sstable；对于major compaction则是归并排序N个文件到M个新文件，如何管理这些文件，就是通过version，能够识别出哪些是归并排序后需要写回下一level的sstable files，哪些属于历史文件。compaction操作后，清理后的数据放到新的版本里面，而旧的数据最终是要被清理掉的，但是如果有某个sstable文件正要被读取，暂时不能删除，该文件属于之前的某个version。</p><p>==版本管理负责管理磁盘上的文件，保证leveldb各层数据的准确性。==</p><h2 id="2-VersionEdit的结构"><a href="#2-VersionEdit的结构" class="headerlink" title="2.VersionEdit的结构"></a>2.VersionEdit的结构</h2><p>前面提到过sstable的MVCC多版本并发控制是利用version来实现的，那么如何从一个版本过渡到新版本的呢？leveldb中是通过VersionEdit来实现的</p><p>VersionEdit顾名思义，是编辑或修改Version。它记录的是两个Version之间的差异</p><blockquote><p>Versoin0 + VersoinEdit = Version1</p></blockquote><p>每次compaction都是新增与删除文件，在原文件版本的基础上生成一个新的版本，也就是<code>Version + Delta = New-Version</code></p><p>在 leveldb 具体实现中，负责管理 Delta 的类是 <code>VersionEdit</code>，某个版本使用<code>Version</code>记录。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/version-edit.png" alt="Version"></p><p><code>operator + =</code>则由类<code>Builder</code>实现。</p><hr><h3 id="2-1-源码解析-VersionEdit"><a href="#2-1-源码解析-VersionEdit" class="headerlink" title="2.1 源码解析-VersionEdit"></a>2.1 源码解析-VersionEdit</h3><p>首先来看看VersionEdit的成员变量和成员函数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">uint64_t</span>&gt; &gt; DeletedFileSet;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> comparator_;</span><br><span class="line">  <span class="keyword">uint64_t</span> log_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> prev_log_number_;</span><br><span class="line">  <span class="keyword">uint64_t</span> next_file_number_;</span><br><span class="line">  SequenceNumber last_sequence_;</span><br><span class="line">  <span class="keyword">bool</span> has_comparator_;</span><br><span class="line">  <span class="keyword">bool</span> has_log_number_;</span><br><span class="line">  <span class="keyword">bool</span> has_prev_log_number_;</span><br><span class="line">  <span class="keyword">bool</span> has_next_file_number_;</span><br><span class="line">  <span class="keyword">bool</span> has_last_sequence_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, InternalKey&gt; &gt; compact_pointers_;</span><br><span class="line">  DeletedFileSet deleted_files_;<span class="comment">//待删除文件</span></span><br><span class="line">  <span class="comment">//新增文件，例如immutable memtable dump后就会添加到new_files_</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt; &gt; new_files_;<span class="comment">//本次操作新增的文件</span></span><br></pre></td></tr></tbody></table></figure><p><code>new_files_</code>是新的version新增了哪些文件，</p><p><code>deleted_files_</code>是新的version删除了哪些文件。</p><blockquote><p>VersionEdit里面保存了此次compact新生成的sstable所处level和MetaData<br>同时保存了需要被删除的sstable（即被compact的sstable）所处level和filenumber.</p></blockquote><p>从一个版本向另一个版本的过度，是由compaction引起的。</p><p>为深入理解version，有必要清楚FileMetaData这个数据结构</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMetaData</span> {</span></span><br><span class="line">  <span class="keyword">int</span> refs;</span><br><span class="line">  <span class="keyword">int</span> allowed_seeks;          <span class="comment">// Seeks allowed until compaction</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;   <span class="comment">//用来唯一表示一个sstable，如文件命名的编号</span></span><br><span class="line">  <span class="keyword">uint64_t</span> file_size;         <span class="comment">// File size in bytes 文件的大小</span></span><br><span class="line">  InternalKey smallest;       <span class="comment">// Smallest internal key served by table  最小键</span></span><br><span class="line">  InternalKey largest;        <span class="comment">// Largest internal key served by table   最大键</span></span><br><span class="line"></span><br><span class="line">  FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) { } <span class="comment">//参数初始化</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>由上段代码可以得知在sstable中存放的key是InternalKey（user_key+sequencenumber+type）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add the specified file at the specified number.</span></span><br><span class="line">  <span class="comment">// REQUIRES: This version has not been saved (see VersionSet::SaveTo)</span></span><br><span class="line">  <span class="comment">// REQUIRES: "smallest" and "largest" are smallest and largest keys in file</span></span><br><span class="line">  <span class="comment">// 记录{level, FileMetaData}对到new_files_</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> InternalKey&amp; smallest,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> InternalKey&amp; largest)</span> </span>{</span><br><span class="line">    FileMetaData f;</span><br><span class="line">    f.number = file;</span><br><span class="line">    f.file_size = file_size;</span><br><span class="line">    f.smallest = smallest;</span><br><span class="line">    f.largest = largest;</span><br><span class="line">    new_files_.push_back(<span class="built_in">std</span>::make_pair(level, f));</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Delete the specified "file" from the specified "level".</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">DeleteFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file)</span> </span>{</span><br><span class="line">    deleted_files_.insert(<span class="built_in">std</span>::make_pair(level, file));</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><strong>成员函数AddFile</strong>是记录{level, FileMetaData}对到new_files_（一个vector）中。</p><p><strong>DeleteFile</strong>在特定的level中删除特定的file</p><h2 id="version类的定义"><a href="#version类的定义" class="headerlink" title="version类的定义"></a>version类的定义</h2><p>先看看Version的成员</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Compaction</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LevelFileNumIterator</span>;</span></span><br><span class="line">  <span class="function">Iterator* <span class="title">NewConcatenatingIterator</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp;, <span class="keyword">int</span> level)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call func(arg, level, f) for every file that overlaps user_key in</span></span><br><span class="line">  <span class="comment">// order from newest to oldest.  If an invocation of func returns</span></span><br><span class="line">  <span class="comment">// false, makes no more calls.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// REQUIRES: user portion of internal_key == user_key.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ForEachOverlapping</span><span class="params">(Slice user_key, Slice internal_key,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">bool</span> (*func)(<span class="keyword">void</span>*, <span class="keyword">int</span>, FileMetaData*))</span></span>;</span><br><span class="line"></span><br><span class="line">  VersionSet* vset_;            <span class="comment">// VersionSet to which this Version belongs所有的version都属于一个集合即Version Set</span></span><br><span class="line">  Version* next_;               <span class="comment">// Next version in linked list  有next_和prev_表示version之间组成一个双链表</span></span><br><span class="line">  Version* prev_;               <span class="comment">// Previous version in linked list</span></span><br><span class="line">  <span class="keyword">int</span> refs_;                    <span class="comment">// Number of live refs to this version</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// List of files per level</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; files_[<span class="built_in">config</span>::kNumLevels];  <span class="comment">//每层的文件列表，每个vector中的元素类型是FileMetaData</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//Compaction触发条件有两种：file_to_compact_ != NULL or compaction_score_ &gt; 1.0</span></span><br><span class="line">  <span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line">  <span class="comment">// 下次compaction的file及level，基于allowed_seeks计算</span></span><br><span class="line">  FileMetaData* file_to_compact_;</span><br><span class="line">  <span class="keyword">int</span> file_to_compact_level_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line">  <span class="comment">// Score &lt; 1 means compaction is not strictly needed.  These fields</span></span><br><span class="line">  <span class="comment">// are initialized by Finalize().</span></span><br><span class="line">  <span class="comment">// 下次compaction的score及level，如果score &lt; 1，表明没有必要compact</span></span><br><span class="line">  <span class="comment">// 在Finalize里计算，基于文件大小or个数</span></span><br><span class="line">  <span class="keyword">double</span> compaction_score_;</span><br><span class="line">  <span class="keyword">int</span> compaction_level_;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Version</span><span class="params">(VersionSet* vset)</span></span></span><br><span class="line">      : vset_(vset), next_(this), prev_(this), refs_(0),</span><br><span class="line">        file_to_compact_(<span class="literal">nullptr</span>),</span><br><span class="line">        file_to_compact_level_(<span class="number">-1</span>),</span><br><span class="line">        compaction_score_(<span class="number">-1</span>),</span><br><span class="line">        compaction_level_(<span class="number">-1</span>) {</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  ~Version();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  Version(<span class="keyword">const</span> Version&amp;);</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Version&amp;);</span><br></pre></td></tr></tbody></table></figure><p>std::vector&lt;FileMetaData*&gt; files_[config::kNumLevels];   <code>kNumLevels</code>=7表明从L0-L6。</p><p>这个vector数组保存了该版本下的所有sstable文件元数据。</p><h3 id="VersionSet类的定义"><a href="#VersionSet类的定义" class="headerlink" title="VersionSet类的定义"></a>VersionSet类的定义</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span> {</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  VersionSet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname,</span><br><span class="line">             <span class="keyword">const</span> Options* options,</span><br><span class="line">             TableCache* table_cache,</span><br><span class="line">             <span class="keyword">const</span> InternalKeyComparator*);</span><br><span class="line">  ~VersionSet();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Apply *edit to the current version to form a new descriptor that</span></span><br><span class="line">  <span class="comment">// is both saved to persistent state and installed as the new</span></span><br><span class="line">  <span class="comment">// current version.  Will release *mu while actually writing to the file.</span></span><br><span class="line">  <span class="comment">// REQUIRES: *mu is held on entry.</span></span><br><span class="line">  <span class="comment">// REQUIRES: no other thread concurrently calls LogAndApply()</span></span><br><span class="line">  <span class="function">Status <span class="title">LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span></span></span><br><span class="line"><span class="function">      <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mu)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Recover the last saved descriptor from persistent storage.</span></span><br><span class="line">  <span class="function">Status <span class="title">Recover</span><span class="params">(<span class="keyword">bool</span> *save_manifest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the current version.</span></span><br><span class="line">  <span class="function">Version* <span class="title">current</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> current_; }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the current manifest file number</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">ManifestFileNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> manifest_file_number_; }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate and return a new file number</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">NewFileNumber</span><span class="params">()</span> </span>{ <span class="keyword">return</span> next_file_number_++; }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Arrange to reuse "file_number" unless a newer file number has</span></span><br><span class="line">  <span class="comment">// already been allocated.</span></span><br><span class="line">  <span class="comment">// REQUIRES: "file_number" was returned by a call to NewFileNumber().</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReuseFileNumber</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (next_file_number_ == file_number + <span class="number">1</span>) {</span><br><span class="line">      next_file_number_ = file_number;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the number of Table files at the specified level.</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">NumLevelFiles</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">const</span></span>; <span class="comment">//const修饰成员函数表明不能改变类的成员变量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the combined file size of all files at the specified level.</span></span><br><span class="line">  <span class="function"><span class="keyword">int64_t</span> <span class="title">NumLevelBytes</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the last sequence number.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">LastSequence</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> last_sequence_; }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the last sequence number to s.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetLastSequence</span><span class="params">(<span class="keyword">uint64_t</span> s)</span> </span>{</span><br><span class="line">    assert(s &gt;= last_sequence_);</span><br><span class="line">    last_sequence_ = s;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mark the specified file number as used.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MarkFileNumberUsed</span><span class="params">(<span class="keyword">uint64_t</span> number)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the current log file number.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">LogNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> log_number_; }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the log file number for the log file that is currently</span></span><br><span class="line">  <span class="comment">// being compacted, or zero if there is no such log file.</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">PrevLogNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> prev_log_number_; }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pick level and inputs for a new compaction.</span></span><br><span class="line">  <span class="comment">// Returns nullptr if there is no compaction to be done.</span></span><br><span class="line">  <span class="comment">// Otherwise returns a pointer to a heap-allocated object that</span></span><br><span class="line">  <span class="comment">// describes the compaction.  Caller should delete the result.</span></span><br><span class="line">  <span class="function">Compaction* <span class="title">PickCompaction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a compaction object for compacting the range [begin,end] in</span></span><br><span class="line">  <span class="comment">// the specified level.  Returns nullptr if there is nothing in that</span></span><br><span class="line">  <span class="comment">// level that overlaps the specified range.  Caller should delete</span></span><br><span class="line">  <span class="comment">// the result.</span></span><br><span class="line">  <span class="function">Compaction* <span class="title">CompactRange</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> level,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> InternalKey* <span class="built_in">begin</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> InternalKey* <span class="built_in">end</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the maximum overlapping data (in bytes) at next level for any</span></span><br><span class="line">  <span class="comment">// file at a level &gt;= 1.</span></span><br><span class="line">  <span class="function"><span class="keyword">int64_t</span> <span class="title">MaxNextLevelOverlappingBytes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create an iterator that reads over the compaction inputs for "*c".</span></span><br><span class="line">  <span class="comment">// The caller should delete the iterator when no longer needed.</span></span><br><span class="line">  <span class="function">Iterator* <span class="title">MakeInputIterator</span><span class="params">(Compaction* c)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true iff some level needs a compaction.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    Version* v = current_;</span><br><span class="line">    <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add all files listed in any live version to *live.</span></span><br><span class="line">  <span class="comment">// May also mutate some internal state.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddLiveFiles</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt;* live)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the approximate offset in the database of the data for</span></span><br><span class="line">  <span class="comment">// "key" as of version "v".</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">ApproximateOffsetOf</span><span class="params">(Version* v, <span class="keyword">const</span> InternalKey&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a human-readable short (single-line) summary of the number</span></span><br><span class="line">  <span class="comment">// of files per level.  Uses *scratch as backing store.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LevelSummaryStorage</span> {</span></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">100</span>];</span><br><span class="line">  };</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">LevelSummary</span><span class="params">(LevelSummaryStorage* scratch)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Compaction</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Version</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ReuseManifest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dscname, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dscbase)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Finalize</span><span class="params">(Version* v)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetRange</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs,</span></span></span><br><span class="line"><span class="function"><span class="params">                InternalKey* smallest,</span></span></span><br><span class="line"><span class="function"><span class="params">                InternalKey* largest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetRange2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs1,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs2,</span></span></span><br><span class="line"><span class="function"><span class="params">                 InternalKey* smallest,</span></span></span><br><span class="line"><span class="function"><span class="params">                 InternalKey* largest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetupOtherInputs</span><span class="params">(Compaction* c)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save current contents to *log</span></span><br><span class="line">  <span class="function">Status <span class="title">WriteSnapshot</span><span class="params">(<span class="built_in">log</span>::Writer* <span class="built_in">log</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AppendVersion</span><span class="params">(Version* v)</span></span>;</span><br><span class="line"></span><br><span class="line">  Env* <span class="keyword">const</span> env_;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_;</span><br><span class="line">  <span class="keyword">const</span> Options* <span class="keyword">const</span> options_;</span><br><span class="line">  TableCache* <span class="keyword">const</span> table_cache_; <span class="comment">//cache</span></span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator icmp_;</span><br><span class="line">  <span class="keyword">uint64_t</span> next_file_number_;  <span class="comment">// 文件编号</span></span><br><span class="line">  <span class="keyword">uint64_t</span> manifest_file_number_; <span class="comment">//当前manifest文件</span></span><br><span class="line">  <span class="keyword">uint64_t</span> last_sequence_; <span class="comment">//该序列号表示internal key中的sequence number</span></span><br><span class="line">  <span class="keyword">uint64_t</span> log_number_;  <span class="comment">//log文件序号</span></span><br><span class="line">  <span class="keyword">uint64_t</span> prev_log_number_;  <span class="comment">// 0 or backing store for memtable being compacted</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Opened lazily</span></span><br><span class="line">  WritableFile* descriptor_file_;</span><br><span class="line">  <span class="built_in">log</span>::Writer* descriptor_log_;</span><br><span class="line">  Version dummy_versions_;  <span class="comment">// Head of circular doubly-linked list of versions. 链表头</span></span><br><span class="line">  Version* current_;        <span class="comment">// == dummy_versions_.prev_  当前版本</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Per-level key at which the next compaction at that level should start.</span></span><br><span class="line">  <span class="comment">// Either an empty string, or a valid InternalKey.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> compact_pointer_[<span class="built_in">config</span>::kNumLevels];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  VersionSet(<span class="keyword">const</span> VersionSet&amp;);</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> VersionSet&amp;);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>LevelDB将所有的Version置于一个双向链表之中，即位于一个集合之中。这样所有的Version组成一个名为VersionSet的结构。</p><p>下图是涉及到的Version、VersionEdit等结构图</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/version_versionset.png" alt="img"></p><p>一个Version结构中保存了L0-L6各个level中sstable文件的元数据，VersionSet里维护了一个双向的环装的Version链表。</p><p>LevelDB会触发Compaction，会对一些文件进行清理操作，让数据更加有序，清理后的数据放到新的版本里面，而老的数据作为原始的素材，最终是要清理掉的，但是如果有读事务位于旧的文件，那么暂时就不能删除。因此利用引用计数，只要一个Verison还活着，就不允许删除该Verison管理的所有文件。当一个Version生命周期结束，它管理的所有文件的引用计数减1。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Version::~Version() {</span><br><span class="line">  assert(refs_ == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove from linked list</span></span><br><span class="line">  prev_-&gt;next_ = next_;</span><br><span class="line">  next_-&gt;prev_ = prev_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop references to files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels; level++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].<span class="built_in">size</span>(); i++) {</span><br><span class="line">      FileMetaData* f = files_[level][i];</span><br><span class="line">      assert(f-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">      f-&gt;refs--;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;refs &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">delete</span> f;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Version的析构函数。当一个Version被删除时，它管理的所有file的引用计数都会减1，当引用计数&lt;=0时，删除该file，是FileMetaData类型。</p><hr><p>前面提到<code>Version + VersionEdit = New-Version</code>具体的操作则由类<code>Builder</code>实现。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201224151238252.png" alt="image-20201224151238252"></p><p>通过sourcetrail源码阅读工具，查看函数调用关系。可以看到在LogAndApply和Recover中调用了Bulider。</p><p>VersionEdit通过new_files_和 deleted_files_保存新增和要被删除的sstable 所在的level和filenumber</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, InternalKey&gt;&gt; compact_pointers_;</span><br><span class="line">DeletedFileSet deleted_files_;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt;&gt; new_files_;</span><br></pre></td></tr></tbody></table></figure><p>在RemoveFile函数中调用了deleted_files_</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Delete the specified "file" from the specified "level".</span><br><span class="line">void RemoveFile(int level, uint64_t file) {</span><br><span class="line">  deleted_files_.insert(std::make_pair(level, file));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201224154552419.png" alt="image-20201224154552419"></p><p><strong>AddInputDeletions</strong>函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compaction::AddInputDeletions</span><span class="params">(VersionEdit* edit)</span> </span>{</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputs_[which].<span class="built_in">size</span>(); i++) {</span><br><span class="line">      edit-&gt;RemoveFile(level_ + which, inputs_[which][i]-&gt;number);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>BackgroundCompaction</strong>函数：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>{ </span><br><span class="line">    ······</span><br><span class="line">Status status;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) {  <span class="comment">//如果c为空，说明没有文件需要进行compaction，无事可做了</span></span><br><span class="line">    <span class="comment">// Nothing to do</span></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;IsTrivialMove()) {</span><br><span class="line">    <span class="comment">// Move file to next level</span></span><br><span class="line">    <span class="comment">//如果不是主动触发的，并且level中的输入文件与level+1中无重叠，且与level + 2中重叠不大于</span></span><br><span class="line">  <span class="comment">//kMaxGrandParentOverlapBytes = 10 * kTargetFileSize,直接将文件移到level+1中</span></span><br><span class="line">    assert(c-&gt;num_input_files(<span class="number">0</span>) == <span class="number">1</span>);</span><br><span class="line">    FileMetaData* f = c-&gt;input(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    c-&gt;edit()-&gt;RemoveFile(c-&gt;level(), f-&gt;number);</span><br><span class="line">    c-&gt;edit()-&gt;AddFile(c-&gt;level() + <span class="number">1</span>, f-&gt;number, f-&gt;file_size, f-&gt;smallest,</span><br><span class="line">                       f-&gt;largest);</span><br><span class="line">    status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_); <span class="comment">//写入version中，稍后分析</span></span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) {</span><br><span class="line">      RecordBackgroundError(status);</span><br><span class="line">    }</span><br><span class="line">    VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">    Log(options_.info_log, <span class="string">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;number), c-&gt;level() + <span class="number">1</span>,</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;file_size),</span><br><span class="line">        status.ToString().c_str(), versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    CompactionState* compact = <span class="keyword">new</span> CompactionState(c);  <span class="comment">//c中包含需要compaction的文件的元信息</span></span><br><span class="line">    status = DoCompactionWork(compact);    <span class="comment">//否则调用DoCompactionWork进行compact输出文件</span></span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) {</span><br><span class="line">      RecordBackgroundError(status);</span><br><span class="line">    }</span><br><span class="line">    CleanupCompaction(compact); <span class="comment">//清理compaction过程中的临时变量</span></span><br><span class="line">    c-&gt;ReleaseInputs();   <span class="comment">//清楚输入文件描述符</span></span><br><span class="line">    RemoveObsoleteFiles(); <span class="comment">//删除无引用的文件</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">delete</span> c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>再来看==new_files_==</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add the specified file at the specified number.</span></span><br><span class="line"><span class="comment">// REQUIRES: This version has not been saved (see VersionSet::SaveTo)</span></span><br><span class="line"><span class="comment">// REQUIRES: "smallest" and "largest" are smallest and largest keys in file</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> InternalKey&amp; smallest, <span class="keyword">const</span> InternalKey&amp; largest)</span> </span>{</span><br><span class="line">  FileMetaData f;</span><br><span class="line">  f.number = file;</span><br><span class="line">  f.file_size = file_size;</span><br><span class="line">  f.smallest = smallest;</span><br><span class="line">  f.largest = largest;</span><br><span class="line">  new_files_.push_back(<span class="built_in">std</span>::make_pair(level, f));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>new_files_在AddFile函数中push_back一个pair（pair.first是层级level，pair.second是FileMetaData文件元数据）。</p><p>AddFile函数被<code>WriteLevel0Table</code>、<code>BackgroundCompaction</code>、<code>InstallCompactionResults</code>函数调用。</p><p>WriteLevel0Table 中是 memtable dump 到 level0 所生成的新文件。</p><p>BackgroundCompaction 是上层与下层不重叠的情况，紧接着是 InstallCompactionResults：将compaction的结果写到level+1中</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::InstallCompactionResults</span><span class="params">(CompactionState* compact)</span> </span>{</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  Log(options_.info_log,  <span class="string">"Compacted %d@%d + %d@%d files =&gt; %lld bytes"</span>,</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">0</span>),</span><br><span class="line">      compact-&gt;compaction-&gt;level(),</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">1</span>),</span><br><span class="line">      compact-&gt;compaction-&gt;level() + <span class="number">1</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(compact-&gt;total_bytes));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add compaction outputs</span></span><br><span class="line">  compact-&gt;compaction-&gt;AddInputDeletions(compact-&gt;compaction-&gt;edit());</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = compact-&gt;compaction-&gt;level();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="keyword">const</span> CompactionState::Output&amp; out = compact-&gt;outputs[i];</span><br><span class="line">    <span class="comment">//新生成的文件增加到edit ,level+1</span></span><br><span class="line">    compact-&gt;compaction-&gt;edit()-&gt;AddFile(</span><br><span class="line">        level + <span class="number">1</span>,</span><br><span class="line">        out.number, out.file_size, out.smallest, out.largest);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> versions_-&gt;LogAndApply(compact-&gt;compaction-&gt;edit(), &amp;mutex_);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201224160650586.png" alt="image-20201224160650586"></p><h4 id="LogAndApply"><a href="#LogAndApply" class="headerlink" title="LogAndApply"></a>LogAndApply</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">VersionSet::LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span> </span>{</span><br><span class="line">  <span class="comment">//为该edit绑定log_number</span></span><br><span class="line">    <span class="keyword">if</span> (edit-&gt;has_log_number_) {</span><br><span class="line">    assert(edit-&gt;log_number_ &gt;= log_number_);</span><br><span class="line">    assert(edit-&gt;log_number_ &lt; next_file_number_);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    edit-&gt;SetLogNumber(log_number_);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!edit-&gt;has_prev_log_number_) {</span><br><span class="line">    edit-&gt;SetPrevLogNumber(prev_log_number_);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">  edit-&gt;SetLastSequence(last_sequence_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前new的version应用edit</span></span><br><span class="line">  Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">  {</span><br><span class="line">    <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">    builder.Apply(edit);</span><br><span class="line">    builder.SaveTo(v);</span><br><span class="line">  }</span><br><span class="line">  Finalize(v); <span class="comment">//计算下一次compaction的compaction_level_和compaction_score_</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize new descriptor log file if necessary by creating</span></span><br><span class="line">  <span class="comment">// a temporary file that contains a snapshot of the current version.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> new_manifest_file; <span class="comment">//创建新的manifest文件</span></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">if</span> (descriptor_log_ == <span class="literal">nullptr</span>) {</span><br><span class="line">    <span class="comment">// No reason to unlock *mu here since we only hit this path in the</span></span><br><span class="line">    <span class="comment">// first call to LogAndApply (when opening the database).</span></span><br><span class="line">    assert(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">//形如MANIFEST-xxxxxx的文件名     // new_manifest_file为当前manifest文件名</span></span><br><span class="line">    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);</span><br><span class="line">    edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">    s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_); <span class="comment">//创建文件</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">      descriptor_log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(descriptor_file_);</span><br><span class="line">      <span class="comment">// manifest写入current_的信息</span></span><br><span class="line">      s = WriteSnapshot(descriptor_log_);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Unlock during expensive MANIFEST log write</span></span><br><span class="line">  {</span><br><span class="line">    mu-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">      edit-&gt;EncodeTo(&amp;record); <span class="comment">//edit的内容编码到record中</span></span><br><span class="line">      <span class="comment">// manifest写入本次edit的信息</span></span><br><span class="line">      s = descriptor_log_-&gt;AddRecord(record);  </span><br><span class="line">      <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">        s = descriptor_file_-&gt;Sync(); <span class="comment">//刷都设备上</span></span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (!s.ok()) {</span><br><span class="line">        Log(options_-&gt;info_log, <span class="string">"MANIFEST write: %s\n"</span>, s.ToString().c_str());</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we just created a new descriptor file, install it by writing a</span></span><br><span class="line">    <span class="comment">// new CURRENT file that points to it.</span></span><br><span class="line">    <span class="comment">// 将manifest_file_number_写入CURRENT文件</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok() &amp;&amp; !new_manifest_file.empty()) { </span><br><span class="line">      s = SetCurrentFile(env_, dbname_, manifest_file_number_);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    mu-&gt;Lock();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install the new version</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">    AppendVersion(v); <span class="comment">//插入version,更新current</span></span><br><span class="line">    log_number_ = edit-&gt;log_number_; </span><br><span class="line">    prev_log_number_ = edit-&gt;prev_log_number_;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">    <span class="keyword">if</span> (!new_manifest_file.empty()) {</span><br><span class="line">      <span class="keyword">delete</span> descriptor_log_;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_file_;</span><br><span class="line">      descriptor_log_ = <span class="literal">nullptr</span>;</span><br><span class="line">      descriptor_file_ = <span class="literal">nullptr</span>;</span><br><span class="line">      env_-&gt;DeleteFile(new_manifest_file);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>总结来看LogAndApply主要作用：</p><ol><li>将<code>edit</code>应用于<code>current_</code>生成一个新的<code>Version</code></li><li>计算新<code>Version</code>下，下次 major compaction 的文件</li><li>更新一些元信息管理文件</li><li>将新<code>Version</code>添加到VersionSet的 双向链表，<code>current_ = 新Version</code></li></ol><p>首先是生成新<code>Version</code>:</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">{</span><br><span class="line">  <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">  builder.Apply(edit);</span><br><span class="line">  builder.SaveTo(v);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接着调用<code>Finalize</code>计算下次 major compact 时要处理的层。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::Finalize</span><span class="params">(Version* v)</span> </span>{</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//level 0看文件个数，降低seek的次数，提高读性能，个数/4</span></span><br><span class="line">  <span class="comment">//level &gt;0看文件大小，减少磁盘占用，大小/(10M**level)</span></span><br><span class="line">  <span class="comment">//例如:</span></span><br><span class="line">  <span class="comment">//level 0 有4个文件，score = 1.0</span></span><br><span class="line">  <span class="comment">//level 1 文件大小为9M，score = 0.9</span></span><br><span class="line">  <span class="comment">//那么compact的level就是0,score = 1.0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels<span class="number">-1</span>; level++) {</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) {</span><br><span class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></span><br><span class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></span><br><span class="line">      <span class="comment">// many level-0 compactions.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></span><br><span class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></span><br><span class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></span><br><span class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></span><br><span class="line">      <span class="comment">// overwrites/deletions).</span></span><br><span class="line">      score = v-&gt;files_[level].<span class="built_in">size</span>() /</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">config</span>::kL0_CompactionTrigger);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) {</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>更新<code>manifest</code>写入<code>current_</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize new descriptor log file if necessary by creating</span></span><br><span class="line"><span class="comment">// a temporary file that contains a snapshot of the current version.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> new_manifest_file;</span><br><span class="line">Status s;</span><br><span class="line"><span class="keyword">if</span> (descriptor_log_ == <span class="literal">nullptr</span>) {</span><br><span class="line">  <span class="comment">// No reason to unlock *mu here since we only hit this path in the</span></span><br><span class="line">  <span class="comment">// first call to LogAndApply (when opening the database).</span></span><br><span class="line">  assert(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">//形如MANIFEST-xxxxxx的文件名</span></span><br><span class="line">  new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);</span><br><span class="line">  edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">  s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">    descriptor_log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(descriptor_file_);</span><br><span class="line">    <span class="comment">// manifest写入current_的信息</span></span><br><span class="line">    s = WriteSnapshot(descriptor_log_);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>写入<code>edit</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlock during expensive MANIFEST log write</span></span><br><span class="line">{</span><br><span class="line">  mu-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">    edit-&gt;EncodeTo(&amp;record);</span><br><span class="line">    <span class="comment">// manifest写入本次edit的信息</span></span><br><span class="line">    s = descriptor_log_-&gt;AddRecord(record);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">      s = descriptor_file_-&gt;Sync();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) {</span><br><span class="line">      Log(options_-&gt;info_log, <span class="string">"MANIFEST write: %s\n"</span>, s.ToString().c_str());</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p><code>manifest</code>就更新完成了，注意格式跟<a href="https://izualzhy.cn/leveldb-log" target="_blank" rel="noopener">log</a>相同。</p><p>接着在<code>CURRENT</code>文件里明文写入<code>manifest</code>文件名。</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将manifest_file_number_写入CURRENT文件</span></span><br><span class="line"><span class="keyword">if</span> (s.ok<span class="literal">()</span><span class="operator"> &amp;&amp; </span>!new_manifest_file.empty<span class="literal">()</span>) {</span><br><span class="line">  s = <span class="constructor">SetCurrentFile(<span class="params">env_</span>, <span class="params">dbname_</span>, <span class="params">manifest_file_number_</span>)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这两个文件在 leveldb 数据库文件里都能找到，形如<code>MANIFEST-000004 CURRENT</code>.</p><p>最后就是调用<code>AppendVersion(v);</code>将新版本更新到链表，修改<code>current_</code>：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v加到链表里</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::AppendVersion</span><span class="params">(Version* v)</span> </span>{</span><br><span class="line">  <span class="comment">// Make "v" current</span></span><br><span class="line">  assert(v-&gt;refs_ == <span class="number">0</span>);</span><br><span class="line">  assert(v != current_);</span><br><span class="line">  <span class="keyword">if</span> (current_ != <span class="literal">nullptr</span>) {</span><br><span class="line">    current_-&gt;Unref();</span><br><span class="line">  }</span><br><span class="line">  current_ = v;</span><br><span class="line">  v-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append to linked list</span></span><br><span class="line">  v-&gt;prev_ = dummy_versions_.prev_;</span><br><span class="line">  v-&gt;next_ = &amp;dummy_versions_;</span><br><span class="line">  v-&gt;prev_-&gt;next_ = v;</span><br><span class="line">  v-&gt;next_-&gt;prev_ = v;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>至此，就完成了将edit的全部过程。</p><p>在磁盘中对应的操作如下图所示：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/manifest.png" alt="manifest"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb学习记录-skiplist</title>
      <link href="/posts/7ad579e7.html"/>
      <url>/posts/7ad579e7.html</url>
      
        <content type="html"><![CDATA[<p>leveldb中memtable的实现是采用skiplist跳表的，了解skiplist这种数据结构，便于我们分析理解memtable。</p><h2 id="1-skiplist跳表的数据结构"><a href="#1-skiplist跳表的数据结构" class="headerlink" title="1.skiplist跳表的数据结构"></a>1.skiplist跳表的数据结构</h2><p>SkipList是一种用来代替平衡树的数据结构。<br>    虽然在最坏的情况下SkipList的效率要低于平衡树，但是大多数情况下效率仍然非常高，其插入、删除、查找的时间复杂度都是O(log(N))。<br>除了高效外，其实现和维护非常简单也是一大优势。SkipList的使用还是比较广泛的，比如在LevelDB中的MemTable就是使用SkipList实现的。</p><a id="more"></a><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skiplist是多层的有序链表</span><br></pre></td></tr></tbody></table></figure><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>以查找19为例</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201221194025728.png" alt="image-20201221194025728"></p><p>先从最上层的跳跃区间大的层开始查找。从头结点开始，首先和23进行比较，小于23，（此时查找指针在图中“1”位置处），查找指针到下一层继续查找。</p><p>然后和9进行判断，大于9，查找指针再往前走一步和23比较，小于23，（此时查找指针在图中“2”位置处） 此时这个值肯定在9结点和23结点之间。查找指针到下一层继续查找。</p><p>然后和13进行判断，大于13，查找指针再往前走一步和23比较，小于23，（此时查找指针在图中“3”位置处）此时这个值肯定在13结点和23结点之间。查找指针到下一层继续查找。此时，我们和19进行判断，找到了。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>包含以下几个操作：</p><p>1、查找到需要插入的位置</p><p>2、申请新的节点</p><p>3、调整指针</p><p>因为在找到插入点之后，新生成节点，新节点按概率出现在每层上，故需要保存所有层的后续指针，这里用一个临时数组保存所有层的插入点处的后续指针。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201221194105759.png" alt="image-20201221194105759"></p><p>以上图为例，现在要插入15这个节点。<br>其过程和查找类似，唯一的问题是，前面的节点的指针是如何保留下来的？</p><p>我们可以看到插入结束后，13的level=0的指针指向了15，13的level=1的指针指向了15。<br>这就意味着，在插入的时候我们就需要保留13的level=0的指针和13的level=1的指针。</p><p>在SkipList中是这样做的，有一个update数组，这个数组的大小为maxLevel。<br>还是以上图为例，在15插入之前，update这个数组中就已经存储了当前每个level的指针。</p><ul><li>update[0]：13 level=0</li><li>update[1]：13 level=1</li><li>update[2]：9   level=2</li><li>update[3]：null level=3</li></ul><p>skiplist的删除</p><p>删除的逻辑和插入类似</p><p>1、查找到相应的节点</p><p>2、通过update数组来实现该节点的逻辑删除</p><p>3、回收该节点资源 </p><h2 id="2-skiplist类介绍"><a href="#2-skiplist类介绍" class="headerlink" title="2.skiplist类介绍"></a>2.skiplist类介绍</h2><p>skiplist是一个模板类</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SkipList</span></span></span><br></pre></td></tr></tbody></table></figure><p>其中key为要存储的数据类型，Comparator实现key之间的比较。</p><h4 id="skiplist的完整定义"><a href="#skiplist的完整定义" class="headerlink" title="skiplist的完整定义"></a>skiplist的完整定义</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SkipList</span> {</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a new SkipList object that will use "cmp" for comparing keys,</span></span><br><span class="line">  <span class="comment">// and will allocate memory using "*arena".  Objects allocated in the arena</span></span><br><span class="line">  <span class="comment">// must remain allocated for the lifetime of the skiplist object.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SkipList</span><span class="params">(Comparator cmp, Arena* arena)</span></span>;</span><br><span class="line"></span><br><span class="line">  SkipList(<span class="keyword">const</span> SkipList&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  SkipList&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SkipList&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Insert key into the list.</span></span><br><span class="line">  <span class="comment">// REQUIRES: nothing that compares equal to key is currently in the list.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true iff an entry that compares equal to key is in the list.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Contains</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Iteration over the contents of a skip list</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> {</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Initialize an iterator over the specified list.</span></span><br><span class="line">    <span class="comment">// The returned iterator is not valid.</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Iterator</span><span class="params">(<span class="keyword">const</span> SkipList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true iff the iterator is positioned at a valid node.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the key at the current position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advances to the next position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advances to the previous position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advance to the first entry with a key &gt;= target</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Key&amp; target)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Position at the first entry in list.</span></span><br><span class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Position at the last entry in list.</span></span><br><span class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> SkipList* list_;</span><br><span class="line">    Node* node_;</span><br><span class="line">    <span class="comment">// Intentionally copyable</span></span><br><span class="line">  };</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">enum</span> { kMaxHeight = <span class="number">12</span> };</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">GetMaxHeight</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> max_height_.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function">Node* <span class="title">NewNode</span><span class="params">(<span class="keyword">const</span> Key&amp; key, <span class="keyword">int</span> <span class="built_in">height</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">RandomHeight</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Equal</span><span class="params">(<span class="keyword">const</span> Key&amp; a, <span class="keyword">const</span> Key&amp; b)</span> <span class="keyword">const</span> </span>{ <span class="keyword">return</span> (compare_(a, b) == <span class="number">0</span>); }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return true if key is greater than the data stored in "n"</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">KeyIsAfterNode</span><span class="params">(<span class="keyword">const</span> Key&amp; key, Node* n)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the earliest node that comes at or after key.</span></span><br><span class="line">  <span class="comment">// Return nullptr if there is no such node.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If prev is non-null, fills prev[level] with pointer to previous</span></span><br><span class="line">  <span class="comment">// node at "level" for every level in [0..max_height_-1].</span></span><br><span class="line">  <span class="function">Node* <span class="title">FindGreaterOrEqual</span><span class="params">(<span class="keyword">const</span> Key&amp; key, Node** prev)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the latest node with a key &lt; key.</span></span><br><span class="line">  <span class="comment">// Return head_ if there is no such node.</span></span><br><span class="line">  <span class="function">Node* <span class="title">FindLessThan</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the last node in the list.</span></span><br><span class="line">  <span class="comment">// Return head_ if list is empty.</span></span><br><span class="line">  <span class="function">Node* <span class="title">FindLast</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Immutable after construction</span></span><br><span class="line">  Comparator <span class="keyword">const</span> compare_;</span><br><span class="line">  Arena* <span class="keyword">const</span> arena_;  <span class="comment">// Arena used for allocations of nodes</span></span><br><span class="line"></span><br><span class="line">  Node* <span class="keyword">const</span> head_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modified only by Insert().  Read racily by readers, but stale</span></span><br><span class="line">  <span class="comment">// values are ok.</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; max_height_;  <span class="comment">// Height of the entire list</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read/written only by Insert().</span></span><br><span class="line">  Random rnd_;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>由skiplist定义，发现其只提供了<code>Insert</code>和<code>Contains</code>两个接口。</p><p>即插入和查找。Contains用于判断是否在list中存在与key值相等的entry（即一条key-value记录）。没有提供<code>Delete</code>接口，因为在leveldb中删除操作就是插入一个标记某个kv对为删除的节点。</p><h2 id="3-insert操作"><a href="#3-insert操作" class="headerlink" title="3.insert操作"></a>3.insert操作</h2><p>insert和contains是skiplist比较核心的部分。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">SkipList</span>&lt;Key, Comparator&gt;:</span>:Insert(<span class="keyword">const</span> Key&amp; key) {</span><br><span class="line">  <span class="comment">// TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span></span><br><span class="line">  <span class="comment">// here since Insert() is externally synchronized.</span></span><br><span class="line">  Node* prev[kMaxHeight];</span><br><span class="line">  Node* x = FindGreaterOrEqual(key, prev);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Our data structure does not allow duplicate insertion</span></span><br><span class="line">  <span class="comment">//leveldb跳表要求不能插入重复数据</span></span><br><span class="line">  assert(x == <span class="literal">nullptr</span> || !Equal(key, x-&gt;key));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = RandomHeight();  <span class="comment">//随机获取一个level值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">height</span> &gt; GetMaxHeight()) {   <span class="comment">//GetMaxHeight为获取跳表当前高度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = GetMaxHeight(); i &lt; <span class="built_in">height</span>; i++) {</span><br><span class="line">      prev[i] = head_;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// It is ok to mutate max_height_ without any synchronization</span></span><br><span class="line">    <span class="comment">// with concurrent readers.  A concurrent reader that observes</span></span><br><span class="line">    <span class="comment">// the new value of max_height_ will see either the old value of</span></span><br><span class="line">    <span class="comment">// new level pointers from head_ (nullptr), or a new value set in</span></span><br><span class="line">    <span class="comment">// the loop below.  In the former case the reader will</span></span><br><span class="line">    <span class="comment">// immediately drop to the next level since nullptr sorts after all</span></span><br><span class="line">    <span class="comment">// keys.  In the latter case the reader will use the new node.</span></span><br><span class="line">    <span class="comment">// 此处不用为并发读加锁。因为并发读在（在另外线程中通过 FindGreaterOrEqual 中的 GetMaxHeight）</span></span><br><span class="line">    <span class="comment">// 读取到更新后跳表层数，但该节点尚未插入时也无妨。因为这意味着它会读到 nullptr，而在 LevelDB</span></span><br><span class="line">    <span class="comment">// 的 Comparator 设定中，nullptr 比所有 key 都大。因此，FindGreaterOrEqual 会继续往下找，</span></span><br><span class="line">    <span class="comment">// 符合预期。</span></span><br><span class="line">    max_height_.store(<span class="built_in">height</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  x = NewNode(key, <span class="built_in">height</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">height</span>; i++) {</span><br><span class="line">    <span class="comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span></span><br><span class="line">    <span class="comment">// we publish a pointer to "x" in prev[i].</span></span><br><span class="line">    <span class="comment">// 此句 NoBarrier_SetNext() 版本就够用了，因为后续 prev[i]-&gt;SetNext(i, x) 语句会进行强制同步。</span></span><br><span class="line">    <span class="comment">// 并且为了保证并发读的正确性，一定要先设置本节点指针，再设置原条表中节点（prev）指针</span></span><br><span class="line">    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));</span><br><span class="line">    prev[i]-&gt;SetNext(i, x);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>采用<code>FindGreaterOrEqual</code>函数确定待插入的位置，采用prev记录每一层最大一个&lt; key的节点，也就是待插入节点的前驱节点。</p><p>通过<code>RandomHeight</code>随机生成此次插入节点的高度，</p><p>插入新节点。</p><h4 id="FindGreaterOrEqual函数"><a href="#FindGreaterOrEqual函数" class="headerlink" title="FindGreaterOrEqual函数"></a>FindGreaterOrEqual函数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;:</span>:Node* SkipList&lt;Key,Comparator&gt;::FindGreaterOrEqual(<span class="keyword">const</span> Key&amp; key, Node** prev)</span><br><span class="line">    <span class="keyword">const</span> {</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line">    <span class="keyword">if</span> (KeyIsAfterNode(key, next)) {<span class="comment">//如果next-&gt;key &lt; key</span></span><br><span class="line">      <span class="comment">// Keep searching in this list</span></span><br><span class="line">      x = next;</span><br><span class="line">    } <span class="keyword">else</span> {<span class="comment">//如果next-&gt;key &gt;= key，如果单纯为了判断是否相等，这里可以加一个判断直接返回了，没必要level--到0再返回</span></span><br><span class="line">      <span class="keyword">if</span> (prev != <span class="literal">nullptr</span>) prev[level] = x;<span class="comment">//prev记录该level最后一个&lt;key的节点</span></span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) {<span class="comment">//到达最底层则返回next (next是第一个&gt;=key的节点)</span></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong><a href="https://link.zhihu.com/?target=https%3A//github.com/google/leveldb/blob/1.22/db/skiplist.h%23L262">FindGreaterOrEqual</a></strong> 查找并返回第一个大于等于 key 的节点。如果是查找后需要进行插入，需要记录下这个节点的 prev 指针。</p><p>插入的高度值是怎么确定的呢？</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RandomHeight</span><span class="params">()</span></span>;<span class="comment">//通过抛硬币的方法(1/4概率)决定高度值，范围[1, kMaxHeight]</span></span><br></pre></td></tr></tbody></table></figure><h4 id="Contains函数"><a href="#Contains函数" class="headerlink" title="Contains函数"></a>Contains函数</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;:</span>:Contains(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span> {</span><br><span class="line">  <span class="comment">//x记录第一个&gt;= key的Node</span></span><br><span class="line">  <span class="comment">//注意FindGreaterOrEqual是查找&gt;=key的Node，因此会迭代直到level = 0才返回</span></span><br><span class="line">  <span class="comment">//实际上可以实现一个接口直接查找==key的Node，这样会在level &gt;=0 时就能返回，查找的时间复杂度不变，不过可以预见减少比较次数。</span></span><br><span class="line">  Node* x = FindGreaterOrEqual(key, <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">//判断x-&gt;key == key</span></span><br><span class="line">  <span class="keyword">if</span> (x != <span class="literal">nullptr</span> &amp;&amp; Equal(key, x-&gt;key)) {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个函数是通过FindGreaterOrEqual找到节点，如果存在该节点，且key值相同，就return true.<strong>Contains</strong> 查找 SkipList 是否包含某个 key.</p><h4 id="FindLessThan和FindLast"><a href="#FindLessThan和FindLast" class="headerlink" title="FindLessThan和FindLast"></a>FindLessThan和FindLast</h4><p><code>Contains</code> <code>Insert</code>都用到了<code>FindGreaterOrEqual</code>，leveldb 还提供了：</p><ol><li><code>FindLessThan</code>：查找最大的一个<code>&lt; key</code>的节点，如果不存在返回head_</li><li><code>FindLast</code>：查找最后一个节点</li></ol><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;:</span>:Node*</span><br><span class="line">SkipList&lt;Key,Comparator&gt;::FindLessThan(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span> {</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;<span class="comment">//获取当前最大height</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    assert(x == head_ || compare_(x-&gt;key, key) &lt; <span class="number">0</span>);</span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">nullptr</span> || compare_(next-&gt;key, key) &gt;= <span class="number">0</span>) {<span class="comment">//如果key &gt;= next-&gt;key</span></span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        level--;</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      x = next;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;:</span>:Node* SkipList&lt;Key,Comparator&gt;::FindLast()</span><br><span class="line">    <span class="keyword">const</span> {</span><br><span class="line">  Node* x = head_;</span><br><span class="line">  <span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    Node* next = x-&gt;Next(level);</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">nullptr</span>) {<span class="comment">//到达最后一个节点</span></span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) {<span class="comment">//level=0，则返回</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Switch to next list</span></span><br><span class="line">        <span class="comment">// level&gt;0则到下一层</span></span><br><span class="line">        level--;</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">//不是最后一个节点则继续递增</span></span><br><span class="line">      x = next;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-iterator"><a href="#4-iterator" class="headerlink" title="4.iterator"></a>4.iterator</h2><p>memtable在读取时采用的是<code>SkipList::Iterator</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Iteration over the contents of a skip list</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> {</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Initialize an iterator over the specified list.</span></span><br><span class="line">    <span class="comment">// The returned iterator is not valid.</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Iterator</span><span class="params">(<span class="keyword">const</span> SkipList* <span class="built_in">list</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns true iff the iterator is positioned at a valid node.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the key at the current position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advances to the next position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advances to the previous position.</span></span><br><span class="line">    <span class="comment">// REQUIRES: Valid()</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Advance to the first entry with a key &gt;= target</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Key&amp; target)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Position at the first entry in list.</span></span><br><span class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Position at the last entry in list.</span></span><br><span class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> SkipList* list_;</span><br><span class="line">    Node* node_;</span><br><span class="line">    <span class="comment">// Intentionally copyable</span></span><br><span class="line">  };</span><br></pre></td></tr></tbody></table></figure><p>分析源码，发现此迭代器接口跟普通迭代器基本一样，内部私有成员包含一个Skiplist和一个node。接口实现都较为简单，有的是直接调用上面提到的<code>FindGreaterOrEqual</code>、<code>FindLessThan</code>、<code>FindLast</code></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>randomHeight，之前介绍抛硬币的方法概率为1/2，这里使用的是1/4，结合<code>kBranching = 4</code>和<code>kMaxHeight = 12</code>，不影响复杂度的情况下，可以最多支持<code>4^11 = 4194304</code>个节点，因此在百万节点左右，这么设置参数效果最优。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb学习记录-memtable</title>
      <link href="/posts/741fdc25.html"/>
      <url>/posts/741fdc25.html</url>
      
        <content type="html"><![CDATA[<p>上一篇博客文章介绍了skiplist，skiplist是leveldb中一个非常重要的数据结构，实现了高效的数据查找和插入，时间复杂度为O(log(n))</p><a id="more"></a><h2 id="1-memtable定义"><a href="#1-memtable定义" class="headerlink" title="1.memtable定义"></a>1.memtable定义</h2><p>首先来看看db/memtable.h文件中MemTable的接口：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemTable</span> {</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// MemTables are reference counted.  The initial reference count</span></span><br><span class="line">  <span class="comment">// is zero and the caller must call Ref() at least once.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MemTable</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; comparator)</span></span>;</span><br><span class="line"></span><br><span class="line">  MemTable(<span class="keyword">const</span> MemTable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  MemTable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MemTable&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Increase reference count.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">()</span> </span>{ ++refs_; }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop reference count.  Delete if no more references exist.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">()</span> </span>{</span><br><span class="line">    --refs_;</span><br><span class="line">    assert(refs_ &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (refs_ &lt;= <span class="number">0</span>) {</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns an estimate of the number of bytes of data in use by this</span></span><br><span class="line">  <span class="comment">// data structure. It is safe to call when MemTable is being modified.</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">ApproximateMemoryUsage</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an iterator that yields the contents of the memtable.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The caller must ensure that the underlying MemTable remains live</span></span><br><span class="line">  <span class="comment">// while the returned iterator is live.  The keys returned by this</span></span><br><span class="line">  <span class="comment">// iterator are internal keys encoded by AppendInternalKey in the</span></span><br><span class="line">  <span class="comment">// db/format.{h,cc} module.</span></span><br><span class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add an entry into memtable that maps key to value at the</span></span><br><span class="line">  <span class="comment">// specified sequence number and with the specified type.</span></span><br><span class="line">  <span class="comment">// Typically value will be empty if type==kTypeDeletion.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(SequenceNumber seq, ValueType type, <span class="keyword">const</span> Slice&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If memtable contains a value for key, store it in *value and return true.</span></span><br><span class="line">  <span class="comment">// If memtable contains a deletion for key, store a NotFound() error</span></span><br><span class="line">  <span class="comment">// in *status and return true.</span></span><br><span class="line">  <span class="comment">// Else, return false.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Get</span><span class="params">(<span class="keyword">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MemTableIterator</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">MemTableBackwardIterator</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">KeyComparator</span> {</span>   <span class="comment">//在memtable里，使用KeyComparator比较，作为skiplist的第二个模板参数</span></span><br><span class="line">    <span class="keyword">const</span> InternalKeyComparator comparator;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">KeyComparator</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; c)</span> : <span class="title">comparator</span><span class="params">(c)</span> </span>{}</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a, <span class="keyword">const</span> <span class="keyword">char</span>* b)</span> <span class="keyword">const</span></span>; <span class="comment">//operator负责解析出internal key，交给comparator比较</span></span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> SkipList&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, KeyComparator&gt; Table;</span><br><span class="line"></span><br><span class="line">  ~MemTable();  <span class="comment">// Private since only Unref() should be used to delete it</span></span><br><span class="line"></span><br><span class="line">  KeyComparator comparator_;   <span class="comment">//比较器</span></span><br><span class="line">  <span class="keyword">int</span> refs_;  <span class="comment">//引用计数</span></span><br><span class="line">  Arena arena_;  <span class="comment">//内存池</span></span><br><span class="line">  Table table_; <span class="comment">//跳表</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>memtable的对象构造必须显示调用（explicit关键字）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb学习记录-log文件</title>
      <link href="/posts/223d4dcc.html"/>
      <url>/posts/223d4dcc.html</url>
      
        <content type="html"><![CDATA[<p>log文件在leveldb的主要作用是防止系统宕机的时候，数据丢失。所以在将键值对写入位于内存的memtable之前，会先写入Log文件中，保证数据的持久化。这样即使系统发生故障，memtable中的数据没有及时Dump到磁盘上，LevelDB仍然可以根据log文件恢复数据。</p><a id="more"></a><h2 id="1-log结构"><a href="#1-log结构" class="headerlink" title="1.log结构"></a>1.log结构</h2><p>关于log的结构在leveldb源码中的doc/log_format.md中有详细的介绍。</p><p>LevelDB对于一个log文件，由以32K为单位的物理块构成，每次读取以一个Block作为基本读取单位。</p><p>下图展示的 log 文件由3个 Block 构成，所以从物理布局来讲，一个 log 文件就是由连续的 32K 大小 Block 构成的。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-03.png" alt="log文件布局"></p><p>每条record的结构如下图所示：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201216200910539.png" alt="image-20201216200910539"></p><p>leveldb中存放的键值对key和value的长度是可变的，所以需要length来记录record中保存的data长度（小端对齐）。checksum记录的是type和data字段的CRC循环校验，验证数据完整性和一致性。log文件是以Block为单位进行存放的，所以会存在某个key-value对过小不能占满一个block块，或者某个key-value对过大，单个block块放不下，需要存放在多个不同的block块中，type字段则是指出每条record的逻辑结构和log文件物理分块结构的关系。在leveldb源码的db/log_format.h文件中,定义了一个RecordType的枚举类。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> RecordType {</span><br><span class="line">  <span class="comment">// Zero is reserved for preallocated files</span></span><br><span class="line">  kZeroType = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  kFullType = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For fragments</span></span><br><span class="line">  kFirstType = <span class="number">2</span>,</span><br><span class="line">  kMiddleType = <span class="number">3</span>,</span><br><span class="line">  kLastType = <span class="number">4</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>主要有以下四种类型：<code>FULL</code>, <code>FIRST</code>, <code>MIDDLE</code>, <code>LAST</code></p><p>如果一个key-value对可以存放在一个block块中，则kFullType=1</p><p>如果某个key-value对过大，单个block块放不下，如上图的Record B就占了3个block块，在block1在Block 1的剩余部分放入Record B的开头一部分，类型标识为FIRST，代表了是一个记录的起始部分；Record B剩下的内容依次放在后续的物理Block里面Block 2全部用来放Record B，且标识类型为MIDDLE，意思是这是Record B中间一段数据；还不够，需要第三个block块 ，Record B剩下的部分可以完全放在Block 3中，类型标识为LAST，代表这是Record B的末尾数据。</p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h2><p>与log日志文件相关的源码：</p><p>db/log_format.h</p><p>db/log_reader.cc</p><p>db/log_reader.h</p><p>db/log_writer.cc</p><p>db/log_writer.h</p><h3 id="leveldb-log命名空间"><a href="#leveldb-log命名空间" class="headerlink" title="leveldb:log命名空间"></a>leveldb:log命名空间</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb {</span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">log</span> {</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RecordType {</span><br><span class="line">  <span class="comment">// Zero is reserved for preallocated files</span></span><br><span class="line">  kZeroType = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  kFullType = <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For fragments</span></span><br><span class="line">  kFirstType = <span class="number">2</span>,</span><br><span class="line">  kMiddleType = <span class="number">3</span>,</span><br><span class="line">  kLastType = <span class="number">4</span></span><br><span class="line">};</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxRecordType = kLastType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kBlockSize = <span class="number">32768</span>;<span class="comment">//32k</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Header is checksum (4 bytes), length (2 bytes), type (1 byte).</span></span><br><span class="line"><span class="comment">// 其中length最大为kBlockSize=0x8000 - kHeaderSize，因此只使用2个字节存储</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kHeaderSize = <span class="number">4</span> + <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">}  <span class="comment">// namespace log</span></span><br><span class="line">}  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></tbody></table></figure><p>leveldb：log下定义的Writer类，封装对log的写入操作：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Write负责组织数据有格式的写入，成员变量dest_负责真正写入数据到文件系统</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span> {</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Create a writer that will append data to "*dest".</span></span><br><span class="line">  <span class="comment">// "*dest" must be initially empty.</span></span><br><span class="line">  <span class="comment">// "*dest" must remain live while this Writer is in use.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Writer</span><span class="params">(WritableFile* dest)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a writer that will append data to "*dest".</span></span><br><span class="line">  <span class="comment">// "*dest" must have initial length "dest_length".</span></span><br><span class="line">  <span class="comment">// "*dest" must remain live while this Writer is in use.</span></span><br><span class="line">  Writer(WritableFile* dest, <span class="keyword">uint64_t</span> dest_length);</span><br><span class="line"></span><br><span class="line">  ~Writer();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//接收数据并调用dest完成写入</span></span><br><span class="line">  <span class="comment">//实现细节：</span></span><br><span class="line">  <span class="comment">//根据slice 及 block剩余大小，可能分成一个或者多个fragment分别写入</span></span><br><span class="line">  <span class="comment">//对于一个fragment格式如下：</span></span><br><span class="line">  <span class="comment">//|crc(4B)  |length(2B)  |type(1B)  |ptr(nB)...  |</span></span><br><span class="line">  <span class="comment">//|--------------header-------------|----data----|</span></span><br><span class="line">  <span class="comment">//其中 type 是一个枚举类型：RecordType</span></span><br><span class="line">  <span class="comment">//{kZeroType kFullType kFirstType kMiddleType kLastType}</span></span><br><span class="line">  <span class="function">Status <span class="title">AddRecord</span><span class="params">(<span class="keyword">const</span> Slice&amp; slice)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  WritableFile* dest_;</span><br><span class="line">  <span class="comment">//每kBlockSize记为一个block，block_offset_记录当前block已经写入的偏移量</span></span><br><span class="line">  <span class="keyword">int</span> block_offset_;       <span class="comment">// Current offset in block</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// crc32c values for all supported record types.  These are</span></span><br><span class="line">  <span class="comment">// pre-computed to reduce the overhead of computing the crc of the</span></span><br><span class="line">  <span class="comment">// record type stored in the header.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> type_crc_[kMaxRecordType + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">EmitPhysicalRecord</span><span class="params">(RecordType type, <span class="keyword">const</span> <span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  Writer(<span class="keyword">const</span> Writer&amp;);</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Writer&amp;);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="AddRecord函数，将数据写入底层文件"><a href="#AddRecord函数，将数据写入底层文件" class="headerlink" title="AddRecord函数，将数据写入底层文件"></a>AddRecord函数，将数据写入底层文件</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Writer::AddRecord</span><span class="params">(<span class="keyword">const</span> Slice&amp; slice)</span> </span>{</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* ptr = slice.data();</span><br><span class="line">  <span class="keyword">size_t</span> left = slice.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fragment the record if necessary and emit it.  Note that if slice</span></span><br><span class="line">  <span class="comment">// is empty, we still want to iterate once to emit a single</span></span><br><span class="line">  <span class="comment">// zero-length record</span></span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">bool</span> <span class="built_in">begin</span> = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">do</span> {</span><br><span class="line">    <span class="comment">//leftover记录block当前可用大小</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> leftover = kBlockSize - block_offset_;<span class="comment">//当前32kb块的剩余量</span></span><br><span class="line">    assert(leftover &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//如果block可用大小已经无法写入header，那么补充\x00</span></span><br><span class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) {</span><br><span class="line">      <span class="comment">// Switch to a new block</span></span><br><span class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></span><br><span class="line">        assert(kHeaderSize == <span class="number">7</span>);</span><br><span class="line">        <span class="comment">//Slice构造函数第二个参数表示字符串长度，因此效果上是leftover个'\x00'</span></span><br><span class="line">        <span class="comment">//leftover size最大为6，因此第一个参数指定6个'\x00'</span></span><br><span class="line">        dest_-&gt;Append(Slice(<span class="string">"\x00\x00\x00\x00\x00\x00"</span>, leftover));</span><br><span class="line">      }</span><br><span class="line">      block_offset_ = <span class="number">0</span>;<span class="comment">//更换新快</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span></span><br><span class="line">    <span class="comment">// block还有剩余可用空间让我们写入一部分数据</span></span><br><span class="line">    <span class="comment">// 如果 = 0，也就是剩余只能写入header，那也写入（只是此时不会写入slice里任何数据）</span></span><br><span class="line">    assert(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可用大小为kBlockSize - block_offset_，减去header大小即为可写的数据大小</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</span><br><span class="line">    <span class="comment">//能够全部写入则=left，否则等于可写大小</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</span><br><span class="line"></span><br><span class="line">    RecordType type;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> <span class="built_in">end</span> = (left == fragment_length);<span class="comment">//相等表示本次可以全部写入</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">begin</span> &amp;&amp; <span class="built_in">end</span>) {</span><br><span class="line">      type = kFullType;<span class="comment">//数据能够一次写入</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">begin</span>) {</span><br><span class="line">      type = kFirstType;<span class="comment">//数据无法一次写入时，标记首次写入</span></span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">end</span>) {</span><br><span class="line">      type = kLastType;<span class="comment">//数据无法一次写入时，标记最后一次写入</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      type = kMiddleType;<span class="comment">//数据无法一次写入时，标记中间写入</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    s = EmitPhysicalRecord(type, ptr, fragment_length);</span><br><span class="line">    ptr += fragment_length;<span class="comment">//下一次slice待写入位置</span></span><br><span class="line">    left -= fragment_length;<span class="comment">//slice还有多少没有写</span></span><br><span class="line">    <span class="built_in">begin</span> = <span class="literal">false</span>;</span><br><span class="line">  } <span class="keyword">while</span> (s.ok() &amp;&amp; left &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="EmitPhysicalRecord函数"><a href="#EmitPhysicalRecord函数" class="headerlink" title="EmitPhysicalRecord函数"></a>EmitPhysicalRecord函数</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写入header data到底层文件(调用flush确保写入)</span></span><br><span class="line"><span class="comment">//|crc(4B)  |length(2B)  |type(1B)  |ptr(nB)...  |</span></span><br><span class="line"><span class="comment">//|--------------header-------------|----data----|</span></span><br><span class="line"><span class="function">Status <span class="title">Writer::EmitPhysicalRecord</span><span class="params">(RecordType t, <span class="keyword">const</span> <span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> n)</span> </span>{</span><br><span class="line">  <span class="comment">//assert这里对应n要使用buf[4, 5]存储，一共两个字节，因此大小应当&lt;=0xffff</span></span><br><span class="line">  assert(n &lt;= <span class="number">0xffff</span>);  <span class="comment">// Must fit in two bytes</span></span><br><span class="line">  <span class="comment">//要写入的数据大小一定能够写入(不大于kBlockSize)</span></span><br><span class="line">  assert(block_offset_ + kHeaderSize + n &lt;= kBlockSize);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Format the header</span></span><br><span class="line">  <span class="keyword">char</span> buf[kHeaderSize];</span><br><span class="line">  <span class="comment">//长度使用两个字节(buf[4, 5])存储，其中4存储低两位，5存储高两位,小端序</span></span><br><span class="line">  <span class="comment">//例如n=0x6789，则buf[4]=0x89，buf[5]=0x67</span></span><br><span class="line">  buf[<span class="number">4</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(n &amp; <span class="number">0xff</span>);</span><br><span class="line">  buf[<span class="number">5</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(n &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  <span class="comment">//buf[6]存储类型</span></span><br><span class="line">  buf[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(t);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算crc: Extend(type_crc, ptr) -&gt; Mask -&gt; EncodeFixed32</span></span><br><span class="line">  <span class="comment">// Compute the crc of the record type and the payload.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> crc = crc32c::Extend(type_crc_[t], ptr, n);</span><br><span class="line">  crc = crc32c::Mask(crc);                 <span class="comment">// Adjust for storage</span></span><br><span class="line">  EncodeFixed32(buf, crc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write the header and the payload</span></span><br><span class="line">  <span class="comment">// 首先写入header: |crc    |length  |type |，大小为kHeaderSize</span></span><br><span class="line">  Status s = dest_-&gt;Append(Slice(buf, kHeaderSize));</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">    <span class="comment">//接着写入数据，大小为n</span></span><br><span class="line">    s = dest_-&gt;Append(Slice(ptr, n));</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">      s = dest_-&gt;Flush();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  block_offset_ += kHeaderSize + n;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个函数的函数体首先检查数据的大小是否小于等于2个字节，接着计算CRC，然后将header数据（|crc  |length |type |，大小为kHeaderSize）写入dest_中，接着写入数据，长度为n。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>本篇博客介绍了leveldb中的log日志文件的结构、逻辑布局和物理布局，分析其源码和主要的几个函数。弄清楚一次写入操作是如何执行的。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201216215542423.png" alt="image-20201216215542423"></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201216215741019.png" alt="image-20201216215741019"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb学习记录-compaction从memtable到sstable</title>
      <link href="/posts/6bd6ce2a.html"/>
      <url>/posts/6bd6ce2a.html</url>
      
        <content type="html"><![CDATA[<p>前面讲了SSTable文件，这种文件是leveldb的最终形态、落盘文件，在该文件中，key－value是有序的，它位于磁盘上。很明显客户输入的key-value对的顺序是不可预知的，是无序，因此SSTable肯定不是直接对应用户的put key－value操作。</p><p>直接应对客户put操作的数据结构是MemTable，它是一个存在在内存中的数据结构，内部也是有序的，使用SkipList来组织用户输入的key－value对。（为了防范异常掉电，所以引入了log文件）。</p><p>这里面就存在一个问题了，用户的输入的数据暂时记录在MemTable，而最终落在磁盘上的是SSTable文件。那问题就来了：</p><a id="more"></a><ul><li>怎么将内存中的SkipList组织的MemTable中的数据dump到SSTable file，</li><li>什么时机做这个dump 操作。</li></ul><p>这就牵扯到LevelDB中很重要的一个概念，Compaction</p><p>==LevelDB中，Compaction分成两种：==</p><ul><li>minor compaction</li><li>major compaction</li></ul><p>minor compaction涉及到将Memtable中的key-value对<font color="orange">dump</font>到磁盘的sstable文件。在合适的时候，将Immutable MemTable dump到磁盘，形成SSTable。</p><p>而major compaction涉及的是磁盘中各个level之间的sstable文件的compaction。</p><h2 id="1-minor-compaction整体流程"><a href="#1-minor-compaction整体流程" class="headerlink" title="1.minor compaction整体流程"></a>1.minor compaction整体流程</h2><p>入口是<font color="orange">  DBImpl::MaybeScheduleCompaction()  </font></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>{</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) {</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) {</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) {</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;NeedsCompaction()) {</span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">    <span class="comment">// 防止无限递归，会判断需不需要再次compaction，如果不需要，递归结束</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BGWork</span><span class="params">(<span class="keyword">void</span>* db)</span> </span>{</span><br><span class="line">  <span class="keyword">reinterpret_cast</span>&lt;DBImpl*&gt;(db)-&gt;BackgroundCall();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCall</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  assert(background_compaction_scheduled_);</span><br><span class="line">  <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) {</span><br><span class="line">    <span class="comment">// No more background work when shutting down.</span></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) {</span><br><span class="line">    <span class="comment">// No more background work after a background error.</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    BackgroundCompaction();<span class="comment">//关键部分 BackgroundCompaction</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  background_compaction_scheduled_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Previous compaction may have produced too many files in a level,</span></span><br><span class="line">  <span class="comment">// so reschedule another compaction if needed.</span></span><br><span class="line">  MaybeScheduleCompaction();</span><br><span class="line">  background_work_finished_signal_.SignalAll();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="整体流程图"><a href="#整体流程图" class="headerlink" title="整体流程图"></a>整体流程图</h4><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20210118113832675.png" alt="调用"></p><p>猛然一看，是一个无限递归函数，从MaybeScheduleCompaction进入，但是后面调用的函数再次调用了MaybeScheduleCompaction函数。但其实在最后if有一个判断，<code>imm_ == NULL &amp;&amp; manual_compaction_ == NULL &amp;&amp;!versions_-&gt;NeedsCompaction()</code>；不会无限递归。</p><ul><li>imm_ == NULL表示没有Immutable MemTable需要dump成SST</li><li>manual_compaction_ == NULL 表示不是手动调用DBImpl::CompactRange，没有人工触发</li><li>versions_-&gt;NeedsCompaction 来 判断是是否需要进一步发起Compaction</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true iff some level needs a compaction.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">  Version* v = current_;</span><br><span class="line">  <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>BackGroundCall()函数中的注释</p><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Previous compaction may have produced too many files in a level,</span></span><br><span class="line"><span class="comment">// so reschedule another compaction if needed.</span></span><br></pre></td></tr></tbody></table></figure><p>意思是第一轮的compaction可能会产生出很多files，需要再发起一次compaction。而是否需要就通过versions_-&gt;NeedsCompaction来判断。</p><p>下面来看看真正compaction的函数：<code>BackgroundCompaction</code></p><p>触发条件：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::BackgroundCompaction</span><span class="params">()</span> </span>{</span><br><span class="line">  mutex_.AssertHeld();<span class="comment">//如果当前线程持有互斥锁，则不执行任何操作</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (imm_ != <span class="literal">NULL</span>) {</span><br><span class="line">    CompactMemTable();<span class="comment">//minor compaction，//将imm_写到level 0</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  }</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="CompactMemTable函数"><a href="#CompactMemTable函数" class="headerlink" title="CompactMemTable函数"></a>CompactMemTable函数</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::CompactMemTable</span><span class="params">()</span> </span>{</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(imm_ != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the contents of the memtable as a new Table  将memtable的内容另存为新表</span></span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  Version* base = versions_-&gt;current();</span><br><span class="line">  base-&gt;Ref();</span><br><span class="line">  Status s = WriteLevel0Table(imm_, &amp;edit, base); <span class="comment">//将数据写到L0</span></span><br><span class="line">  base-&gt;Unref();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) {</span><br><span class="line">    s = Status::IOError(<span class="string">"Deleting DB during memtable compaction"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Replace immutable memtable with the generated Table</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">    edit.SetPrevLogNumber(<span class="number">0</span>);</span><br><span class="line">    edit.SetLogNumber(logfile_number_);  <span class="comment">// Earlier logs no longer needed</span></span><br><span class="line">    s = versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_); <span class="comment">//早期的log不再需要，将生成的Version Edit到当前VersionSet中</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">    <span class="comment">// Commit to the new state</span></span><br><span class="line">    imm_-&gt;Unref(); <span class="comment">//计数-1，引用计数为0时会delete当前imm_</span></span><br><span class="line">    imm_ = <span class="literal">nullptr</span>;</span><br><span class="line">    has_imm_.store(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    RemoveObsoleteFiles();</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    RecordBackgroundError(s);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里引用其他博客里的一张调用流程图如下：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/minor_compaction_workflow.png" alt="调用流程图"></p><h5 id="WriteLevel0Table函数"><a href="#WriteLevel0Table函数" class="headerlink" title="WriteLevel0Table函数"></a>WriteLevel0Table函数</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::WriteLevel0Table</span><span class="params">(MemTable* mem, VersionEdit* edit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Version* base)</span> </span>{</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;NowMicros();</span><br><span class="line">  FileMetaData meta;</span><br><span class="line">  meta.number = versions_-&gt;NewFileNumber();</span><br><span class="line">  pending_outputs_.insert(meta.number);</span><br><span class="line">  Iterator* iter = mem-&gt;NewIterator();</span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: started"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number);</span><br><span class="line"></span><br><span class="line">  Status s;</span><br><span class="line">  {</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);<span class="comment">//将imm dump到sstable中</span></span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: %lld bytes %s"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.file_size,</span><br><span class="line">      s.ToString().c_str());</span><br><span class="line">  <span class="keyword">delete</span> iter;</span><br><span class="line">  pending_outputs_.erase(meta.number);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note that if file_size is zero, the file has been deleted and</span></span><br><span class="line">  <span class="comment">// should not be added to the manifest.</span></span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; meta.file_size &gt; <span class="number">0</span>) {</span><br><span class="line">    <span class="keyword">const</span> Slice min_user_key = meta.smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice max_user_key = meta.largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (base != <span class="literal">nullptr</span>) {</span><br><span class="line">      level = base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key); <span class="comment">//选择sstable写到哪个level</span></span><br><span class="line">    }</span><br><span class="line">    edit-&gt;AddFile(level, meta.number, meta.file_size, meta.smallest,</span><br><span class="line">                  meta.largest); <span class="comment">//添加本次sstable的Filemeta 生成VersionEdit，给manifest文件记录。</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  CompactionStats stats;</span><br><span class="line">  stats.<span class="built_in">micros</span> = env_-&gt;NowMicros() - start_micros;</span><br><span class="line">  stats.bytes_written = meta.file_size;</span><br><span class="line">  stats_[level].Add(stats);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个函数主要包括三个部分，</p><ul><li>BuildTable：将imm dump到磁盘的sstable中</li><li>PickLevelForMemTableOutput：根据最小key和最大key计算新生成的sstable应该位于哪一层</li><li>edit-&gt;AddFile：AddFile**是记录{level, FileMetaData}对到new_files_（一个vector）中。</li></ul><p>其中最重要的BuildTable就是将immutable memtable的内容写到sstable 文件中，sstable文件的命令是由一些列数组+.ldb构成的</p><p><img src="leveldb%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95-compaction%E4%BB%8Ememtable%E5%88%B0sstable.assets/image-20210118171318768.png" alt="sstable"></p><p>这个数字是由VersionSet分配的,meta-&gt;number的赋值语句在DBImpl::WriteLevel0Table中的 <code>meta.number = versions_-&gt;NewFileNumber();</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> meta.number = versions_-&gt;NewFileNumber();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span> {</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">     VersionSet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname,</span><br><span class="line">            <span class="keyword">const</span> Options* options,</span><br><span class="line">            TableCache* table_cache,</span><br><span class="line">            <span class="keyword">const</span> InternalKeyComparator*);</span><br><span class="line">     ~VersionSet();</span><br><span class="line"> ...</span><br><span class="line"> </span><br><span class="line">     <span class="comment">// Allocate and return a new file number</span></span><br><span class="line">    <span class="function"><span class="keyword">uint64_t</span> <span class="title">NewFileNumber</span><span class="params">()</span> </span>{ <span class="keyword">return</span> next_file_number_++; }</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="BuildTable"><a href="#BuildTable" class="headerlink" title="BuildTable"></a>BuildTable</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BuildTable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, Env* env, <span class="keyword">const</span> Options&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                  TableCache* table_cache, Iterator* iter, FileMetaData* meta)</span> </span>{</span><br><span class="line">  Status s;</span><br><span class="line">  meta-&gt;file_size = <span class="number">0</span>;</span><br><span class="line">  iter-&gt;SeekToFirst();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname, meta-&gt;number);</span><br><span class="line">  <span class="keyword">if</span> (iter-&gt;Valid()) {</span><br><span class="line">    WritableFile* file;</span><br><span class="line">    s = env-&gt;NewWritableFile(fname, &amp;file);</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) {</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    TableBuilder* builder = <span class="keyword">new</span> TableBuilder(options, file); <span class="comment">//新建sstable</span></span><br><span class="line">    meta-&gt;smallest.DecodeFrom(iter-&gt;key()); <span class="comment">//第一个key是最小的</span></span><br><span class="line">    Slice key;</span><br><span class="line">    <span class="keyword">for</span> (; iter-&gt;Valid(); iter-&gt;Next()) {</span><br><span class="line">      key = iter-&gt;key();</span><br><span class="line">      builder-&gt;Add(key, iter-&gt;value()); <span class="comment">//向sstable添加key</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (!key.empty()) {</span><br><span class="line">      meta-&gt;largest.DecodeFrom(key); <span class="comment">//最后一个key是最大的</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish and check for builder errors</span></span><br><span class="line">    s = builder-&gt;Finish(); <span class="comment">//写入sstable的其他block，filter block、metaindex block、index block</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">      meta-&gt;file_size = builder-&gt;FileSize();</span><br><span class="line">      assert(meta-&gt;file_size &gt; <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">delete</span> builder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish and check for file errors</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">      s = file-&gt;Sync(); <span class="comment">//写入</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">      s = file-&gt;Close();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">delete</span> file;</span><br><span class="line">    file = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) {</span><br><span class="line">      <span class="comment">// Verify that the table is usable</span></span><br><span class="line">      Iterator* it = table_cache-&gt;NewIterator(ReadOptions(), meta-&gt;number,</span><br><span class="line">                                              meta-&gt;file_size);</span><br><span class="line">      s = it-&gt;status();</span><br><span class="line">      <span class="keyword">delete</span> it;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check for input iterator errors</span></span><br><span class="line">  <span class="keyword">if</span> (!iter-&gt;status().ok()) {</span><br><span class="line">    s = iter-&gt;status();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; meta-&gt;file_size &gt; <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">// Keep it</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    env-&gt;RemoveFile(fname);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>BuildTable函数实现位于db/build.cc中,该函数产生了SSTable文件。首先会新建一个sstable文件，然后根据iter，向sstable添加数据，然后写入磁盘中。</p><h5 id="PickLevelForMemTableOutput"><a href="#PickLevelForMemTableOutput" class="headerlink" title="PickLevelForMemTableOutput"></a>PickLevelForMemTableOutput</h5><p> 新产生出来的sstable 并不一定总是处于level 0， 尽管大多数情况下，处于level 0。新创建的出来的sstable文件应该位于那一层呢？ 由PickLevelForMemTableOutput 函数来计算。</p><p>从策略上要尽量将新compact的文件push高level，毕竟在level 0 需要控制文件过多，compaction IO和查找都比较耗费，另一方面也不能放到过高的level，一定程度上控制查找的次数，而且若某些范围的key更新比较频繁，后续往高层compaction IO消耗也很大，读性能会降低。 所以PickLevelForMemTableOutput就是个权衡折中。</p><p>如果新生成的sstable和Level 0的sstable有交叠，那么新产生的sstable就直接加入level 0，否则根据一定的策略，向上推到Level1 甚至是Level 2，但是最高推到Level2，这里有一个控制参数：<code>kMaxMemCompactLevel</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum level to which a new compacted memtable is pushed if it</span></span><br><span class="line"><span class="comment">// does not create overlap.  We try to push to level 2 to avoid the</span></span><br><span class="line"><span class="comment">// relatively expensive level 0=&gt;1 compactions and to avoid some</span></span><br><span class="line"><span class="comment">// expensive manifest file operations.  We do not push all the way to</span></span><br><span class="line"><span class="comment">// the largest level since that can generate a lot of wasted disk</span></span><br><span class="line"><span class="comment">// space if the same key space is being repeatedly overwritten.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxMemCompactLevel = <span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure><p>由kMaxMemCompactLevel定义来看，sstable最多被放到level2。</p><p>现在来看看PickLevelForMemTableOutput函数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Version::PickLevelForMemTableOutput</span><span class="params">(<span class="keyword">const</span> Slice&amp; smallest_user_key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> Slice&amp; largest_user_key)</span> </span>{</span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!OverlapInLevel(<span class="number">0</span>, &amp;smallest_user_key, &amp;largest_user_key)) { <span class="comment">//如果sstable文件与L0有重叠，直接加入L0</span></span><br><span class="line">    <span class="comment">// Push to next level if there is no overlap in next level,</span></span><br><span class="line">    <span class="comment">// and the #bytes overlapping in the level after that are limited.</span></span><br><span class="line">    <span class="function">InternalKey <span class="title">start</span><span class="params">(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek)</span></span>;</span><br><span class="line">    <span class="function">InternalKey <span class="title">limit</span><span class="params">(largest_user_key, <span class="number">0</span>, <span class="keyword">static_cast</span>&lt;ValueType&gt;(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; overlaps;</span><br><span class="line">    <span class="keyword">while</span> (level &lt; <span class="built_in">config</span>::kMaxMemCompactLevel) {<span class="comment">//最高判断到L2 while 循环寻找合适的level层级，最大level为2，不能更大</span></span><br><span class="line">      <span class="keyword">if</span> (OverlapInLevel(level + <span class="number">1</span>, &amp;smallest_user_key, &amp;largest_user_key)) {</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (level + <span class="number">2</span> &lt; <span class="built_in">config</span>::kNumLevels) { <span class="comment">//kNumLevels=7</span></span><br><span class="line">        <span class="comment">// Check that file does not overlap too many grandparent bytes.</span></span><br><span class="line">        GetOverlappingInputs(level + <span class="number">2</span>, &amp;start, &amp;limit, &amp;overlaps);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int64_t</span> sum = TotalFileSize(overlaps);</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; MaxGrandParentOverlapBytes(vset_-&gt;options_)) {</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      level++;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> level;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序流程图：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/PickLevelForMemTableOutput.png" alt="流程图"></p><p>有一点，是如何判断和不同的level的sstable文件有没有重叠的呢？主要有以下原因：</p><ul><li>SSTable中的key－pair是有序的，给我一个最小的key和一个最大的key，就足以描述该文件中key的范围</li><li>数据结构 FileMetaData，描述了各个文件的名字，最小key 最大key，文件的大小等信息。</li></ul><h5 id="edit-gt-AddFile"><a href="#edit-gt-AddFile" class="headerlink" title="edit->AddFile"></a>edit-&gt;AddFile</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add the specified file at the specified number.</span></span><br><span class="line"><span class="comment">// REQUIRES: This version has not been saved (see VersionSet::SaveTo)</span></span><br><span class="line"><span class="comment">// REQUIRES: "smallest" and "largest" are smallest and largest keys in file</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddFile</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">uint64_t</span> file, <span class="keyword">uint64_t</span> file_size,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> InternalKey&amp; smallest, <span class="keyword">const</span> InternalKey&amp; largest)</span> </span>{</span><br><span class="line">  FileMetaData f;</span><br><span class="line">  f.number = file;</span><br><span class="line">  f.file_size = file_size;</span><br><span class="line">  f.smallest = smallest;</span><br><span class="line">  f.largest = largest;</span><br><span class="line">  new_files_.push_back(<span class="built_in">std</span>::make_pair(level, f));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从 edit-&gt;AddFile 可知，一个 SSTable 对应有一个 FileMeta 存放在 edit 中，edit 最终会存放在 manifest，同时 edit +原始的version最终会演变成新的 version，version 又会加入到 versioneset 中。</p><h2 id="2-何时触发compaction呢？"><a href="#2-何时触发compaction呢？" class="headerlink" title="2.何时触发compaction呢？"></a>2.何时触发compaction呢？</h2><p>看下上面提到的MaybeScheduleCompaction函数</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBImpl::MaybeScheduleCompaction</span><span class="params">()</span> </span>{</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) {</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) {</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) {</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;NeedsCompaction()) {</span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">    <span class="comment">// 防止无限递归，会判断需不需要再次compaction，如果不需要，递归结束</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>当imm_ ！= NULL表示有Immutable MemTable需要dump成SST</li><li>manual_compaction_ ！= NULL 表示会手动调用DBImpl::CompactRange，人工触发compaction</li><li>versions_-&gt;NeedsCompaction 来 判断是是否需要进一步发起Compaction</li></ul><p>触发条件:来看NeedsCompaction ()函数，这里又分了两种情况，文件数目过多或者某层级文件总大小过大， 引起compaction</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true iff some level needs a compaction.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">  Version* v = current_;</span><br><span class="line">  <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>先看看v-&gt;compaction_score_，</p><h3 id="2-1-文件数目过多或者某层级文件总大小过大，引起compacction"><a href="#2-1-文件数目过多或者某层级文件总大小过大，引起compacction" class="headerlink" title="2.1 文件数目过多或者某层级文件总大小过大，引起compacction"></a>2.1 文件数目过多或者某层级文件总大小过大，引起compacction</h3><h4 id="compaction-score-和Finalize函数"><a href="#compaction-score-和Finalize函数" class="headerlink" title="compaction_score_和Finalize函数"></a>compaction_score_和Finalize函数</h4><p>那么什么情况下会重新计算compaction_score_呢，利用VersionSet的<code>Finalize</code>函数，会遍历各个level的文件数目和该level所有文件的总大小，给各个level打个分，如果没有一个level的分数是大于等于1，表示任何一个层级都不需要Compaction，但是如果存在某个或者某几个层级的score大于等于1，选择分最高的那个level。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::Finalize</span><span class="params">(Version* v)</span> </span>{</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels<span class="number">-1</span>; level++) {</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) {</span><br><span class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></span><br><span class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></span><br><span class="line">      <span class="comment">// many level-0 compactions.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></span><br><span class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></span><br><span class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></span><br><span class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></span><br><span class="line">      <span class="comment">// overwrites/deletions).</span></span><br><span class="line">      score = v-&gt;files_[level].<span class="built_in">size</span>() /</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">config</span>::kL0_CompactionTrigger);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) {</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里需要注意，level0是<font color="red">根据文件数目来计算score</font>，而其他层级(level 1~level 6)是根据该<font color="red">层级所有文件的总大小来计算score</font>。</p><p>对于level 0</p><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">score =  （level <span class="number">0</span> 文件总数目） ／ <span class="built_in">config</span>::kL0_CompactionTrigger</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_CompactionTrigger = <span class="number">4</span>;<span class="comment">// Level-0 compaction is started when we hit this many files.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (level == <span class="number">0</span>) {</span><br><span class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></span><br><span class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></span><br><span class="line">      <span class="comment">// many level-0 compactions.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></span><br><span class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></span><br><span class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></span><br><span class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></span><br><span class="line">      <span class="comment">// overwrites/deletions).</span></span><br><span class="line">      score = v-&gt;files_[level].<span class="built_in">size</span>() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">config</span>::kL0_CompactionTrigger);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>对于 level 1～ level 6,则是根据当前文件的大小与该level大小的理论上限的比值</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">score = （该level 所有文件的总大小）／ （该level的大小的理论上限：MaxBytesForLevel）</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">MaxBytesForLevel</span><span class="params">(<span class="keyword">const</span> Options* options, <span class="keyword">int</span> level)</span> </span>{</span><br><span class="line">  <span class="comment">// Note: the result for level zero is not really used since we set</span></span><br><span class="line">  <span class="comment">// the level-0 compaction threshold based on number of files.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Result for both level-0 and level-1</span></span><br><span class="line">  <span class="keyword">double</span> result = <span class="number">10.</span> * <span class="number">1048576.0</span>; <span class="comment">//默认是10M</span></span><br><span class="line">  <span class="keyword">while</span> (level &gt; <span class="number">1</span>) {</span><br><span class="line">    result *= <span class="number">10</span>;</span><br><span class="line">    level--;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里说一下为什么L0跟其他level不一样</p><blockquote><p>看到一篇博客的解释：</p><p>注释说的很明白，level 0的文件之间，key可能是交叉重叠的，因此不希望level 0的文件数特别多。我们考虑write buffer 比较小的时候，如果使用size来限制，那么level 0的文件数可能太多。</p><p>另一个方面，如果write buffer过大，使用固定大小的size 来限制level 0的话，可能算出来的level 0的文件数又太少，触发 level 0 compaction的情况发生的又太频繁。所以L0根据文件数目来计算score，进行compaction。默认L0的文件数量为4</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Level-0 compaction is started when we hit this many files.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_CompactionTrigger = <span class="number">4</span>;</span><br></pre></td></tr></tbody></table></figure></blockquote><p>L1-L6中各层之间的T=10，也就是下一层的大小是上一层的10倍。比如L1=10M，L2=100M, L3=1000M，</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">level 1               10M </span><br><span class="line">level 2              100M</span><br><span class="line">level 3             1000M</span><br><span class="line">level 4            10000M</span><br><span class="line">level 5           100000M</span><br><span class="line">level 6          1000000M</span><br></pre></td></tr></tbody></table></figure><p>其会选择score高的level来做compaction</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (score &gt; best_score) {</span><br><span class="line">  best_level = level;</span><br><span class="line">  best_score = score;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>得分越高，说明该层级触发compaction的要求就越迫切， v-&gt;compaction_level_ 就会设置成得分最高的那个层级。</p><p><font color="cornflowerblue">所以当level0文件数过多，或者L1-L6的总file size过大时，会触发compaction。</font></p><h3 id="2-2-seek次数太多，触发compaction"><a href="#2-2-seek次数太多，触发compaction" class="headerlink" title="2.2 seek次数太多，触发compaction"></a>2.2 seek次数太多，触发compaction</h3><h4 id="file-to-compact-amp-Seek-Compaction"><a href="#file-to-compact-amp-Seek-Compaction" class="headerlink" title="file_to_compact_ &amp; Seek Compaction"></a>file_to_compact_ &amp; Seek Compaction</h4><blockquote><p>随着时间的流逝，LevelDB各个层级都有多个文件。剔除level 0不论，对于任何一个层级来说，层级的内的任意一个文件本身是有序的，而位于同一层级的内部的多个文件，他们也是有序的，而且key是不交叉的。</p><p><font color="orange">但是很不幸的是，level n 和level n＋1的文件，key的范围可能交叉，这种交叉，就可能带来 seek miss，即数据有可能位于level n的某个文件中（根据该文件的最小key和最大key和用户要查找的key来推算），但是实际情况是并不在level n的该文件中，不得不去level n＋1的文件查找。这种seek miss不解决，就会造成查询效率的下降。</font></p></blockquote><p>除了level 0以外，任何一个level的文件内部是有序的，文件之间也是有序的。但是level（n）和level（n＋1）中的两个文件的key可能存在交叉。正是因为这种交叉，查找某个key值的时候，level（n） 的查找无功而返，而不得不去level(n＋1)查找。如果查找了多次，某个文件不得不查找，却总也找不到，总是去高一级的level，才能找到。这说明该层级的文件和上一级的文件，key的范围重叠的很严重，这是不合理的，会导致效率的下降。因此，需要对该level 发起一次major compaction，减少 level 和level ＋ 1的重叠情况。</p><p>这就是所谓的 Seek Compaction。对于seek触发的compaction, 哪个文件无效seek的次数到了阈值，那个文件就是level n的参与compaction的文件。而size 触发的compaction稍微复杂一点，它需要考虑上一次compaction做到了哪个key，什么地方，然后大于该key的第一个文件即为level n的参与compaction的文件。</p><p>对于n &gt;0的情况，初选情况下level n的参与compaction文件只会有1个，如果n＝0，因为level 0的文件之间，key可能交叉重叠，因此，根据选定的level 0的该文件，得到该文件负责的最小key和最大key，找到所有和这个key 区间有交叠的level 0文件，都加入到参战文件。</p><blockquote><p>LevelDb在选定某个level进行compaction后，还要选择是具体哪个文件要进行compaction，比如这次是文件A进行compaction，那么下次就是在key range上紧挨着文件A的文件B进行compaction，这样每个文件都会有机会轮流和高层的level 文件进行合并。</p><p>如果选好了level L的文件A和level L+1层的文件进行合并，那么问题又来了，应该选择level L+1哪些文件进行合并？levelDb选择L+1层中和文件A在key range上有重叠的所有文件来和文件A进行合并。也就是说，选定了level L的文件A，之后在level L+1中找到了所有需要合并的文件B,C,D…..等等。剩下的问题就是具体是如何进行major 合并的？就是说给定了一系列文件，每个文件内部是key有序的，如何对这些文件进行合并，使得新生成的文件仍然Key有序，同时抛掉哪些不再有价值的KV 数据。</p></blockquote><h2 id="3-compaction的实现"><a href="#3-compaction的实现" class="headerlink" title="3.compaction的实现"></a>3.compaction的实现</h2><p>compaction的实现部分位于<code>DBImpl::BackgroundCompaction()</code>函数，包括了minor compaction和major compaciton。</p><h3 id="3-1-PickCompaction"><a href="#3-1-PickCompaction" class="headerlink" title="3.1 PickCompaction()"></a>3.1 PickCompaction()</h3><p>代码首先判断是否需要<code>CompactMemTable()</code>，判断imm_是否为空，不为空则执行CompactMemTable（），minor compaction操作</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) {   <span class="comment">//如果有转换的memtable，直接将memtable写入sstable即返回</span></span><br><span class="line">  CompactMemTable();  <span class="comment">//将imm_写到level 0</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果immutable 不存在，则merge各层leveldb的sstable，也就是major compaction，可以知道，minor compaction的优先级高于major compaction。</p><p>然后就是执行major compaction，一般数据库的compaction操作都为自动触发，不使用手动触发，所以这里直接认为执行else{…}中<code>PickCompaction()</code>挑选合适参与compaction的所有sstable。保存在C中</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Compaction* c;</span><br><span class="line"><span class="keyword">bool</span> is_manual = (manual_compaction_ != <span class="literal">nullptr</span>);</span><br><span class="line">InternalKey manual_end;</span><br><span class="line"><span class="keyword">if</span> (is_manual) {      <span class="comment">//用户(主动)手动触发的compaction</span></span><br><span class="line"> XXXXXXX</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  c = versions_-&gt;PickCompaction();  <span class="comment">//找出最合适compaction的level，自动触发</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来我们来看看<code>PickCompaction()</code>函数。<code>Compaction* VersionSet::PickCompaction()</code>简言来说，就是选取一层需要compaction的sstable文件列表，及相关的下层sstable文件列表，记录在<code>Compaction*</code>返回。</p><p>上面我们提到major compaction除了包括手动触发的compaction外，还包括文件数目过多或某个level文件总大小过大触发compaction，也就是size compaction；和seek次数过多，触发的compaction，也就是seek compaction。</p><p>源码部分，首先根据size_compaction和seek_compaction计算待compaction的文件。</p><p>当compaction_score_&gt;=1时，触发size compaction。首先是找到该层第一个满足条件的sstable，// Pick the first file that comes after compact_pointer_[level]</p><p><code>std::string compact_pointer_[config::kNumLevels];</code>compact_pointer_定义的是string类型，记录了该层上次compaction时文件的最大key值， 定义<code>compact_pointer_</code>的初始值为空，也就是选择该层的第一个sstable文件。</p><p>此时input_[0]中有且仅有一个文件，还需要在L0中找到还有哪些文件与初始的一个文件有重叠，把这些文件都加进来，再通过<code>GetRange</code>获得输入文件的key range，得到最小key和最大key，也就是文件的范围。经过这一步之后，其实是要满足等待compaction的sst文件在各个level都满足这一条件：<code>inputs_[0]</code>中的sst文件跟该层的其他文件之间没有overlap（key重叠）。</p><blockquote><p>// inputs_[0]为 level-n 的 sstable 文件信息，</p><p>// inputs_[1]为 level-n+1 的 sstable 文件信息</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Compaction* <span class="title">VersionSet::PickCompaction</span><span class="params">()</span> </span>{</span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We prefer compactions triggered by too much data in a level over</span></span><br><span class="line">  <span class="comment">// the compactions triggered by seeks.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (size_compaction) { <span class="comment">/*size compaction是第一种情况，根据size来决定是否发起compaction，从which层级发起compaction*/</span></span><br><span class="line">    level = current_-&gt;compaction_level_;</span><br><span class="line">    assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(level + <span class="number">1</span> &lt; <span class="built_in">config</span>::kNumLevels);</span><br><span class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].<span class="built_in">size</span>(); i++) {</span><br><span class="line">      FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">      <span class="keyword">if</span> (compact_pointer_[level].empty() ||</span><br><span class="line">          icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) {</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>].push_back(f);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].empty()) {</span><br><span class="line">      <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">      c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">    }</span><br><span class="line">  } <span class="keyword">else</span> <span class="keyword">if</span> (seek_compaction) { <span class="comment">// /*seek_compaction 是第二种情况，无效seek 次数太多，所以依据文件以及其所属层级发起compaction*/</span></span><br><span class="line">    level = current_-&gt;file_to_compact_level_;</span><br><span class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line">    c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;file_to_compact_);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  c-&gt;input_version_ = current_;</span><br><span class="line">  c-&gt;input_version_-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></span><br><span class="line">  <span class="keyword">if</span> (level == <span class="number">0</span>) {</span><br><span class="line">    InternalKey smallest, largest;</span><br><span class="line">    GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">    <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">    <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">    <span class="comment">// which will include the picked file.</span></span><br><span class="line">    current_-&gt;GetOverlappingInputs(<span class="number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    assert(!c-&gt;inputs_[<span class="number">0</span>].empty());</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  SetupOtherInputs(c); <span class="comment">//负责计算level n+1中参与compaction的文件</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-2-SetupOtherInputs"><a href="#3-2-SetupOtherInputs" class="headerlink" title="3.2 SetupOtherInputs()"></a>3.2 SetupOtherInputs()</h3><p>计算下一层参与compaction的sst，得到input_[1]。</p><p>在level n+1中，所有与level n得到的key的range中(smallest,largest)有重叠的sst文件，都要加进input_[1]中参与compaction。得到这些sst文件后，还要注意能否在不增加level n+1层文件的前提下，增加leveldb n层的文件。</p><p>也就是尽肯能增加level n层的文件，类似贪心算法。</p><p>根据源码来理解下SetupOtherInputs()函数</p><p>首先是计算下一层与<code>inputs_[0]</code> key range 有重叠的所有 sstable files，记录到<code>inputs_[1]</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VersionSet::SetupOtherInputs</span><span class="params">(Compaction* c)</span> </span>{</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = c-&gt;level();</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line">  <span class="comment">//inputs_[0]所有文件的key range -&gt; [smallest, largest]</span></span><br><span class="line">  GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//inputs_[1]记录level + 1层所有与inputs_[0]有overlap的文件</span></span><br><span class="line">  current_-&gt;GetOverlappingInputs(level+<span class="number">1</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get entire range covered by compaction</span></span><br><span class="line">  InternalKey all_start, all_limit;</span><br><span class="line">  <span class="comment">//inputs_[0, 1]两层所有文件的key range -&gt; [all_start, all_limit]</span></span><br><span class="line">  GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br></pre></td></tr></tbody></table></figure><p>根据<code>inputs_[1]</code>反推下 level 层有多少 key range 有重叠的文件，记录到<code>expanded0</code>：</p><figure class="highlight dts"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See if we can grow the number of inputs in "level" without</span></span><br><span class="line"><span class="comment">// changing the number of "level+1" files we pick up.</span></span><br><span class="line"><span class="comment">// 如果再不增加level + 1层文件的情况下，尽可能的增加level层的文件</span></span><br><span class="line">if (!c-&gt;inputs_[<span class="number">1</span>].empty()) {</span><br><span class="line"><span class="symbol">  std:</span>:vector<span class="params">&lt;FileMetaData*&gt;</span> expanded0;</span><br><span class="line">  <span class="comment">//level层与[all_start, all_limit]有overlap的所有文件，记录到expanded0</span></span><br><span class="line">  <span class="comment">//expanded0 &gt;= inputs_[0]</span></span><br><span class="line">  current_-&gt;GetOverlappingInputs(level, <span class="variable">&amp;all_start</span>, <span class="variable">&amp;all_limit</span>, <span class="variable">&amp;expanded0</span>);</span><br></pre></td></tr></tbody></table></figure><p>如果文件确实又增加，同时又不会增加太多文件(太多会导致 compact 压力过大)</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = TotalFileSize(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = TotalFileSize(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = TotalFileSize(expanded0);</span><br><span class="line"><span class="comment">//1. level 层参与compact文件数有增加</span></span><br><span class="line"><span class="comment">//2. 但合并的文件总量在ExpandedCompactionByteSizeLimit之内（防止compact过多）</span></span><br><span class="line"><span class="keyword">if</span> (expanded0.<span class="built_in">size</span>() &gt; c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">    inputs1_size + expanded0_size &lt;</span><br><span class="line">        ExpandedCompactionByteSizeLimit(options_)) {</span><br></pre></td></tr></tbody></table></figure><p>那么就增加参与 compact 的文件，更新到<code>inputs_</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">InternalKey new_start, new_limit;</span><br><span class="line"><span class="comment">//[new_start, new_limit]记录expand0的key range</span></span><br><span class="line">GetRange(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded1;</span><br><span class="line"><span class="comment">//如果level层文件从inputs_[0]扩展到expand0，key的范围变成[new_start, new_limit]</span></span><br><span class="line"><span class="comment">//看下level + 1层overlap的文件范围，记录到expand1</span></span><br><span class="line">current_-&gt;GetOverlappingInputs(level+<span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                               &amp;expanded1);</span><br><span class="line"><span class="comment">//确保level + 1层文件没有增加，那么使用心得expand0, expand1</span></span><br><span class="line"><span class="keyword">if</span> (expanded1.<span class="built_in">size</span>() == c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()) {</span><br><span class="line">  Log(options_-&gt;info_log,</span><br><span class="line">      <span class="string">"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"</span>,</span><br><span class="line">      level,</span><br><span class="line">      <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">0</span>].<span class="built_in">size</span>()),</span><br><span class="line">      <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">1</span>].<span class="built_in">size</span>()),</span><br><span class="line">      <span class="keyword">long</span>(inputs0_size), <span class="keyword">long</span>(inputs1_size),</span><br><span class="line">      <span class="keyword">int</span>(expanded0.<span class="built_in">size</span>()),</span><br><span class="line">      <span class="keyword">int</span>(expanded1.<span class="built_in">size</span>()),</span><br><span class="line">      <span class="keyword">long</span>(expanded0_size), <span class="keyword">long</span>(inputs1_size));</span><br><span class="line">  smallest = new_start;</span><br><span class="line">  largest = new_limit;</span><br><span class="line">  c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">  c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">  GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意上述的判断逻辑，</p><p>1、根据level n的input[0]所确定的key的范围确定level n+1层的input[1]。</p><p>2、再根据input[1]反过来看能否增大input[0]</p><p>3、将增加sst后的input[0]记录到expanded0中</p><p>4、根据expanded0确定的key的range判断是否会导致input[1]增大</p><p>5、如果input1[1]还是原来的大小，则可以扩大参与compaction的level n的文件范围。</p><p>简单说，就是在不增加level n+1层文件，同时不会导致level n和level n+1参与compaction的总文件过大的前提下，尽量增加level n层的文件数。</p><p>至此，参与compaction的level n和level n+1的文件集合就已经确定了，为了避免这些文件合并到 level n+1 层后，跟 level n+2 层有重叠的文件太多，届时合并 level n+1 和 level n+2 层压力太大，因此我们还需要记录下 level n+2 层的文件，后续 compaction 时用于提前结束的判断：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute the set of grandparent files that overlap this compaction</span></span><br><span class="line"><span class="comment">// (parent == level+1; grandparent == level+2)</span></span><br><span class="line"><span class="comment">// level + 2层有overlap的文件，记录到c-&gt;grandparents_</span></span><br><span class="line"><span class="keyword">if</span> (level + <span class="number">2</span> &lt; <span class="built_in">config</span>::kNumLevels) {</span><br><span class="line">  <span class="comment">//level + 2层overlap的文件记录到c-&gt;grandparents_</span></span><br><span class="line">  current_-&gt;GetOverlappingInputs(level + <span class="number">2</span>, &amp;all_start, &amp;all_limit,</span><br><span class="line">                                 &amp;c-&gt;grandparents_);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后记录<code>compact_pointer_</code>到<code>c-&gt;edit_</code>，在后续<code>PickCompaction</code>入口时使用</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Update the place where we will do the next compaction for this level.</span></span><br><span class="line">  <span class="comment">// We update this immediately instead of waiting for the VersionEdit</span></span><br><span class="line">  <span class="comment">// to be applied so that if the compaction fails, we will try a different</span></span><br><span class="line">  <span class="comment">// key range next time.</span></span><br><span class="line">  compact_pointer_[level] = largest.Encode().ToString();</span><br><span class="line">  c-&gt;edit_.SetCompactPointer(level, largest);  <span class="comment">//记录下Compaction_pointer_，对于size compaction, 下一次要靠该值来选择 level n的参与compaction的文件</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><p>PickCompaction()函数的最后就是返回挑选进行compaction的文件的结果<code>c</code></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选取一层需要compact的文件列表，及相关的下层文件列表，记录在Compaction*</span></span><br><span class="line"><span class="function">Compaction* <span class="title">VersionSet::PickCompaction</span><span class="params">()</span> </span>{</span><br><span class="line">  Compaction* c;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>返回Compaction * c后，紧接着有一个判断，什么情况下可以直接使用原sst文件，直接向下merge，省去了重新生成文件的过程。这里关注一下<code>IsTrivialMove</code>函数。</p><h3 id="3-3-IsTrivialMove"><a href="#3-3-IsTrivialMove" class="headerlink" title="3.3 IsTrivialMove()"></a>3.3 IsTrivialMove()</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compaction::IsTrivialMove</span><span class="params">()</span> <span class="keyword">const</span> </span>{</span><br><span class="line">  <span class="keyword">const</span> VersionSet* vset = input_version_-&gt;vset_;</span><br><span class="line">  <span class="comment">// Avoid a move if there is lots of overlapping grandparent data.</span></span><br><span class="line">  <span class="comment">// Otherwise, the move could create a parent file that will require</span></span><br><span class="line">  <span class="comment">// a very expensive merge later on.</span></span><br><span class="line">  <span class="comment">// 同时满足以下条件时，我们只要简单的把文件从level标记到level + 1层就可以了</span></span><br><span class="line">  <span class="comment">// 1. level层只有一个文件</span></span><br><span class="line">  <span class="comment">// 2. level + 1层没有文件</span></span><br><span class="line">  <span class="comment">// 3. 跟level + 2层overlap的文件没有超过25M</span></span><br><span class="line">  <span class="comment">// 注：条件三主要是(避免move到level + 1后，导致level + 1 与 level + 2层compact压力过大)</span></span><br><span class="line">  <span class="keyword">return</span> (num_input_files(<span class="number">0</span>) == <span class="number">1</span> &amp;&amp; num_input_files(<span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">          TotalFileSize(grandparents_) &lt;=</span><br><span class="line">              MaxGrandParentOverlapBytes(vset-&gt;options_));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当level 与level +1层文件没有overlap，直接merge或者叫move到下一level并不会导致错误，这样就节省了compaction重新生成文件的开销。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Status status;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="literal">nullptr</span>) {  <span class="comment">//如果c为空，说明没有文件需要进行compaction，无事可做了</span></span><br><span class="line">  <span class="comment">// Nothing to do</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;IsTrivialMove()) {</span><br><span class="line">  <span class="comment">// Move file to next level</span></span><br><span class="line">  <span class="comment">//如果不是手动触发的，并且level中的输入文件与level+1中无重叠，且与level + 2中重叠不大于</span></span><br><span class="line"><span class="comment">//kMaxGrandParentOverlapBytes = 10 * kTargetFileSize,直接将文件移到level+1中，并删除level层的文件</span></span><br><span class="line">  assert(c-&gt;num_input_files(<span class="number">0</span>) == <span class="number">1</span>);</span><br><span class="line">  FileMetaData* f = c-&gt;input(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  c-&gt;edit()-&gt;RemoveFile(c-&gt;level(), f-&gt;number);</span><br><span class="line">  c-&gt;edit()-&gt;AddFile(c-&gt;level() + <span class="number">1</span>, f-&gt;number, f-&gt;file_size, f-&gt;smallest,</span><br><span class="line">                     f-&gt;largest);</span><br><span class="line">  status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_); <span class="comment">//写入version中，稍后分析</span></span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) {</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  }</span><br><span class="line">  VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">  Log(options_.info_log, <span class="string">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;number), c-&gt;level() + <span class="number">1</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;file_size),</span><br><span class="line">      status.ToString().c_str(), versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>阅读上面的代码可以看出，如果满足c-&gt;IsTrivialMove()的条件，就只需要在edit中记录一下，</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;edit()-&gt;DeleteFile(c-&gt;level(), f-&gt;number);</span><br><span class="line">    c-&gt;edit()-&gt;AddFile(c-&gt;level() + <span class="number">1</span>, f-&gt;number, f-&gt;file_size,</span><br><span class="line">                       f-&gt;smallest, f-&gt;largest);</span><br></pre></td></tr></tbody></table></figure><p>然后再通过<code>LogAndApply</code>生效就ok了。<code>LogAndApply</code>主要做了以下几件事：</p><ol><li>将<code>edit</code>应用于<code>current_</code>生成一个新的<code>Version</code></li><li>计算新<code>Version</code>下，下次 major compaction 的文件</li><li>更新一些元信息管理文件</li><li>将新<code>Version</code>添加到双向链表，<code>current_ = 新Version</code></li></ol><p>所以，其实并没有操作sst文件，只是修改了文件对应的level。</p><p>如果pickcompaction得到的待compaction文件 <code>compaction* c</code>不满足以上if条件判断的内容，就直接调用实际的compaction过程，先读，再合并排序，然后写入一个新的sst到下一层level。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> {<span class="comment">//调用实际的compaction过程</span></span><br><span class="line">    CompactionState* compact = <span class="keyword">new</span> CompactionState(c);  <span class="comment">//c中包含需要compaction的文件的元信息</span></span><br><span class="line">    status = DoCompactionWork(compact);    <span class="comment">//否则调用DoCompactionWork进行compact输出文件</span></span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) {</span><br><span class="line">      RecordBackgroundError(status);</span><br><span class="line">    }</span><br><span class="line">    CleanupCompaction(compact); <span class="comment">//清理compaction过程中的临时变量</span></span><br><span class="line">    c-&gt;ReleaseInputs();   <span class="comment">//清楚输入文件描述符</span></span><br><span class="line">    RemoveObsoleteFiles(); <span class="comment">//删除无引用的文件,回收磁盘空间</span></span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>现在，来关注以下DoCompactionWork()函数</p><h3 id="3-4-DoCompactionWork"><a href="#3-4-DoCompactionWork" class="headerlink" title="3.4 DoCompactionWork()"></a>3.4 DoCompactionWork()</h3><p><code>Status DBImpl::DoCompactionWork(CompactionState* compact)</code>真正的compaction，也就是多路归并过程，生成新的版本，其中compact里保存compaction的状态。</p><p>首先一个if判断来取<code>当前最小的使用中的SequenceNumber</code>。</p><p>然后参与Compaction的sstable组成一个迭代器input。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::DoCompactionWork</span><span class="params">(CompactionState* compact)</span> </span>{</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;NowMicros();</span><br><span class="line">  <span class="keyword">int64_t</span> imm_micros = <span class="number">0</span>;  <span class="comment">// Micros spent doing imm_ compactions</span></span><br><span class="line"></span><br><span class="line">  Log(options_.info_log, <span class="string">"Compacting %d@%d + %d@%d files"</span>, <span class="comment">//记录当前层文件数，层编号，下一层文件数，层编号</span></span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">0</span>), compact-&gt;compaction-&gt;level(),</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">1</span>),</span><br><span class="line">      compact-&gt;compaction-&gt;level() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  assert(versions_-&gt;NumLevelFiles(compact-&gt;compaction-&gt;level()) &gt; <span class="number">0</span>);</span><br><span class="line">  assert(compact-&gt;builder == <span class="literal">nullptr</span>);</span><br><span class="line">  assert(compact-&gt;outfile == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (snapshots_.empty()) { <span class="comment">//将snapshot相关的内容记录到compact信息中</span></span><br><span class="line">    compact-&gt;smallest_snapshot = versions_-&gt;LastSequence();</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    compact-&gt;smallest_snapshot = snapshots_.oldest()-&gt;sequence_number();</span><br><span class="line">  }</span><br><span class="line"> <span class="comment">//生成iterator，遍历所有要compaction的文件</span></span><br><span class="line">  Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</span><br></pre></td></tr></tbody></table></figure><p>接着，先将input定位到首位置，开启遍历。</p><p> 循环判断 如果有memtable需要compaction，先compact memtable，<br> 依次通过上面的迭代器iterator遍历所有参与compaction的文件的所有key，<br> 循环的主体工作是判断当前迭代器对应的key是否应该加入到新合并生成的文件中。</p><p>这里要注意一下</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在做真正的compaction work时不应该阻塞DB的读写操作</span></span><br><span class="line"><span class="comment">// Release mutex while we're actually doing the compaction work 在实际执行compaction时释放互斥锁</span></span><br><span class="line">mutex_.Unlock();</span><br><span class="line"></span><br><span class="line">input-&gt;SeekToFirst();</span><br><span class="line">Status status;</span><br><span class="line">ParsedInternalKey ikey;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> current_user_key;</span><br><span class="line"><span class="keyword">bool</span> has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">SequenceNumber last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line"><span class="comment">//循环判断 如果有memtable需要compact，先compact memtable</span></span><br><span class="line"><span class="comment">//依次通过上面的迭代器iterator遍历所有参与compaction的文件的所有key</span></span><br><span class="line"><span class="comment">//循环的主体工作是判断当前迭代器对应的key是否应该加入到新合并生成的文件中</span></span><br><span class="line"><span class="keyword">while</span> (input-&gt;Valid() &amp;&amp; !shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) {  <span class="comment">//每个input对应的是一个K/V</span></span><br><span class="line">  <span class="comment">// Prioritize immutable compaction work 优先immutable memtable的compact操作</span></span><br><span class="line">  <span class="keyword">if</span> (has_imm_.load(<span class="built_in">std</span>::memory_order_relaxed)) {</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> imm_start = env_-&gt;NowMicros();</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">    <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) {</span><br><span class="line">      CompactMemTable();   <span class="comment">//将imm_写入磁盘中</span></span><br><span class="line">      <span class="comment">// Wake up MakeRoomForWrite() if necessary.</span></span><br><span class="line">      background_work_finished_signal_.SignalAll();  <span class="comment">//wakeup等待空间的线程</span></span><br><span class="line">    }</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    imm_micros += (env_-&gt;NowMicros() - imm_start);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  Slice key = input-&gt;key();</span><br><span class="line">  <span class="comment">//判断是否需要停止compaction，中途输出compaction的结果，避免compaction结果和level N+2 files有过多的重叠</span></span><br><span class="line">  <span class="keyword">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;</span><br><span class="line">      compact-&gt;builder != <span class="literal">nullptr</span>) { <span class="comment">////与level + 2层的文件比较，如果目前的compact已经会导致后续level + 1 与 level + 2 compact压力过大</span></span><br><span class="line">  <span class="comment">//那么结束本次compact</span></span><br><span class="line">    status = FinishCompactionOutputFile(compact, input); <span class="comment">//写当前文件到磁盘</span></span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) {</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">  }  <span class="comment">//这里先把迭代器对应的key提取出来，因为在此之前我们可能以及遍历过多个key-value了，</span></span><br><span class="line">  <span class="comment">//也就是可能已经将多个key-value写入到新的sstable中了。这里通过ShouldStopBefore函数判断是否符合生成一个新的sstable的条件，</span></span><br><span class="line">  <span class="comment">//如果符合的话就将这个sstable写盘，如果不符合的话，就继续往里面加key-value。</span></span><br></pre></td></tr></tbody></table></figure><p>这里要注意一下这个判断,其中的<code>ShouldStopBefore()</code>判断生成的SSTable和level  + 2层的有重叠overlap的文件个数，如果超过10个，那么这个SSTable生成就完成了,这样保证了新产生的SSTable和上一层不会有过多的重叠。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;</span><br><span class="line">        compact-&gt;builder != <span class="literal">nullptr</span>) { <span class="comment">////与level + 2层的文件比较，如果目前的compact已经会导致后续level + 1 与 level + 2 compact压力过大</span></span><br><span class="line">    <span class="comment">//那么结束本次compact</span></span><br><span class="line">      status = FinishCompactionOutputFile(compact, input); <span class="comment">//写当前文件到磁盘</span></span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) {</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>接着定义了一个bool型变量drop=false，用来指示是否该key是否需要丢弃。会将起一次出现的key的SequenceNumber设置为最大，可以保证第一个key不会被丢弃，如果上一个key的SequenceNumber&lt;=最小存活的snapshot的sequencenumber，当遍历到下一个key时，其SequenceNumber一定小于该最小存活的snapshot的sequencenumber，</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">if</span> (!has_current_user_key ||          <span class="comment">//如果第一次碰到一个user key</span></span><br><span class="line">          user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=</span><br><span class="line">              <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// First occurrence of this user key 第一次出现的key，将seq设置为最大标记</span></span><br><span class="line">        current_user_key.assign(ikey.user_key.data(), ikey.user_key.<span class="built_in">size</span>());</span><br><span class="line">        has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">        last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">      }</span><br><span class="line">    <span class="comment">//因为第一次出现会将last seq设置为最大， 表示上一个key的关于seqnumber的比较结果</span></span><br><span class="line">    <span class="comment">// 如果上一个Key的SequenceNumber &lt;= 最小的存活的Snapshot，那么</span></span><br><span class="line">    <span class="comment">// 这个Key的SequenceNumber一定 &lt; 最小的存活的Snapshot，那么这个Key就不</span></span><br><span class="line">      <span class="comment">// 会被任何线程看到了，可以被丢弃，上面碰到了第一个User Key时，设置了</span></span><br><span class="line">      <span class="comment">// last_sequence_for_key = kMaxSequenceNumber;保证第一个Key一定不会</span></span><br><span class="line">      <span class="comment">// 被丢弃。</span></span><br><span class="line">      <span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) {</span><br><span class="line">        <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">        drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</span><br><span class="line">                 ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line">                 compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) {</span><br><span class="line">        <span class="comment">// 如果碰到了一个删除操作，并且SequenceNumber &lt;= 最小的Snapshot，</span></span><br><span class="line">        <span class="comment">// 通过IsBaseLevelForKey判断更高的Level不会有这个User Key存在，那么这个Key就被丢弃</span></span><br><span class="line">        <span class="comment">// For this user key:</span></span><br><span class="line">        <span class="comment">// (1) there is no data in higher levels</span></span><br><span class="line">        <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></span><br><span class="line">        <span class="comment">// (3) data in layers that are being compacted here and have</span></span><br><span class="line">        <span class="comment">//     smaller sequence numbers will be dropped in the next</span></span><br><span class="line">        <span class="comment">//     few iterations of this loop (by rule (A) above).</span></span><br><span class="line">        <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></span><br><span class="line">        drop = <span class="literal">true</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      last_sequence_for_key = ikey.sequence;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><code>ParseInternalKey</code>和<code>InternalKey</code>是有所关联的，<code>ParsedInternalKey</code>是解析后的<code>InternalKey</code>。</p><p>如果drop为false，表示没有被丢弃，就添加此key，一旦达到文件大小就实际写入文件，生成新文件。然后input-&gt;next，遍历下一个key。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!drop) {</span><br><span class="line">      <span class="comment">// Open output file if necessary 打开输出文件</span></span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder == <span class="literal">nullptr</span>) {</span><br><span class="line">        status = OpenCompactionOutputFile(compact);</span><br><span class="line">        <span class="keyword">if</span> (!status.ok()) {</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder-&gt;NumEntries() == <span class="number">0</span>) {</span><br><span class="line">        compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);</span><br><span class="line">      }</span><br><span class="line">      compact-&gt;current_output()-&gt;largest.DecodeFrom(key);</span><br><span class="line">      compact-&gt;builder-&gt;Add(key, input-&gt;value()); <span class="comment">//没有被丢弃就添加key</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Close output file if it is big enough     // 达到文件大小，就写入文件，生成新文件</span></span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">          compact-&gt;compaction-&gt;MaxOutputFileSize()) {  <span class="comment">//当前结果超过输出阈值2M</span></span><br><span class="line">        status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">        <span class="keyword">if</span> (!status.ok()) {</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">input-&gt;Next(); <span class="comment">//遍历下一个KV对</span></span><br></pre></td></tr></tbody></table></figure><p><code>DBImpl::DoCompactionWork</code>构造了一个迭代器，开始多路归并的操作，会考虑以下几点：</p><p>1、迭代按照Internal Key的顺序进行，多个连续的Internal Key里面可能包含相同的User Key，按照SequenceNumber降序排列；</p><p>2、相同的User Key里只有第一个User Key是有效的，因为它的SequenceNumber是最大的，覆盖了旧的User Key，但是无法只保留第一个User Key，因为LevelDB支持多版本，旧的User Key可能依然有线程可以引用，但是不再引用的User Key可以安全的删除；</p><p>3、碰到一个删除时，并且它的SequenceNumber &lt;= 最新的Snapshot，会判断更高Level是否有这个User Key存在。如果存在，那么无法丢弃这个删除操作，因为一旦丢弃了，更高Level原被删除的User Key又可见了。如果不存在，那么可以安全的丢弃这个删除操作，这个键就找不到了；最开始看到这个地方的时候有些不太理解，考虑到如何更高level存在的user key如果也是表示为删除的也就是deletion的，就不会出现上述的问题呀，也就是可以直接丢弃这个删除操作</p><blockquote><p>如果这个InternalKey满足一下三个条件，则可以直接丢弃。*     </p><p>1.是个Deletionkey。</p><p>2.sequence &lt;= small_snaphshot。    </p><p>3.当前compact的level是level-n和level-n+1，</p><p> 如果在level-n+1以上的层已经没有此InternalKey对应的user_key了。</p><p>基于以上三种情况可删除。    为什么要此条件(IsBaseLevelForKey)判断呢？</p><p><em>举个例子：</em>     如果在更高层，还有此InternalKey对应的User_key，此时你把当前这个InternalKey删除了，那就会出现两个问题：</p><p>问题1：再次读取删除的key时，就会读取到老的过期的key(这个key的type是非deletion)，这是有问题的。</p><p>问题2：再次合并时，但这个key(这个key的type是非deletion)首次被读取时last_sequence_for_key会设置为kMaxSequenceNumber，这样就也不会丢弃。</p><p>以上两个问题好像在更高层的也就是旧的此key的所有userkey的type都是是delete的时候好像是没问题的，但这毕竟是少数，原则上为了系统正常运行，我们每次丢弃一个标记为kTypeDeletion的key时，必须保证数据库中不存在它的过期key，否则就得将它保留，直到后面它和这个过期的key合并为止，合并之后再丢弃。</p></blockquote><p>4、对于生成的SSTable文件，设置两个上限，哪个先达到，都会开始新的SSTable。一个就是2MB，另外一个就是判断上一Level和这个文件的重叠的文件数量，不超过10个，这是为了控制这个生成的文件Compaction的时候，不会和太多的上层文件重叠。</p><p>最后通过<code>DBImpl::InstallCompactionResults</code>安装Compaction的结果：</p><h3 id="3-5-InstallCompactionResults"><a href="#3-5-InstallCompactionResults" class="headerlink" title="3.5 InstallCompactionResults()"></a>3.5 InstallCompactionResults()</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::InstallCompactionResults</span><span class="params">(CompactionState* compact)</span> </span>{</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  Log(options_.info_log, <span class="string">"Compacted %d@%d + %d@%d files =&gt; %lld bytes"</span>,</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">0</span>), compact-&gt;compaction-&gt;level(),</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">1</span>), compact-&gt;compaction-&gt;level() + <span class="number">1</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(compact-&gt;total_bytes));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add compaction outputs</span></span><br><span class="line">  <span class="comment">// 将该删除的文件和该添加的文件更新到VersionEdit里</span></span><br><span class="line">  compact-&gt;compaction-&gt;AddInputDeletions(compact-&gt;compaction-&gt;edit());</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = compact-&gt;compaction-&gt;level();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.<span class="built_in">size</span>(); i++) {</span><br><span class="line">    <span class="keyword">const</span> CompactionState::Output&amp; out = compact-&gt;outputs[i];</span><br><span class="line">    compact-&gt;compaction-&gt;edit()-&gt;AddFile(level + <span class="number">1</span>, out.number, out.file_size,</span><br><span class="line">                                         out.smallest, out.largest);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> versions_-&gt;LogAndApply(compact-&gt;compaction-&gt;edit(), &amp;mutex_); <span class="comment">//应用一次版本变更，安装新版本</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb学习-安装与编译测试</title>
      <link href="/posts/e867c52e.html"/>
      <url>/posts/e867c52e.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git clone --recurse-submodules http<span class="variable">s:</span>//github.<span class="keyword">com</span>/google/leveldb.git</span><br><span class="line"></span><br><span class="line">sudo apt-<span class="built_in">get</span> install cmake</span><br><span class="line"></span><br><span class="line"><span class="keyword">cd</span> leveldb</span><br><span class="line"></span><br><span class="line">cmake CMakeLists.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">make</span></span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h3 id="ubuntu下leveldb的安装与编译测试"><a href="#ubuntu下leveldb的安装与编译测试" class="headerlink" title="ubuntu下leveldb的安装与编译测试"></a>ubuntu下leveldb的安装与编译测试</h3><p>1.源码下载</p><p>git clone –recurse-submodules <a href="https://github.com/google/leveldb.git" target="_blank" rel="noopener">https://github.com/google/leveldb.git</a></p><p>下载完成之后，在当前目录会有一个leveldb的文件夹。</p><p>2.编译安装</p><p>cd leveldb //进入leveldb目录<br>mkdir -p build &amp;&amp; cd build<br>cmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake –build .</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=<span class="number">1</span> -DCMAKE_BUILD_TYPE=Release .. &amp;&amp;cmake --build .</span><br></pre></td></tr></tbody></table></figure><p>cmake生成用于sourcetrail的json文件</p><p>编译完成之后，leveldb/build/目录下生成了一个静态库libleveldb.a，将这个静态库复制到/usr/local/lib/, 并把leveldb相关的头文件复制到/usr/local/include/</p><p>sudo cp build/libleveldb.a /usr/local/lib/<br>sudo cp -r include/leveldb/ /usr/local/include/</p><p>至此就安装完成啦，下面开始测试</p><p>创建demo.cpp</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;leveldb/db.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  leveldb::DB* db;</span><br><span class="line">  leveldb::Options options;</span><br><span class="line">  options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line">  leveldb::Status status = leveldb::DB::Open(options, <span class="string">"/tmp/testdb"</span>, &amp;db);</span><br><span class="line">  assert(status.ok());</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> key = <span class="string">"test_key"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> value = <span class="string">"test_value"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> get;</span><br><span class="line"> </span><br><span class="line">  leveldb::Status s = db-&gt;Put(leveldb::WriteOptions(), key, value);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (s.ok()) </span><br><span class="line">s = db-&gt;Get(leveldb::ReadOptions(), key, &amp;get);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"key="</span> &lt;&lt; key &lt;&lt; <span class="string">"\nvalue="</span> &lt;&lt; get  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"failed to find the key!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">delete</span> db;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用g++编译，测试，输出结果</p><figure class="highlight maxima"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o <span class="built_in">demo</span> <span class="built_in">demo</span>.cpp -pthread -lleveldb -<span class="built_in">std</span>=c++<span class="number">11</span></span><br></pre></td></tr></tbody></table></figure><p>然后输入<code>./demo</code>结果：</p><p>key=test_key<br>value=test_value</p><p>结果：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201120140718303.png" alt="image-20201120140718303"></p><h3 id="skiplist跳表的数据结构"><a href="#skiplist跳表的数据结构" class="headerlink" title="skiplist跳表的数据结构"></a>skiplist跳表的数据结构</h3><p>SkipList是一种用来代替平衡树的数据结构。<br>    虽然在最坏的情况下SkipList的效率要低于平衡树，但是大多数情况下效率仍然非常高，其插入、删除、查找的时间复杂度都是O(log(N))。<br>除了高效外，其实现和维护非常简单也是一大优势。SkipList的使用还是比较广泛的，比如在LevelDB中的MemTable就是使用SkipList实现的。</p><p>​    skiplist是多层的有序链表</p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>以查找19为例</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/20150530165353841" alt="img"></p><p>先从最上层的跳跃区间大的层开始查找。从头结点开始，首先和23进行比较，小于23，（此时查找指针在图中“1”位置处），查找指针到下一层继续查找。</p><p>然后和9进行判断，大于9，查找指针再往前走一步和23比较，小于23，（此时查找指针在图中“2”位置处） 此时这个值肯定在9结点和23结点之间。查找指针到下一层继续查找。</p><p>然后和13进行判断，大于13，查找指针再往前走一步和23比较，小于23，（此时查找指针在图中“3”位置处）此时这个值肯定在13结点和23结点之间。查找指针到下一层继续查找。此时，我们和19进行判断，找到了。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>包含以下几个操作：</p><p>1、查找到需要插入的位置</p><p>2、申请新的节点</p><p>3、调整指针</p><p>因为在找到插入点之后，新生成节点，新节点按概率出现在每层上，故需要保存所有层的后续指针，这里用一个临时数组保存所有层的插入点处的后续指针。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/20150530170615663" alt="img"></p><p>以上图为例，现在要插入15这个节点。<br>其过程和查找类似，唯一的问题是，前面的节点的指针是如何保留下来的？</p><p>我们可以看到插入结束后，13的level=0的指针指向了15，13的level=1的指针指向了15。<br>这就意味着，在插入的时候我们就需要保留13的level=0的指针和13的level=1的指针。</p><p>在SkipList中是这样做的，有一个update数组，这个数组的大小为maxLevel。<br>还是以上图为例，在15插入之前，update这个数组中就已经存储了当前每个level的指针。</p><ul><li>update[0]：13 level=0</li><li>update[1]：13 level=1</li><li>update[2]：9   level=2</li><li>update[3]：null level=3</li></ul><p>skiplist的删除</p><p>删除的逻辑和插入类似</p><p>1、查找到相应的节点</p><p>2、通过update数组来实现该节点的逻辑删除</p><p>3、回收该节点资源 </p><h2 id="sstable的读取过程"><a href="#sstable的读取过程" class="headerlink" title="sstable的读取过程"></a>sstable的读取过程</h2><p>sstable的读取过程，简单总结就是四个字:按图索骥</p><p>各个索引在读取过程中发挥了很大的作用。首先是seek到文件末尾读取固定48个字节大小的footer，footer是定长的。最后有8个字节的magic校验</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201125153200335.png" alt="image-20201125153200335"></p><p>然后解析出<code>meta index block</code> 以及<code>index_block</code>。</p><p>通过<code>meta index block</code> 解析出filter block</p><p>通过index block解析出data_block</p><p>查找时先通过filter block查找是否存在，然后通过data_block解析出对应的value.</p><h2 id="compaction操作"><a href="#compaction操作" class="headerlink" title="compaction操作"></a>compaction操作</h2><h5 id="backgroundcompaction函数的调用关系图"><a href="#backgroundcompaction函数的调用关系图" class="headerlink" title="backgroundcompaction函数的调用关系图"></a>backgroundcompaction函数的调用关系图</h5><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201125205236672.png" alt="image-20201125205236672"></p><h6 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h6><p>compactmemtable主要流程分为三部分：</p><ol><li><code>WriteLevel0Table(imm_, &amp;edit, base)</code>：<code>imm_</code>落盘成为新的 sst 文件，文件信息记录到 <code>edit</code></li><li><code>versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_)</code>：将本次文件更新信息<code>versions_</code>，当前的文件（包含新的 sst 文件）作为数据库的一个最新状态，后续读写都会基于该状态</li><li><code>DeleteObsoleeteFiles</code>：删除一些无用文件</li></ol><p>通过Finalize函数计算compaction的level和score</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb学习记录-各组件的默认大小</title>
      <link href="/posts/86b8d360.html"/>
      <url>/posts/86b8d360.html</url>
      
        <content type="html"><![CDATA[<h2 id="memtable的大小"><a href="#memtable的大小" class="headerlink" title="memtable的大小"></a>memtable的大小</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Amount of data to build up in memory (backed by an unsorted log</span></span><br><span class="line"><span class="comment">// on disk) before converting to a sorted on-disk file.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Larger values increase performance, especially during bulk loads.</span></span><br><span class="line"><span class="comment">// Up to two write buffers may be held in memory at the same time,</span></span><br><span class="line"><span class="comment">// so you may wish to adjust this parameter to control memory usage.</span></span><br><span class="line"><span class="comment">// Also, a larger write buffer will result in a longer recovery time</span></span><br><span class="line"><span class="comment">// the next time the database is opened.</span></span><br><span class="line"><span class="keyword">size_t</span> write_buffer_size = <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//memtable的最大size</span></span><br></pre></td></tr></tbody></table></figure><p>表示一个memtable的最大大小，默认为==4MB==</p><h2 id="sstable的大小"><a href="#sstable的大小" class="headerlink" title="sstable的大小"></a>sstable的大小</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Leveldb will write up to this amount of bytes to a file before</span></span><br><span class="line"><span class="comment">// switching to a new one.</span></span><br><span class="line"><span class="comment">// Most clients should leave this parameter alone.  However if your</span></span><br><span class="line"><span class="comment">// filesystem is more efficient with larger files, you could</span></span><br><span class="line"><span class="comment">// consider increasing the value.  The downside will be longer</span></span><br><span class="line"><span class="comment">// compactions and hence longer latency/performance hiccups.</span></span><br><span class="line"><span class="comment">// Another reason to increase this parameter might be when you are</span></span><br><span class="line"><span class="comment">// initially populating a large database.</span></span><br><span class="line"><span class="keyword">size_t</span> max_file_size = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>;<span class="comment">//最大文件尺寸</span></span><br></pre></td></tr></tbody></table></figure><p>sstable默认为2MB</p><a id="more"></a><h2 id="level0的文件大小"><a href="#level0的文件大小" class="headerlink" title="level0的文件大小"></a>level0的文件大小</h2><p>level 0 的文件是无序的，每次查找 level 0都需要查找所有文件，因此需要严格控制个数。</p><p>当文件数目 &gt;= <code>config::kL0_SlowdownWritesTrigger</code> 时，通过 sleep 延缓写入，当文件数目 &gt;= <code>config::kL0_StopWritesTrigger</code>时，则完全停止写入，等待后台 compaction.这两个数字分别是 8 和 12.</p><p>由于 memtable 是通过 <code>BuildTable</code> 一次性生成一个文件，因此文件大小 ~ 4M左右.</p><p>compact 会有一个 score 的筛选，其中 level 0 的计算公式为：</p><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score = v-&gt;files_[level].<span class="built_in">size</span>() /</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">config</span>::kL0_CompactionTrigger);</span><br></pre></td></tr></tbody></table></figure><p>当 <code>score &gt;= 1.0</code> 时，就会触发往下层的文件归并操作，因此可以认为 level 0 比较理想的个数应当 &lt; <code>config::kL0_CompactionTrigger</code>，该值为 4.</p><!--more--><h2 id="level-1-的文件大小及个数"><a href="#level-1-的文件大小及个数" class="headerlink" title="level 1+ 的文件大小及个数"></a>level 1+ 的文件大小及个数</h2><p>level 最大一共是 7层，范围是<code>[0, kNumLevels = 7)</code>.</p><p>各 level 的文件都是归并生成的，在<code>DoCompactionWork</code>生成文件，当文件大小超过<code>MaxOutputFileSize</code>时，则重新打开新文件写入。这个大小对所有 level 都是一样的，默认值是<code>options-&gt;max_file_size = 2M</code>.</p><p>每次的文件总大小是<code>MaxBytesForLevel</code>，随着 level 增大，从<code>10M</code>到<code>1T</code>.</p><table><thead><tr><th>level</th><th>single file size</th><th>totla file size</th></tr></thead><tbody><tr><td>0</td><td>4M</td><td>4M*(4 or 8 or 12)</td></tr><tr><td>1</td><td>2M</td><td>10M</td></tr><tr><td>2</td><td>2M</td><td>100M</td></tr><tr><td>3</td><td>2M</td><td>1G</td></tr><tr><td>4</td><td>2M</td><td>10G</td></tr><tr><td>5</td><td>2M</td><td>100G</td></tr><tr><td>6</td><td>2M</td><td>1T</td></tr></tbody></table><p>sstable data block的默认大小为4K</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Approximate size of user data packed per block.  Note that the</span></span><br><span class="line"><span class="comment">// block size specified here corresponds to uncompressed data.  The</span></span><br><span class="line"><span class="comment">// actual size of the unit read from disk may be smaller if</span></span><br><span class="line"><span class="comment">// compression is enabled.  This parameter can be changed dynamically.</span></span><br><span class="line"><span class="keyword">size_t</span> block_size = <span class="number">4</span> * <span class="number">1024</span>;<span class="comment">//sstable中block的size</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb之读过程</title>
      <link href="/posts/27a72563.html"/>
      <url>/posts/27a72563.html</url>
      
        <content type="html"><![CDATA[<p>LevelDB 首先会去查看内存中的 Memtable，如果 Memtable 中包含 key 及其对应的value，则返回 value 值即可；</p><p>如果在 Memtable 没有读到key，则接下来到同样处于内存中的 Immutable Memtable 中去读取，类似地，如果读到就返回，若是没有读到,那么只能万般无奈下从磁盘中的大量SSTable文件中查找。</p><a id="more"></a><p>sstable文件由data block、meta block、metaindex block、index blcok和footer组成。默认大小2MB。</p><p>如果数据不在内存中的组件中，那就需要在磁盘的sstable文件中查找了，基于B+树思想的存储引擎，利用索引可以直接定位到具体的哪个磁盘块，而LSM树的存储引擎需要遍历多个sstable文件才能确定数据在哪个磁盘块，读性能自然就不如B+树了。在介绍如何在磁盘上查找含有指定Key的sstable之前先介绍一个重要的数据结构：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMetaData</span> {</span></span><br><span class="line">  <span class="keyword">int</span> refs;</span><br><span class="line">  <span class="keyword">int</span> allowed_seeks;          <span class="comment">// Seeks allowed until compaction</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  <span class="keyword">uint64_t</span> file_size;         <span class="comment">// File size in bytes</span></span><br><span class="line">  InternalKey smallest;       <span class="comment">// Smallest internal key served by table</span></span><br><span class="line">  InternalKey largest;        <span class="comment">// Largest internal key served by table</span></span><br><span class="line">  FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) { }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>FileMetaData数据结构保存了sstable文件的元数据，包括文件的名字number、key的范围、引用次数。每个sstable文件对应一个FileMetaData，每一层的sstable对应的FileMetaData用std::vecotr保存，定位key在磁盘的哪个sstable文件中需要逐层遍历(level-by-level)，另外L0层因为sstable文件之间可能存在key重叠，所以L0层处理方式与其它层不同，下面介绍具体的查找过程：</p><p>1、先定位key可能在哪些sstable文件中。这里的定位利用了上面的FileMetaData结构体里的smallest、largest字段，如果在这个范围里，该文件的FileMetaData加入一个vcetor tmp保存，每一层有很多的sstable文件，而且key可能存在多个版本，所以tmp里面可能存在很多sstable文件，如何确定最新的版本在哪个文件里呢？查找的原则应该是先从最新的sstable文件中查找，对于L0层，LevelDB做了优化，这里要说明一下，sstable文件是用uint64_t number命名的，而且越新的数据number越大，所以vector tmp按照FileNumber排序。非L0层的sstable文件之间key不会重叠，所以可以利用二分查找定位sstable。</p><p>2、在第一步定位了key可能存在的sstable之后，第二步需要定位key在sstable文件的哪个data block里面，图中sstable格式里有一个重要的模块：index block。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/leveldb-02-06.png" alt="逻辑布局"></p><p>index block存储了data block的索引，为了加速读性能，leveldb也做了优化，把经常访问的sstable的index block缓存在cache中，关于cache的知识点后续会介绍。利用index block可以快速定位key可能存在哪个data block中。如何确定key到底在不在data block呢，LevelDB利用bloom filter，如果通过bloom filter得出key不在此data block中，那么该key 肯定不在此data block中，则data not found；如果通过bloom filter得出key在此data block中，还不能完全肯定在此data block中，还需要去遍历该data block。</p><p>如果在immutable memtable flush to磁盘之前，new创建的mutable memtable已经被填满，insert操作将会被暂停，stall</p><p>当前的LSM设计要承受高昂的压缩成本，因为压缩涉及迭代不可变的内存表跳过列表，将数据序列化为磁盘兼容（SSTable）格式。</p><p><font color="orange"> 序列化：将对象转化为字节序列的过程，数据持久化为sstable格式。为什么要进行序列化？  为了数据持久化</font>。</p><p>磁盘的sstable包含多个level，最坏情况下有可能触发链式compaction操作，使前台更新stall</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>源码阅读工具-sourcetrail的使用</title>
      <link href="/posts/2516b88f.html"/>
      <url>/posts/2516b88f.html</url>
      
        <content type="html"><![CDATA[<p>基本原理是通过生成 cmake生成<code>compile_commands.json</code></p><p>这个文件记录了所有C++文件的编译指令</p><p>cmake项目采用如下指令：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>非cmake项目，如 Visual Studio 有官方的插件，其它 IDE 也有相应的官方插件。</p><ul><li>根据 compile_commands.json 中的条目，逐一解析索引相关 C++ 源文件，收集所有信息存储在本地数据库中，并生成全文索引信息。</li><li>根据查询需求，展示所有相关信息。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>由于 compile_commands.json 中是没有头文件的编译指令的，因此所有需要索引的头文件（或者包含头文件的目录）都需要在项目设置中手动指定。<br>幸而它会递归搜索所有子目录，所以只要设置根目录就可以了。当然还可以根据需要，逐个添加部分自己感兴趣的目录。<br>毕竟文件越多，索引的越慢。<br>由于其索引器是静态链接 clang 的相关库，所以一些 Visual Studio 特有的编译参数（/ 开头）并不支持，这其实并不影响索引，手动移除即可。<br>对项目设置额外的编译器参数 -driver=cl 并不起作用。<br>如果项目启用了合并编译，则一些源文件会标记为 ExcludeFromBuild，这些文件就不会出现在 compile_commands.json，也就不会被索引。自己想办法替换成原始的文件吧。</p><a id="more"></a><h3 id="ubuntu下leveldb的安装与编译测试"><a href="#ubuntu下leveldb的安装与编译测试" class="headerlink" title="ubuntu下leveldb的安装与编译测试"></a>ubuntu下leveldb的安装与编译测试</h3><p>1.源码下载</p><p>git clone –recurse-submodules <a href="https://github.com/google/leveldb.git" target="_blank" rel="noopener">https://github.com/google/leveldb.git</a></p><p>下载完成之后，在当前目录会有一个leveldb的文件夹。</p><p>2.编译安装</p><p>cd leveldb //进入leveldb目录<br>mkdir -p build &amp;&amp; cd build<br>cmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake –build .</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_EXPORT_COMMANDS=<span class="number">1</span> -DCMAKE_BUILD_TYPE=Release .. &amp;&amp;cmake --build .</span><br></pre></td></tr></tbody></table></figure><p>cmake生成用于sourcetrail的json文件</p><p>编译完成之后，leveldb/build/目录下生成了一个静态库libleveldb.a，将这个静态库复制到/usr/local/lib/, 并把leveldb相关的头文件复制到/usr/local/include/</p><p>sudo cp build/libleveldb.a /usr/local/lib/<br>sudo cp -r include/leveldb/ /usr/local/include/</p><p>至此就安装完成啦，下面开始测试。</p><h3 id="sourcetrail使用教程"><a href="#sourcetrail使用教程" class="headerlink" title="sourcetrail使用教程"></a>sourcetrail使用教程</h3><p>首先我们需要创建一个新项目，输入一个项目名称，然后选择一个项目位置。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20210529131110261.png" alt="image-20210529131110261"></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20210529131151080.png" alt="image-20210529131151080"></p><p>这里我们选择项目的根目录。</p><p>现在我们需要在项目中添加至少一个源组，每个sourcetrail项目都包含一个或多个元组。来源组定义一组文件以及用于正确索引他们的其他信息。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20210529132124230.png" alt="image-20210529132124230"></p><p>编译数据库，是最简单的方法，编译数据库是JSON文件，包含代码库中所有源文件和所有文件的列表，建立它们的必要信息。</p><p>我们可以得到这个JSON文件，通过从CMake使用C_MAKE_EXPORT_COMPILE_COMMANDS标志。添加该标志并重新运行CMake后，就可以看到该compile_commands.json文件。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20210529132328564.png" alt="image-20210529132328564"></p><p>该json文件包含一个列表，所有源文件以及有关如何构建他们的所有信息，如果无法生成，还有其他方式生成。在MacOS或Linux上，可以尝试使用Bear或Build EAR以模拟创建编译数据库文件，如果在windows上使用Visual Studio，则可以使用sourtrail extension拓展来导出我们的 编译数据库。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20210529132547056.png" alt="image-20210529132547056"></p><p>接下来点击创建，然后等待一会出现Finished Indexing就完成了。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20210529154141538.png" alt="image-20210529154141538"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leveldb学习记录-互斥锁、原子量</title>
      <link href="/posts/63a2cc78.html"/>
      <url>/posts/63a2cc78.html</url>
      
        <content type="html"><![CDATA[<p>leveldb使用的仍然是C++标准库中的互斥量和条件变量，做了简单的封装<code>port/port_stdcxx.h</code></p><a id="more"></a><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBImpl</span> {</span></span><br><span class="line">  <span class="comment">// Queue of writers.</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;Writer*&gt; writers_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="function">WriteBatch* tmp_batch_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Information kept for every waiting writer</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DBImpl</span>:</span>:Writer {</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Writer</span><span class="params">(port::Mutex* mu)</span></span></span><br><span class="line">      : batch(nullptr), sync(false), done(false), cv(mu) {}</span><br><span class="line"></span><br><span class="line">  Status status;</span><br><span class="line">  WriteBatch* batch;</span><br><span class="line">  <span class="keyword">bool</span> sync;</span><br><span class="line">  <span class="keyword">bool</span> done;</span><br><span class="line">  port::CondVar cv;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">DBImpl::Write</span><span class="params">(<span class="keyword">const</span> WriteOptions&amp; options, WriteBatch* updates)</span> </span>{</span><br><span class="line">  <span class="function">Writer <span class="title">w</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  w.batch = updates;</span><br><span class="line">  w.sync = options.sync;</span><br><span class="line">  w.done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  writers_.push_back(&amp;w);</span><br><span class="line">  <span class="keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.front()) {</span><br><span class="line">    w.cv.Wait();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (w.done) {</span><br><span class="line">    <span class="keyword">return</span> w.status;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// May temporarily unlock and wait.</span></span><br><span class="line">  Status status = MakeRoomForWrite(updates == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">uint64_t</span> last_sequence = versions_-&gt;LastSequence();</span><br><span class="line">  Writer* last_writer = &amp;w;</span><br><span class="line">  <span class="keyword">if</span> (status.ok() &amp;&amp; updates != <span class="literal">nullptr</span>) {  <span class="comment">// nullptr batch is for compactions</span></span><br><span class="line">    WriteBatch* updates = BuildBatchGroup(&amp;last_writer);</span><br><span class="line">    WriteBatchInternal::SetSequence(updates, last_sequence + <span class="number">1</span>);</span><br><span class="line">    last_sequence += WriteBatchInternal::Count(updates);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add to log and apply to memtable.  We can release the lock</span></span><br><span class="line">    <span class="comment">// during this phase since &amp;w is currently responsible for logging</span></span><br><span class="line">    <span class="comment">// and protects against concurrent loggers and concurrent writes</span></span><br><span class="line">    <span class="comment">// into mem_.</span></span><br><span class="line">    {</span><br><span class="line">      mutex_.Unlock();</span><br><span class="line">      status = log_-&gt;AddRecord(WriteBatchInternal::Contents(updates));</span><br><span class="line">      <span class="keyword">bool</span> sync_error = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (status.ok() &amp;&amp; options.sync) {</span><br><span class="line">        status = logfile_-&gt;Sync();</span><br><span class="line">        <span class="keyword">if</span> (!status.ok()) {</span><br><span class="line">          sync_error = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span> (status.ok()) {</span><br><span class="line">        status = WriteBatchInternal::InsertInto(updates, mem_);</span><br><span class="line">      }</span><br><span class="line">      mutex_.Lock();</span><br><span class="line">      <span class="keyword">if</span> (sync_error) {</span><br><span class="line">        <span class="comment">// The state of the log file is indeterminate: the log record we</span></span><br><span class="line">        <span class="comment">// just added may or may not show up when the DB is re-opened.</span></span><br><span class="line">        <span class="comment">// So we force the DB into a mode where all future writes fail.</span></span><br><span class="line">        RecordBackgroundError(status);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (updates == tmp_batch_) tmp_batch_-&gt;Clear();</span><br><span class="line"></span><br><span class="line">    versions_-&gt;SetLastSequence(last_sequence);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    Writer* <span class="built_in">ready</span> = writers_.front();</span><br><span class="line">    writers_.pop_front();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ready</span> != &amp;w) {</span><br><span class="line">      <span class="built_in">ready</span>-&gt;status = status;</span><br><span class="line">      <span class="built_in">ready</span>-&gt;done = <span class="literal">true</span>;</span><br><span class="line">      <span class="built_in">ready</span>-&gt;cv.Signal();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ready</span> == last_writer) <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Notify new head of write queue</span></span><br><span class="line">  <span class="keyword">if</span> (!writers_.empty()) {</span><br><span class="line">    writers_.front()-&gt;cv.Signal();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// REQUIRES: Writer list must be non-empty</span></span><br><span class="line"><span class="comment">// REQUIRES: First writer must have a non-null batch</span></span><br><span class="line"><span class="function">WriteBatch* <span class="title">DBImpl::BuildBatchGroup</span><span class="params">(Writer** last_writer)</span> </span>{</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(!writers_.empty());</span><br><span class="line">  Writer* first = writers_.front();</span><br><span class="line">  WriteBatch* result = first-&gt;batch;</span><br><span class="line">  assert(result != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> <span class="built_in">size</span> = WriteBatchInternal::ByteSize(first-&gt;batch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow the group to grow up to a maximum size, but if the</span></span><br><span class="line">  <span class="comment">// original write is small, limit the growth so we do not slow</span></span><br><span class="line">  <span class="comment">// down the small write too much.</span></span><br><span class="line">  <span class="keyword">size_t</span> max_size = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">size</span> &lt;= (<span class="number">128</span> &lt;&lt; <span class="number">10</span>)) {</span><br><span class="line">    max_size = <span class="built_in">size</span> + (<span class="number">128</span> &lt;&lt; <span class="number">10</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  *last_writer = first;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;Writer*&gt;::iterator iter = writers_.<span class="built_in">begin</span>();</span><br><span class="line">  ++iter;  <span class="comment">// Advance past "first"</span></span><br><span class="line">  <span class="keyword">for</span> (; iter != writers_.<span class="built_in">end</span>(); ++iter) {</span><br><span class="line">    Writer* w = *iter;</span><br><span class="line">    <span class="keyword">if</span> (w-&gt;sync &amp;&amp; !first-&gt;sync) {</span><br><span class="line">      <span class="comment">// Do not include a sync write into a batch handled by a non-sync write.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (w-&gt;batch != <span class="literal">nullptr</span>) {</span><br><span class="line">      <span class="built_in">size</span> += WriteBatchInternal::ByteSize(w-&gt;batch);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">size</span> &gt; max_size) {</span><br><span class="line">        <span class="comment">// Do not make batch too big</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      }</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Append to *result</span></span><br><span class="line">      <span class="keyword">if</span> (result == first-&gt;batch) {</span><br><span class="line">        <span class="comment">// Switch to temporary batch instead of disturbing caller's batch</span></span><br><span class="line">        result = tmp_batch_;</span><br><span class="line">        assert(WriteBatchInternal::Count(result) == <span class="number">0</span>);</span><br><span class="line">        WriteBatchInternal::Append(result, first-&gt;batch);</span><br><span class="line">      }</span><br><span class="line">      WriteBatchInternal::Append(result, w-&gt;batch);</span><br><span class="line">    }</span><br><span class="line">    *last_writer = w;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>假设现在有编号为 [1, 2, 3, 4] 的四个线程基本同时调用写入操作，发生的事件如下：</p><ol><li>每个线程中各自构造 <code>Writer</code>；</li><li>1 号线程较快地构造了 <code>MutexLock</code> 拿到锁，[2, 3, 4] 则阻塞在此处；</li><li>1 号线程将写入请求插入双向队列中，跳过循环，继续向下走；</li><li>1 号线程执行 <code>BuildBatchGroup</code>，由于队列中只有自身一个请求，不会发生合并；</li><li>1 号线程执行 <code>mutex_.Unlock()</code> 释放锁，随后执行写入操作，完成后执行 <code>mutex_.Lock()</code> 再次获得锁；</li><li>1 号线程在循环中从双向队列里将写入请求弹出，最后通知队列顶的 2 号线程唤醒；</li><li>1号线程析构局部变量、释放锁。</li></ol><p>在第 5 步发生释放锁的同时：</p><ol><li>2 号线程获得锁，将写入请求插入双向队列中，由于请求不在队列顶端，进而进入循环、等待、释放锁；</li><li>3 号线程获得锁，将写入请求插入双向队列中，由于请求不在队列顶端，进而进入循环、等待、释放锁；</li><li>此时 1 号线程写入完成、执行 <code>mutex_.Lock()</code> 获得锁，4 号线程继续等待；</li><li>1 号线程执行结束、释放锁，2 号线程唤醒获得锁，执行 <code>BuildBatchGroup</code> 将队列中的 3 号线程中的写入请求合并；</li><li>2 号线程执行 <code>mutex_.Unlock()</code> 解锁，随后执行写入操作，完成后执行 <code>mutex_.Lock()</code> 再次获得锁。与此同时 4 号线程获得锁，将写入请求插入双向队列中，等待、释放锁；</li><li>2 号线程在循环中从双向队列里将写入请求弹出，将 3 号线程的写入请求标记为完成，尝试唤醒 3 号线程；</li><li>2 号线程析构局部变量、释放锁。3 号线程唤醒、获得锁，判断已完成，返回、释放锁；</li><li>4 号线程唤醒、获得锁，正常执行。</li></ol><p>上述合并操作依赖写入时的释放锁操作，这使得其他线程有机会加入队列、然后等待，在下一次获得锁时合并队列中的其他写入请求。</p><p>LevelDB是一个多线程系统，会有后台线程负责sstable的compact，同时用户也可能采用多线程进行并发访问。因此需要一些机制来协调线程工作，控制memtable等共享资源的并发读写，主要通过如下三种机制来实现。在这里我们主要关注port/port_posix.h里的对应实现。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port::Mutex mutex_;</span><br><span class="line"></span><br><span class="line">port::AtomicPointer shutting_down_;</span><br><span class="line"></span><br><span class="line">port::CondVar bg_cv_;      <span class="comment">// Signalled when background work finishes</span></span><br></pre></td></tr></tbody></table></figure><p>在leveldb中，通过调用pthread_mutex_init初始化互斥锁，mutexattr用于指定互斥锁属性，采用默认属性。主要有以下两种用法：一种是单纯的作为Mutex，另一个用法是封装在MutexLock中，在MutexLock的构造函数和析构函数中进行加锁和解锁。</p><blockquote><p>主要有如下地方使用到了互斥锁：db/db_impl.cc 中DBImpl 有成员变量port::Mutex mutex_;此外在db/db_impl.cc，db/db_bench.cc，util/cache.cc，helpers/memenv/memenv.cc中还都使用了MutexLock。</p><p>在很多过程中都会用到互斥锁，比如：</p><p>l DBImpl析构中等待后台compaction结束的过程</p><p>l DBImpl::WriteLevel0Table中将memtable内容写入sstable时</p><p>l DBImpl::CompactMemTable中versions_-&gt;LogAndApply时</p><p>l DBImpl::CompactRange中访问versions_-&gt;current()时</p><p>l DBImpl::BackgroundCall()中</p><p>l DBImpl::OpenCompactionOutputFile中创建output file时</p><p>l DBImpl::NewInternalIterator</p><p>l DBImpl::Get</p><p>l DBImpl::GetSnapshot</p><p>l DBImpl::ReleaseSnapshot</p><p>l DBImpl::Write</p><p>l DBImpl::GetProperty</p><p>l DBImpl::GetApproximateSizes</p><p>l DB::Open</p><p>基本上所有的DB相关函数都使用到了该Mutex变量。因此理解这些函数中何时为何加锁解锁以及不加会有什么问题，对于理解函数实现是至关重要的。此外该Mutex变量还会被传入VersionSet::LogAndApply中，传入的目的主要是为了优化锁，在写入MANIFEST log时会进行解锁。</p></blockquote><h3 id="条件变量的使用"><a href="#条件变量的使用" class="headerlink" title="条件变量的使用"></a>条件变量的使用</h3><p>与互斥量不同，条件变量是用来等待而不是用来上锁的。条件变量用来自动阻塞一个线程，直到某特殊情况发生为止。通常条件变量和互斥锁同时使用。条件变量使我们可以睡眠等待某种条件出现。条件变量是利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使”条件成立”（给出条件成立信号）。</p><p>条件的检测是在互斥锁的保护下进行的。如果一个条件为假，一个线程自动阻塞，并释放等待状态改变的互斥锁。如果另一个线程改变了条件，它发信号给关联的条件变量，唤醒一个或多个等待它的线程，重新获得互斥锁，重新评价条件。</p><blockquote><p>利用pthread_cond_t和Mutex实现CondVar。在LevelDB中有如下地方使用了CondVar：</p></blockquote><p>port::CondVar bg_cv_;用于等待后台compaction线程的结束</p><p>port::CondVar cv;用于等待Writer完成</p><h3 id="原子指针"><a href="#原子指针" class="headerlink" title="原子指针"></a>原子指针</h3><p>原子变量即操作变量的操作是原子的，该操作不可再分，因此是线程安全的。使用原子变量的原因是多个线程对单个变量操作也会引起问题。原子变量只是保证单个变量在某一个操作过程的原子性，但是无法保证整个程序的安全性。当共享资源是位或整型变量，是一个完整的加锁体制对于一个简单的整数值看来过分了. 对于这样的情况，使用原子变量效率更高。</p><p>在LevelDB中使用的是AtomicPointer，用来提供对指针变量的原子性访问。有两种实现方式，一种是采用cstdatomic，一种是采用 <a href="http://www.linuxforum.net/forum/printthread.php?Cat=&amp;Board=linuxK&amp;main=653778&amp;type=thread" target="_blank" rel="noopener">MemoryBarrier</a>。基于MemoryBarrier的实现要比cstdatomic快很多，关于MemoryBarrier的作用可参考 <a href="http://blog.renren.com/share/281270102/6849391011" target="_blank" rel="noopener">Why Memory Barrier</a>， <a href="http://blog.chinaunix.net/uid-9863638-id-1996308.html" target="_blank" rel="noopener">barrier内存屏蔽</a>。</p><p>可以看到MemoryBarrier()实际上就是如下的一条汇编语句：</p><p><strong>asm</strong> <strong>volatile</strong>(“” : : : “memory”);</p><p>1）<strong>asm</strong>用于指示编译器在此插入汇编语句</p><p>2）<strong>volatile</strong>用于告诉编译器，严禁将此处的汇编语句与其它的语句重组合优化。即：原原本本按原来的样子处理这这里的汇编。</p><p>3）memory强制gcc编译器假设RAM所有内存单元均被汇编指令修改，这样cpu中的registers和cache中已缓存的内存单元中的数据将作废。cpu将不得不在需要的时候重新读取内存中的数据。这就阻止了cpu又将registers，cache中的数据用于去优化指令，而避免去访问内存。</p><p>4）””:::表示这是个空指令。</p><p>如下地方使用到了AtomicPointer：</p><p>db/skiplist.h</p><p>port::AtomicPointer next_[1];</p><p>port::AtomicPointer max_height_;</p><p>db/db_impl.h</p><p>port::AtomicPointer shutting_down_;</p><p>port::AtomicPointer has_imm_;</p><hr><p>互斥，可以保护数据，避免资源竞争，那么互斥为什么会带来死锁呢？</p><p>常见两种典型的死锁情形：</p><p>1、线程自己将自己锁住，如果一个线程先后两次调用lock，由于第二次调用时，锁已被占用，该线程会挂起等待占用该锁的线程释放锁，而锁正是被自己占用的，该线程又被挂起没办法释放锁，就一直处于挂起等待状态了，形成了死锁。</p><p>2、多线程抢占锁资源造成死锁，如线程A获得了锁1，线程B获得了锁2，此时线程A试图调用lock获得锁2，需要挂起等待锁2被释放（也就是线程B释放锁2）；此时线程B试图调用lock获得锁1，需要挂起等待锁1被释放（也就是线程A释放锁1）。这样，线程A和线程B都处于挂起状态了，形成死锁。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leveldb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu16.04安装tensorflow教程</title>
      <link href="/posts/6efa.html"/>
      <url>/posts/6efa.html</url>
      
        <content type="html"><![CDATA[<p>教程链接：<a href="https://www.tensorflow.org/install/pip" target="_blank" rel="noopener">https://www.tensorflow.org/install/pip</a></p><ol><li>在系统上安装python开发环境</li><li>安装python、pip软件包管理器和Virtualenv<br>sudo apt update<br>sudo apt install python3-dev python3-pip<br>sudo pip3 install -U virtualenv  # system-wide install</li></ol><a id="more"></a><p>通过系统安装的方式安装TensorFlow<br>pip3 install –user –upgrade tensorflow</p><p>gnome-system-monitor</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leveldb-study</title>
      <link href="/posts/a6e0.html"/>
      <url>/posts/a6e0.html</url>
      
        <content type="html"><![CDATA[<p>2020年11月我学习了leveldb，google开发的一个高效KV数据库</p><a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>实验室服务器RTX2080Ti安装nvidia驱动</title>
      <link href="/posts/76e1b77c.html"/>
      <url>/posts/76e1b77c.html</url>
      
        <content type="html"><![CDATA[<p>ubuntu16.04 RTX2080Ti</p><h2 id="一、安装NVIDIA驱动"><a href="#一、安装NVIDIA驱动" class="headerlink" title="一、安装NVIDIA驱动"></a>一、安装NVIDIA驱动</h2><p>1.下载驱动文件<br>去官网下载和自己的显卡适配的驱动文件，是个.run文件。贴个下载地址：<a href="https://www.nvidia.cn/Download/index.aspx" target="_blank" rel="noopener">https://www.nvidia.cn/Download/index.aspx</a></p><p>search之后下载就行，记住它下载到了哪个文件夹里，以后会用的到<br>2.文件已经下载好了，但是在安装之前我我们需要做一些准备。<br>（1）、删除原有驱动（可选）：$ sudo apt-get remove –purge nvidia*<br>我在删除的时候就提示我没有原有的驱动。<br>（2）、禁用nouveau，安装NVIDIA需要把系统自带的驱动禁用<br>打开文件：<code>sudo gedit /etc/modprobe.d/blacklist.conf</code><br>在文本最后添加以下内容：</p><a id="more"></a><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">blacklist</span> <span class="string">nouveau</span></span><br><span class="line"><span class="attr">options</span> <span class="string">nouveau modeset=0</span></span><br></pre></td></tr></tbody></table></figure><p>然后保存退出<br>执行：<code>sudo update-initramfs -u</code><br>重启，命令行输入：<code>lsmod | grep nouveau</code><br>没有任何输出的话就代表禁用成功。</p><h3 id="3-安装NVIDIA驱动程序（准备另一台电脑，用来看教程或者是查找需要输入的命令）"><a href="#3-安装NVIDIA驱动程序（准备另一台电脑，用来看教程或者是查找需要输入的命令）" class="headerlink" title="3.安装NVIDIA驱动程序（准备另一台电脑，用来看教程或者是查找需要输入的命令）"></a>3.安装NVIDIA驱动程序（准备另一台电脑，用来看教程或者是查找需要输入的命令）</h3><p>用图形界面服务：<code>sudo service lightdm stop</code><br>按Ctrl+Alt+F1进入命令行，输入用户名密码登录（通过Ctrl+Alt+F7可返回界面）<br>下载的是.run文件，首先给文件赋予执行权限，首先cd到下载目录：（重要的事情说三遍：注意参数、注意参数、注意参数）<br>打开所在的文件夹：<code>cd ～/download/</code> （这里应该写你当时把.run文件下载到的文件夹的路径，一般默认是下载文件夹，如果你在这里出现错误，比如找不到文件，或者路径是中文的，可以尝试把.run文件移动到一个home下，这样可以直接打：cd /home/你的用户名/ 这样就可以打开了。）<br>然后输入：<code>sudo chmod a+x NVIDIA-Linux-x86_64-410.78.run</code> （敲自己下载的文件名字）<br>这是不会有什么输出。<br>接着安装：<code>sudo ./NVIDIA-Linux-x86_64-410.78.run –no-opengl-files</code></p><p>no-opengl-files 只安装驱动文件，不安装opengl文件。这个参数最重要<br>–no-x-check 安装驱动时不检查X服务<br>–no-nouveau-check 安装驱动时不检查nouveau<br>后面两个参数可不加。<br>接着就是一直选择它默认的那个选项就好。<br>然后挂载驱动： <code>modprobe nvidia</code><br>最后查看是否已经安装好了：<code>nvidia-smi</code></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201223141432219.png" alt="image-20201223141432219"></p><p>出现这种界面，说明已经安装成功。可以打开图形界面了：<code>sudo service lightdm start</code>。后面的安装直接在终端即可。</p><h2 id="二、安装cuda-10-0"><a href="#二、安装cuda-10-0" class="headerlink" title="二、安装cuda 10.0"></a>二、安装cuda 10.0</h2><p>安装和自己显卡的适配版本，我选择的是cuda 10.0。</p><h4 id="1-下载文件"><a href="#1-下载文件" class="headerlink" title="1.下载文件"></a>1.下载文件</h4><p>官网地址：<a href="https://developer.nvidia.com/cuda-zone" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-zone</a> 选择适合自己的版本</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201223145849652.png" alt="image-20201223145849652"></p><h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h4><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+x cuda_10<span class="number">.0</span><span class="number">.130</span>_410<span class="number">.48</span>_linux.run <span class="comment">// 获取权限</span></span><br><span class="line">sudo sh cuda_10<span class="number">.0</span><span class="number">.130</span>_410<span class="number">.48</span>_linux.run</span><br></pre></td></tr></tbody></table></figure><p>这时会出现很长的声明，一直按enter键，把声明读完，然后就可以进行选择了。</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20201223145653513.png" alt="image-20201223145653513"></p><p>因为是独立安装的NVIDIA 程序，所以进行上面的选择，安装完成后会出现个提醒，这是因为我在安装CUDA的时候没有选择安装驱动，提示需要安装驱动，忽略就行。</p><h4 id="3-加入环境变量"><a href="#3-加入环境变量" class="headerlink" title="3.加入环境变量"></a>3.加入环境变量</h4><p>打开.bashrc 文件：<code>sudo gedit ~/.bashrc</code><br>打开文件后将下面两句话加入进去：</p><figure class="highlight elixir"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export LD_LIBRARY_PATH=<span class="variable">$LDLIBRARY_PATH</span><span class="symbol">:/usr/local/cuda-</span><span class="number">10.0</span>/lib64</span><br><span class="line">export PATH=<span class="variable">$PATH</span><span class="symbol">:/usr/local/cuda-</span><span class="number">10.0</span>/bin</span><br><span class="line">export CUDA_HOME=<span class="variable">$CUDA_HOME</span><span class="symbol">:/usr/local/cuda-</span><span class="number">10.0</span></span><br></pre></td></tr></tbody></table></figure><p>保存 关闭，命令行输入：</p><figure class="highlight gams"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$source</span> ~/.bashrc</span></span><br></pre></td></tr></tbody></table></figure><h4 id="4-终端输入"><a href="#4-终端输入" class="headerlink" title="4.终端输入"></a>4.终端输入</h4><figure class="highlight gams"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">$nvcc</span> --version</span></span><br></pre></td></tr></tbody></table></figure><p>会输出CUDA的版本信息</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20210117135412688.png" alt="安装成功截图"></p><h4 id="5-测试CUDA的samples"><a href="#5-测试CUDA的samples" class="headerlink" title="5.测试CUDA的samples"></a>5.测试CUDA的samples</h4><p>为什么需要安装cuda samples？一方面为了后面学习cuda使用，另一方面，可以检验cuda是否真的安装成功。如果cuda samples全部编译通过，没有一个Error信息（Warning忽略），那么就说明成功地安装了cuda。如果最后一行虽然显示PASS，但是编译过程中有ERROR，请自行网上搜索相关错误信息解决之后。</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 切换到cuda-samples所在目录</span><br><span class="line">cd /usr/local/cuda<span class="number">-10.0</span>/samples 或者 cd ~/NVIDIA_CUDA<span class="number">-10.0</span>_Samples </span><br><span class="line"># 没有make，先安装命令 sudo apt-<span class="built_in">get</span> install cmake，-j是最大限度的使用cpu编译，加快编译的速度</span><br><span class="line">make –j</span><br><span class="line"># 编译完毕，切换<span class="built_in">release</span>目录（/usr/local/cuda<span class="number">-8.0</span>/samples/bin/x86_64/linux/<span class="built_in">release</span>完整目录）</span><br><span class="line">cd ./bin/x86_64/linux/<span class="built_in">release</span></span><br><span class="line"> </span><br><span class="line"># 检验是否成功，运行实例</span><br><span class="line">./deviceQuery </span><br><span class="line"> </span><br><span class="line"># 可以认真看看自行结果，它显示了你的NVIDIA显卡的相关信息，最后能看到Result = PASS就算成功。</span><br></pre></td></tr></tbody></table></figure><p>注意:最终能看到Result=PASS就成功了！！！</p><p>如下图：</p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/image-20210117142854433.png" alt="测试结果"></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./deviceQuery</span> <span class="string">Starting...</span></span><br><span class="line"></span><br><span class="line"> <span class="string">CUDA</span> <span class="string">Device</span> <span class="string">Query</span> <span class="string">(Runtime</span> <span class="string">API)</span> <span class="string">version</span> <span class="string">(CUDART</span> <span class="string">static</span> <span class="string">linking)</span></span><br><span class="line"></span><br><span class="line"><span class="string">Detected</span> <span class="number">2</span> <span class="string">CUDA</span> <span class="string">Capable</span> <span class="string">device(s)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Device 0:</span> <span class="string">"GeForce RTX 2080 Ti"</span></span><br><span class="line">  <span class="string">CUDA</span> <span class="string">Driver</span> <span class="string">Version</span> <span class="string">/</span> <span class="string">Runtime</span> <span class="string">Version</span>          <span class="number">11.0</span> <span class="string">/</span> <span class="number">10.0</span></span><br><span class="line">  <span class="attr">CUDA Capability Major/Minor version number:</span>    <span class="number">7.5</span></span><br><span class="line">  <span class="attr">Total amount of global memory:</span>                 <span class="number">11019</span> <span class="string">MBytes</span> <span class="string">(11554717696</span> <span class="string">bytes)</span></span><br><span class="line">  <span class="string">(68)</span> <span class="string">Multiprocessors,</span> <span class="string">(</span> <span class="number">64</span><span class="string">)</span> <span class="attr">CUDA Cores/MP:</span>     <span class="number">4352</span> <span class="string">CUDA</span> <span class="string">Cores</span></span><br><span class="line">  <span class="attr">GPU Max Clock rate:</span>                            <span class="number">1545</span> <span class="string">MHz</span> <span class="string">(1.54</span> <span class="string">GHz)</span></span><br><span class="line">  <span class="attr">Memory Clock rate:</span>                             <span class="number">7000</span> <span class="string">Mhz</span></span><br><span class="line">  <span class="attr">Memory Bus Width:</span>                              <span class="number">352</span><span class="string">-bit</span></span><br><span class="line">  <span class="attr">L2 Cache Size:</span>                                 <span class="number">5767168</span> <span class="string">bytes</span></span><br><span class="line">  <span class="string">Maximum</span> <span class="string">Texture</span> <span class="string">Dimension</span> <span class="string">Size</span> <span class="string">(x,y,z)</span>         <span class="string">1D=(131072),</span> <span class="string">2D=(131072,</span> <span class="number">65536</span><span class="string">),</span> <span class="string">3D=(16384,</span> <span class="number">16384</span><span class="string">,</span> <span class="number">16384</span><span class="string">)</span></span><br><span class="line">  <span class="string">Maximum</span> <span class="string">Layered</span> <span class="string">1D</span> <span class="string">Texture</span> <span class="string">Size,</span> <span class="string">(num)</span> <span class="string">layers</span>  <span class="string">1D=(32768),</span> <span class="number">2048</span> <span class="string">layers</span></span><br><span class="line">  <span class="string">Maximum</span> <span class="string">Layered</span> <span class="string">2D</span> <span class="string">Texture</span> <span class="string">Size,</span> <span class="string">(num)</span> <span class="string">layers</span>  <span class="string">2D=(32768,</span> <span class="number">32768</span><span class="string">),</span> <span class="number">2048</span> <span class="string">layers</span></span><br><span class="line">  <span class="attr">Total amount of constant memory:</span>               <span class="number">65536</span> <span class="string">bytes</span></span><br><span class="line">  <span class="attr">Total amount of shared memory per block:</span>       <span class="number">49152</span> <span class="string">bytes</span></span><br><span class="line">  <span class="attr">Total number of registers available per block:</span> <span class="number">65536</span></span><br><span class="line">  <span class="attr">Warp size:</span>                                     <span class="number">32</span></span><br><span class="line">  <span class="attr">Maximum number of threads per multiprocessor:</span>  <span class="number">1024</span></span><br><span class="line">  <span class="attr">Maximum number of threads per block:</span>           <span class="number">1024</span></span><br><span class="line">  <span class="string">Max</span> <span class="string">dimension</span> <span class="string">size</span> <span class="string">of</span> <span class="string">a</span> <span class="string">thread</span> <span class="string">block</span> <span class="string">(x,y,z):</span> <span class="string">(1024,</span> <span class="number">1024</span><span class="string">,</span> <span class="number">64</span><span class="string">)</span></span><br><span class="line">  <span class="string">Max</span> <span class="string">dimension</span> <span class="string">size</span> <span class="string">of</span> <span class="string">a</span> <span class="string">grid</span> <span class="string">size</span>    <span class="string">(x,y,z):</span> <span class="string">(2147483647,</span> <span class="number">65535</span><span class="string">,</span> <span class="number">65535</span><span class="string">)</span></span><br><span class="line">  <span class="attr">Maximum memory pitch:</span>                          <span class="number">2147483647</span> <span class="string">bytes</span></span><br><span class="line">  <span class="attr">Texture alignment:</span>                             <span class="number">512</span> <span class="string">bytes</span></span><br><span class="line">  <span class="attr">Concurrent copy and kernel execution:</span>          <span class="literal">Yes</span> <span class="string">with</span> <span class="number">3</span> <span class="string">copy</span> <span class="string">engine(s)</span></span><br><span class="line">  <span class="attr">Run time limit on kernels:</span>                     <span class="literal">No</span></span><br><span class="line">  <span class="attr">Integrated GPU sharing Host Memory:</span>            <span class="literal">No</span></span><br><span class="line">  <span class="attr">Support host page-locked memory mapping:</span>       <span class="literal">Yes</span></span><br><span class="line">  <span class="attr">Alignment requirement for Surfaces:</span>            <span class="literal">Yes</span></span><br><span class="line">  <span class="attr">Device has ECC support:</span>                        <span class="string">Disabled</span></span><br><span class="line">  <span class="string">Device</span> <span class="string">supports</span> <span class="string">Unified</span> <span class="string">Addressing</span> <span class="string">(UVA):</span>      <span class="literal">Yes</span></span><br><span class="line">  <span class="attr">Device supports Compute Preemption:</span>            <span class="literal">Yes</span></span><br><span class="line">  <span class="attr">Supports Cooperative Kernel Launch:</span>            <span class="literal">Yes</span></span><br><span class="line">  <span class="attr">Supports MultiDevice Co-op Kernel Launch:</span>      <span class="literal">Yes</span></span><br><span class="line">  <span class="attr">Device PCI Domain ID / Bus ID / location ID:</span>   <span class="number">0</span> <span class="string">/</span> <span class="number">26</span> <span class="string">/</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">Compute Mode:</span></span><br><span class="line">     <span class="string">&lt;</span> <span class="string">Default</span> <span class="string">(multiple</span> <span class="string">host</span> <span class="string">threads</span> <span class="string">can</span> <span class="string">use</span> <span class="string">::cudaSetDevice()</span> <span class="string">with</span> <span class="string">device</span> <span class="string">simultaneously)</span> <span class="string">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Device 1:</span> <span class="string">"GeForce RTX 2080 Ti"</span></span><br><span class="line">  <span class="string">CUDA</span> <span class="string">Driver</span> <span class="string">Version</span> <span class="string">/</span> <span class="string">Runtime</span> <span class="string">Version</span>          <span class="number">11.0</span> <span class="string">/</span> <span class="number">10.0</span></span><br><span class="line">  <span class="attr">CUDA Capability Major/Minor version number:</span>    <span class="number">7.5</span></span><br><span class="line">  <span class="attr">Total amount of global memory:</span>                 <span class="number">11016</span> <span class="string">MBytes</span> <span class="string">(11551440896</span> <span class="string">bytes)</span></span><br><span class="line">  <span class="string">(68)</span> <span class="string">Multiprocessors,</span> <span class="string">(</span> <span class="number">64</span><span class="string">)</span> <span class="attr">CUDA Cores/MP:</span>     <span class="number">4352</span> <span class="string">CUDA</span> <span class="string">Cores</span></span><br><span class="line">  <span class="attr">GPU Max Clock rate:</span>                            <span class="number">1545</span> <span class="string">MHz</span> <span class="string">(1.54</span> <span class="string">GHz)</span></span><br><span class="line">  <span class="attr">Memory Clock rate:</span>                             <span class="number">7000</span> <span class="string">Mhz</span></span><br><span class="line">  <span class="attr">Memory Bus Width:</span>                              <span class="number">352</span><span class="string">-bit</span></span><br><span class="line">  <span class="attr">L2 Cache Size:</span>                                 <span class="number">5767168</span> <span class="string">bytes</span></span><br><span class="line">  <span class="string">Maximum</span> <span class="string">Texture</span> <span class="string">Dimension</span> <span class="string">Size</span> <span class="string">(x,y,z)</span>         <span class="string">1D=(131072),</span> <span class="string">2D=(131072,</span> <span class="number">65536</span><span class="string">),</span> <span class="string">3D=(16384,</span> <span class="number">16384</span><span class="string">,</span> <span class="number">16384</span><span class="string">)</span></span><br><span class="line">  <span class="string">Maximum</span> <span class="string">Layered</span> <span class="string">1D</span> <span class="string">Texture</span> <span class="string">Size,</span> <span class="string">(num)</span> <span class="string">layers</span>  <span class="string">1D=(32768),</span> <span class="number">2048</span> <span class="string">layers</span></span><br><span class="line">  <span class="string">Maximum</span> <span class="string">Layered</span> <span class="string">2D</span> <span class="string">Texture</span> <span class="string">Size,</span> <span class="string">(num)</span> <span class="string">layers</span>  <span class="string">2D=(32768,</span> <span class="number">32768</span><span class="string">),</span> <span class="number">2048</span> <span class="string">layers</span></span><br><span class="line">  <span class="attr">Total amount of constant memory:</span>               <span class="number">65536</span> <span class="string">bytes</span></span><br><span class="line">  <span class="attr">Total amount of shared memory per block:</span>       <span class="number">49152</span> <span class="string">bytes</span></span><br><span class="line">  <span class="attr">Total number of registers available per block:</span> <span class="number">65536</span></span><br><span class="line">  <span class="attr">Warp size:</span>                                     <span class="number">32</span></span><br><span class="line">  <span class="attr">Maximum number of threads per multiprocessor:</span>  <span class="number">1024</span></span><br><span class="line">  <span class="attr">Maximum number of threads per block:</span>           <span class="number">1024</span></span><br><span class="line">  <span class="string">Max</span> <span class="string">dimension</span> <span class="string">size</span> <span class="string">of</span> <span class="string">a</span> <span class="string">thread</span> <span class="string">block</span> <span class="string">(x,y,z):</span> <span class="string">(1024,</span> <span class="number">1024</span><span class="string">,</span> <span class="number">64</span><span class="string">)</span></span><br><span class="line">  <span class="string">Max</span> <span class="string">dimension</span> <span class="string">size</span> <span class="string">of</span> <span class="string">a</span> <span class="string">grid</span> <span class="string">size</span>    <span class="string">(x,y,z):</span> <span class="string">(2147483647,</span> <span class="number">65535</span><span class="string">,</span> <span class="number">65535</span><span class="string">)</span></span><br><span class="line">  <span class="attr">Maximum memory pitch:</span>                          <span class="number">2147483647</span> <span class="string">bytes</span></span><br><span class="line">  <span class="attr">Texture alignment:</span>                             <span class="number">512</span> <span class="string">bytes</span></span><br><span class="line">  <span class="attr">Concurrent copy and kernel execution:</span>          <span class="literal">Yes</span> <span class="string">with</span> <span class="number">3</span> <span class="string">copy</span> <span class="string">engine(s)</span></span><br><span class="line">  <span class="attr">Run time limit on kernels:</span>                     <span class="literal">Yes</span></span><br><span class="line">  <span class="attr">Integrated GPU sharing Host Memory:</span>            <span class="literal">No</span></span><br><span class="line">  <span class="attr">Support host page-locked memory mapping:</span>       <span class="literal">Yes</span></span><br><span class="line">  <span class="attr">Alignment requirement for Surfaces:</span>            <span class="literal">Yes</span></span><br><span class="line">  <span class="attr">Device has ECC support:</span>                        <span class="string">Disabled</span></span><br><span class="line">  <span class="string">Device</span> <span class="string">supports</span> <span class="string">Unified</span> <span class="string">Addressing</span> <span class="string">(UVA):</span>      <span class="literal">Yes</span></span><br><span class="line">  <span class="attr">Device supports Compute Preemption:</span>            <span class="literal">Yes</span></span><br><span class="line">  <span class="attr">Supports Cooperative Kernel Launch:</span>            <span class="literal">Yes</span></span><br><span class="line">  <span class="attr">Supports MultiDevice Co-op Kernel Launch:</span>      <span class="literal">Yes</span></span><br><span class="line">  <span class="attr">Device PCI Domain ID / Bus ID / location ID:</span>   <span class="number">0</span> <span class="string">/</span> <span class="number">104</span> <span class="string">/</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">Compute Mode:</span></span><br><span class="line">     <span class="string">&lt;</span> <span class="string">Default</span> <span class="string">(multiple</span> <span class="string">host</span> <span class="string">threads</span> <span class="string">can</span> <span class="string">use</span> <span class="string">::cudaSetDevice()</span> <span class="string">with</span> <span class="string">device</span> <span class="string">simultaneously)</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">&gt;</span> <span class="string">Peer</span> <span class="string">access</span> <span class="string">from</span> <span class="string">GeForce</span> <span class="string">RTX</span> <span class="number">2080</span> <span class="string">Ti</span> <span class="string">(GPU0)</span> <span class="string">-&gt;</span> <span class="string">GeForce</span> <span class="string">RTX</span> <span class="number">2080</span> <span class="string">Ti</span> <span class="string">(GPU1)</span> <span class="string">:</span> <span class="literal">No</span></span><br><span class="line"><span class="string">&gt;</span> <span class="string">Peer</span> <span class="string">access</span> <span class="string">from</span> <span class="string">GeForce</span> <span class="string">RTX</span> <span class="number">2080</span> <span class="string">Ti</span> <span class="string">(GPU1)</span> <span class="string">-&gt;</span> <span class="string">GeForce</span> <span class="string">RTX</span> <span class="number">2080</span> <span class="string">Ti</span> <span class="string">(GPU0)</span> <span class="string">:</span> <span class="literal">No</span></span><br><span class="line"></span><br><span class="line"><span class="string">deviceQuery,</span> <span class="string">CUDA</span> <span class="string">Driver</span> <span class="string">=</span> <span class="string">CUDART,</span> <span class="string">CUDA</span> <span class="string">Driver</span> <span class="string">Version</span> <span class="string">=</span> <span class="number">11.0</span><span class="string">,</span> <span class="string">CUDA</span> <span class="string">Runtime</span> <span class="string">Version</span> <span class="string">=</span> <span class="number">10.0</span><span class="string">,</span> <span class="string">NumDevs</span> <span class="string">=</span> <span class="number">2</span></span><br><span class="line"><span class="string">Result</span> <span class="string">=</span> <span class="string">PASS</span></span><br></pre></td></tr></tbody></table></figure><h2 id="三、安装cudnn"><a href="#三、安装cudnn" class="headerlink" title="三、安装cudnn"></a>三、安装cudnn</h2><p>查阅cuda10.0对应的cudnn版本</p><p>这里给出下载地址：</p><p><a href="https://pan.baidu.com/s/1ns8KBQFFfO4yJTt_XnEreA" target="_blank" rel="noopener">https://pan.baidu.com/s/1ns8KBQFFfO4yJTt_XnEreA</a></p><p>cuda10.0的下载地址：<a href="https://pan.baidu.com/s/1zhd2RT8g827H0vVjR3OnSg" target="_blank" rel="noopener">https://pan.baidu.com/s/1zhd2RT8g827H0vVjR3OnSg</a></p><p>参考博客</p><p><a href="https://blog.csdn.net/bmwlwg/article/details/100795413！" target="_blank" rel="noopener">https://blog.csdn.net/bmwlwg/article/details/100795413！</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++-example</title>
      <link href="/posts/9071.html"/>
      <url>/posts/9071.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C-study</title>
      <link href="/posts/241f.html"/>
      <url>/posts/241f.html</url>
      
        <content type="html"><![CDATA[<p>学习C++过程中的记录</p><a id="more"></a><h1 id="1、python"><a href="#1、python" class="headerlink" title="1、python"></a>1、python</h1><p>123</p><h1 id="2、C"><a href="#2、C" class="headerlink" title="2、C++"></a>2、C++</h1><p>456</p><h1 id="3、http"><a href="#3、http" class="headerlink" title="3、http"></a>3、http</h1><p>789</p><h1 id="4、数据库"><a href="#4、数据库" class="headerlink" title="4、数据库"></a>4、数据库</h1><p>123</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完美解决Tensorflow不支持AVX2指令集问题|指令集加速</title>
      <link href="/posts/6e6c.html"/>
      <url>/posts/6e6c.html</url>
      
        <content type="html"><![CDATA[<p> 在pycharm中安装tensorflow后</p><a id="more"></a>    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200712190018795.png)<p>运行如下测试代码：</p><!--more--><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">x = tf.Variable(<span class="number">3</span>, name=<span class="string">"x"</span>)</span><br><span class="line">y = tf.Variable(<span class="number">4</span>, name=<span class="string">"y"</span>)</span><br><span class="line">f = x*x*y + y + <span class="number">2</span></span><br><span class="line">print(f)</span><br></pre></td></tr></tbody></table></figure><p>发现会报一行错误<img src="https://img-blog.csdnimg.cn/20200712190733701.png" alt="在这里插入图片描述"><br><code>Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2</code>大概意思是安装的tensorflow版本不支持cpu的AVX2编译<br>可能是因为安装时使用的pip install tensorflow ，这样默认会下载X86_64的SIMD版本。<br>查找解决办法后，有以下两种办法：</p><h4 id="1-忽略屏蔽这个警告"><a href="#1-忽略屏蔽这个警告" class="headerlink" title="1.忽略屏蔽这个警告"></a>1.忽略屏蔽这个警告</h4><p>在代码最前面添加如下两行代码</p><pre><code>import osos.environ["TF_CPP_MIN_LOG_LEVEL"]='2' # 只显示 warning 和 Error</code></pre><h4 id="2-彻底解决，换成支持cpu用AVX2编译的TensorFlow版本。"><a href="#2-彻底解决，换成支持cpu用AVX2编译的TensorFlow版本。" class="headerlink" title="2.彻底解决，换成支持cpu用AVX2编译的TensorFlow版本。"></a>2.彻底解决，换成支持cpu用AVX2编译的TensorFlow版本。</h4><p>首先卸载原来安装的tensorflow版本<br><code>pip uninstall tensorflow</code><br>在这里下载对应版本的tensorflow：<a href="https://github.com/fo40225/tensorflow-windows-wheel" target="_blank" rel="noopener">https://github.com/fo40225/tensorflow-windows-wheel</a>，比如我需要的是CPU+AVX2+Python3.6，那么我就在下面的列表中选择这个：<br><img src="https://img-blog.csdnimg.cn/20200712220316853.png" alt="在这里插入图片描述"></p><table><thead><tr><th>Path</th><th>Compiler</th><th>CUDA/cuDNN</th><th>SIMD</th><th>Notes</th></tr></thead><tbody><tr><td>2.2.0\py37\CPU+GPU\cuda102cudnn76sse2</td><td>VS2019 16.5</td><td>10.2.89_441.22/7.6.5.32</td><td>x86_64</td><td>Python 3.7/Compute 3.0</td></tr><tr><td>2.2.0\py37\CPU+GPU\cuda102cudnn76avx2</td><td>VS2019 16.5</td><td>10.2.89_441.22/7.6.5.32</td><td>AVX2</td><td>Python 3.7/Compute 3.0,3.5,5.0,5.2,6.1,7.0,7.5</td></tr><tr><td>2.1.0\py37\CPU+GPU\cuda102cudnn76sse2</td><td>VS2019 16.4</td><td>10.2.89_441.22/7.6.5.32</td><td>x86_64</td><td>Python 3.7/Compute 3.0</td></tr><tr><td>2.1.0\py37\CPU+GPU\cuda102cudnn76avx2</td><td>VS2019 16.4</td><td>10.2.89_441.22/7.6.5.32</td><td>AVX2</td><td>Python 3.7/Compute 3.0,3.5,5.0,5.2,6.1,7.0,7.5</td></tr><tr><td>2.0.0\py37\CPU\sse2</td><td>VS2019 16.3</td><td>No</td><td>x86_64</td><td>Python 3.7</td></tr><tr><td>2.0.0\py37\CPU\avx2</td><td>VS2019 16.3</td><td>No</td><td>AVX2</td><td>Python 3.7</td></tr><tr><td>2.0.0\py37\GPU\cuda101cudnn76sse2</td><td>VS2019 16.3</td><td>10.1.243_426.00/7.6.4.38</td><td>x86_64</td><td>Python 3.7/Compute 3.0</td></tr><tr><td>2.0.0\py37\GPU\cuda101cudnn76avx2</td><td>VS2019 16.3</td><td>10.1.243_426.00/7.6.4.38</td><td>AVX2</td><td>Python 3.7/Compute 3.0,3.5,5.0,5.2,6.1,7.0,7.5</td></tr><tr><td>1.15.0\py37\CPU+GPU\cuda101cudnn76sse2</td><td>VS2019 16.3</td><td>10.1.243_426.00/7.6.4.38</td><td>x86_64</td><td>Python 3.7/Compute 3.0</td></tr><tr><td>1.15.0\py37\CPU+GPU\cuda101cudnn76avx2</td><td>VS2019 16.3</td><td>10.1.243_426.00/7.6.4.38</td><td>AVX2</td><td>Python 3.7/Compute 3.0,3.5,5.0,5.2,6.1,7.0,7.5</td></tr><tr><td>1.14.0\py37\CPU\sse2</td><td>VS2019 16.1</td><td>No</td><td>x86_64</td><td>Python 3.7</td></tr><tr><td>1.14.0\py37\CPU\avx2</td><td>VS2019 16.1</td><td>No</td><td>AVX2</td><td>Python 3.7</td></tr><tr><td>1.14.0\py37\GPU\cuda101cudnn76sse2</td><td>VS2019 16.1</td><td>10.1.168_425.25/7.6.0.64</td><td>x86_64</td><td>Python 3.7/Compute 3.0</td></tr><tr><td>1.14.0\py37\GPU\cuda101cudnn76avx2</td><td>VS2019 16.1</td><td>10.1.168_425.25/7.6.0.64</td><td>AVX2</td><td>Python 3.7/Compute 3.0,3.5,5.0,5.2,6.1,7.0,7.5</td></tr><tr><td>1.13.1\py37\CPU\sse2</td><td>VS2017 15.9</td><td>No</td><td>x86_64</td><td>Python 3.7</td></tr><tr><td>1.13.1\py37\CPU\avx2</td><td>VS2017 15.9</td><td>No</td><td>AVX2</td><td>Python 3.7</td></tr><tr><td>1.13.1\py37\GPU\cuda101cudnn75sse2</td><td>VS2017 15.9</td><td>10.1.105_418.96/7.5.0.56</td><td>x86_64</td><td>Python 3.7/Compute 3.0</td></tr><tr><td>1.13.1\py37\GPU\cuda101cudnn75avx2</td><td>VS2017 15.9</td><td>10.1.105_418.96/7.5.0.56</td><td>AVX2</td><td>Python 3.7/Compute 3.0,3.5,5.0,5.2,6.1,7.0,7.5</td></tr><tr><td>1.12.0\py36\CPU\sse2</td><td>VS2017 15.8</td><td>No</td><td>x86_64</td><td>Python 3.6</td></tr><tr><td>1.12.0\py36\CPU\avx2</td><td>VS2017 15.8</td><td>No</td><td>AVX2</td><td>Python 3.6</td></tr><tr><td>1.12.0\py36\GPU\cuda100cudnn73sse2</td><td>VS2017 15.8</td><td>10.0.130_411.31/7.3.1.20</td><td>x86_64</td><td>Python 3.6/Compute 3.0</td></tr><tr><td>1.12.0\py36\GPU\cuda100cudnn73avx2</td><td>VS2017 15.8</td><td>10.0.130_411.31/7.3.1.20</td><td>AVX2</td><td>Python 3.6/Compute 3.0,3.5,5.0,5.2,6.1,7.0,7.5</td></tr><tr><td>1.12.0\py37\CPU\sse2</td><td>VS2017 15.8</td><td>No</td><td>x86_64</td><td>Python 3.7</td></tr><tr><td>1.12.0\py37\CPU\avx2</td><td>VS2017 15.8</td><td>No</td><td>AVX2</td><td>Python 3.7</td></tr><tr><td>1.12.0\py37\GPU\cuda100cudnn73sse2</td><td>VS2017 15.8</td><td>10.0.130_411.31/7.3.1.20</td><td>x86_64</td><td>Python 3.7/Compute 3.0</td></tr><tr><td>1.12.0\py37\GPU\cuda100cudnn73avx2</td><td>VS2017 15.8</td><td>10.0.130_411.31/7.3.1.20</td><td>AVX2</td><td>Python 3.7/Compute 3.0,3.5,5.0,5.2,6.1,7.0,7.5</td></tr><tr><td>1.11.0\py36\CPU\sse2</td><td>VS2017 15.8</td><td>No</td><td>x86_64</td><td>Python 3.6</td></tr><tr><td>1.11.0\py36\CPU\avx2</td><td>VS2017 15.8</td><td>No</td><td>AVX2</td><td>Python 3.6</td></tr><tr><td>1.11.0\py36\GPU\cuda100cudnn73sse2</td><td>VS2017 15.8</td><td>10.0.130_411.31/7.3.0.29</td><td>x86_64</td><td>Python 3.6/Compute 3.0</td></tr><tr><td>1.11.0\py36\GPU\cuda100cudnn73avx2</td><td>VS2017 15.8</td><td>10.0.130_411.31/7.3.0.29</td><td>AVX2</td><td>Python 3.6/Compute 3.0,3.5,5.0,5.2,6.1,7.0,7.5</td></tr><tr><td>1.11.0\py37\CPU\sse2</td><td>VS2017 15.8</td><td>No</td><td>x86_64</td><td>Python 3.7</td></tr><tr><td>1.11.0\py37\CPU\avx2</td><td>VS2017 15.8</td><td>No</td><td>AVX2</td><td>Python 3.7</td></tr><tr><td>1.11.0\py37\GPU\cuda100cudnn73sse2</td><td>VS2017 15.8</td><td>10.0.130_411.31/7.3.0.29</td><td>x86_64</td><td>Python 3.7/Compute 3.0</td></tr><tr><td>1.11.0\py37\GPU\cuda100cudnn73avx2</td><td>VS2017 15.8</td><td>10.0.130_411.31/7.3.0.29</td><td>AVX2</td><td>Python 3.7/Compute 3.0,3.5,5.0,5.2,6.1,7.0,7.5</td></tr><tr><td>1.10.0\py36\CPU\sse2</td><td>VS2017 15.8</td><td>No</td><td>x86_64</td><td>Python 3.6</td></tr><tr><td>1.10.0\py36\CPU\avx2</td><td>VS2017 15.8</td><td>No</td><td>AVX2</td><td>Python 3.6</td></tr><tr><td>1.10.0\py36\GPU\cuda92cudnn72sse2</td><td>VS2017 15.8</td><td>9.2.148.1/7.2.1.38</td><td>x86_64</td><td>Python 3.6/Compute 3.0</td></tr><tr><td>1.10.0\py36\GPU\cuda92cudnn72avx2</td><td>VS2017 15.8</td><td>9.2.148.1/7.2.1.38</td><td>AVX2</td><td>Python 3.6/Compute 3.0,3.5,5.0,5.2,6.1,7.0</td></tr><tr><td>1.10.0\py27\CPU\sse2</td><td>VS2017 15.8</td><td>No</td><td>x86_64</td><td>Python 2.7</td></tr><tr><td>1.10.0\py27\CPU\avx2</td><td>VS2017 15.8</td><td>No</td><td>AVX2</td><td>Python 2.7</td></tr><tr><td>1.10.0\py27\GPU\cuda92cudnn72sse2</td><td>VS2017 15.8</td><td>9.2.148.1/7.2.1.38</td><td>x86_64</td><td>Python 2.7/Compute 3.0</td></tr><tr><td>1.10.0\py27\GPU\cuda92cudnn72avx2</td><td>VS2017 15.8</td><td>9.2.148.1/7.2.1.38</td><td>AVX2</td><td>Python 2.7/Compute 3.0,3.5,5.0,5.2,6.1,7.0</td></tr><tr><td>1.9.0\py36\CPU\sse2</td><td>VS2017 15.7</td><td>No</td><td>x86_64</td><td>Python 3.6</td></tr><tr><td>1.9.0\py36\CPU\avx2</td><td>VS2017 15.7</td><td>No</td><td>AVX2</td><td>Python 3.6</td></tr><tr><td>1.9.0\py36\GPU\cuda92cudnn71sse2</td><td>VS2017 15.7</td><td>9.2.148/7.1.4</td><td>x86_64</td><td>Python 3.6/Compute 3.0</td></tr><tr><td>1.9.0\py36\GPU\cuda92cudnn71avx2</td><td>VS2017 15.7</td><td>9.2.148/7.1.4</td><td>AVX2</td><td>Python 3.6/Compute 3.0,3.5,5.0,5.2,6.1,7.0</td></tr><tr><td>1.9.0\py27\CPU\sse2</td><td>VS2017 15.7</td><td>No</td><td>x86_64</td><td>Python 2.7</td></tr><tr><td>1.9.0\py27\CPU\avx2</td><td>VS2017 15.7</td><td>No</td><td>AVX2</td><td>Python 2.7</td></tr><tr><td>1.9.0\py27\GPU\cuda92cudnn71sse2</td><td>VS2017 15.7</td><td>9.2.148/7.1.4</td><td>x86_64</td><td>Python 2.7/Compute 3.0</td></tr><tr><td>1.9.0\py27\GPU\cuda92cudnn71avx2</td><td>VS2017 15.7</td><td>9.2.148/7.1.4</td><td>AVX2</td><td>Python 2.7/Compute 3.0,3.5,5.0,5.2,6.1,7.0</td></tr><tr><td>1.8.0\py36\CPU\sse2</td><td>VS2017 15.4</td><td>No</td><td>x86_64</td><td>Python 3.6</td></tr><tr><td>1.8.0\py36\CPU\avx2</td><td>VS2017 15.4</td><td>No</td><td>AVX2</td><td>Python 3.6</td></tr><tr><td>1.8.0\py36\GPU\cuda91cudnn71sse2</td><td>VS2017 15.4</td><td>9.1.85.3/7.1.3</td><td>x86_64</td><td>Python 3.6/Compute 3.0</td></tr><tr><td>1.8.0\py36\GPU\cuda91cudnn71avx2</td><td>VS2017 15.4</td><td>9.1.85.3/7.1.3</td><td>AVX2</td><td>Python 3.6/Compute 3.0,3.5,5.0,5.2,6.1,7.0</td></tr><tr><td>1.8.0\py27\CPU\sse2</td><td>VS2017 15.4</td><td>No</td><td>x86_64</td><td>Python 2.7</td></tr><tr><td>1.8.0\py27\CPU\avx2</td><td>VS2017 15.4</td><td>No</td><td>AVX2</td><td>Python 2.7</td></tr><tr><td>1.8.0\py27\GPU\cuda91cudnn71sse2</td><td>VS2017 15.4</td><td>9.1.85.3/7.1.3</td><td>x86_64</td><td>Python 2.7/Compute 3.0</td></tr><tr><td>1.8.0\py27\GPU\cuda91cudnn71avx2</td><td>VS2017 15.4</td><td>9.1.85.3/7.1.3</td><td>AVX2</td><td>Python 2.7/Compute 3.0,3.5,5.0,5.2,6.1,7.0</td></tr><tr><td>1.7.0\py36\CPU\sse2</td><td>VS2017 15.4</td><td>No</td><td>x86_64</td><td>Python 3.6</td></tr><tr><td>1.7.0\py36\CPU\avx2</td><td>VS2017 15.4</td><td>No</td><td>AVX2</td><td>Python 3.6</td></tr><tr><td>1.7.0\py36\GPU\cuda91cudnn71sse2</td><td>VS2017 15.4</td><td>9.1.85.3/7.1.2</td><td>x86_64</td><td>Python 3.6/Compute 3.0</td></tr><tr><td>1.7.0\py36\GPU\cuda91cudnn71avx2</td><td>VS2017 15.4</td><td>9.1.85.3/7.1.2</td><td>AVX2</td><td>Python 3.6/Compute 3.0,3.5,5.0,5.2,6.1,7.0</td></tr><tr><td>1.7.0\py27\CPU\sse2</td><td>VS2017 15.4</td><td>No</td><td>x86_64</td><td>Python 2.7</td></tr><tr><td>1.7.0\py27\CPU\avx2</td><td>VS2017 15.4</td><td>No</td><td>AVX2</td><td>Python 2.7</td></tr><tr><td>1.7.0\py27\GPU\cuda91cudnn71sse2</td><td>VS2017 15.4</td><td>9.1.85.3/7.1.2</td><td>x86_64</td><td>Python 2.7/Compute 3.0</td></tr><tr><td>1.7.0\py27\GPU\cuda91cudnn71avx2</td><td>VS2017 15.4</td><td>9.1.85.3/7.1.2</td><td>AVX2</td><td>Python 2.7/Compute 3.0,3.5,5.0,5.2,6.1,7.0</td></tr><tr><td>1.6.0\py36\CPU\sse2</td><td>VS2017 15.4</td><td>No</td><td>x86_64</td><td>Python 3.6</td></tr><tr><td>1.6.0\py36\CPU\avx2</td><td>VS2017 15.4</td><td>No</td><td>AVX2</td><td>Python 3.6</td></tr><tr><td>1.6.0\py36\GPU\cuda91cudnn71sse2</td><td>VS2017 15.4</td><td>9.1.85.3/7.1.1</td><td>x86_64</td><td>Python 3.6/Compute 3.0</td></tr><tr><td>1.6.0\py36\GPU\cuda91cudnn71avx2</td><td>VS2017 15.4</td><td>9.1.85.3/7.1.1</td><td>AVX2</td><td>Python 3.6/Compute 3.0,3.5,5.0,5.2,6.1,7.0</td></tr><tr><td>1.6.0\py27\CPU\sse2</td><td>VS2017 15.4</td><td>No</td><td>x86_64</td><td>Python 2.7</td></tr><tr><td>1.6.0\py27\CPU\avx2</td><td>VS2017 15.4</td><td>No</td><td>AVX2</td><td>Python 2.7</td></tr><tr><td>1.6.0\py27\GPU\cuda91cudnn71sse2</td><td>VS2017 15.4</td><td>9.1.85.2/7.1.1</td><td>x86_64</td><td>Python 2.7/Compute 3.0</td></tr><tr><td>1.6.0\py27\GPU\cuda91cudnn71avx2</td><td>VS2017 15.4</td><td>9.1.85.2/7.1.1</td><td>AVX2</td><td>Python 2.7/Compute 3.0,3.5,5.0,5.2,6.1,7.0</td></tr><tr><td>1.5.0\py36\CPU\avx</td><td>VS2017 15.4</td><td>No</td><td>AVX</td><td>Python 3.6</td></tr><tr><td>1.5.0\py36\CPU\avx2</td><td>VS2017 15.4</td><td>No</td><td>AVX2</td><td>Python 3.6</td></tr><tr><td>1.5.0\py36\GPU\cuda91cudnn7avx2</td><td>VS2017 15.4</td><td>9.1.85/7.0.5</td><td>AVX2</td><td>Python 3.6/Compute 3.0,3.5,5.0,5.2,6.1,7.0</td></tr><tr><td>1.5.0\py27\CPU\sse2</td><td>VS2017 15.4</td><td>No</td><td>x86_64</td><td>Python 2.7</td></tr><tr><td>1.5.0\py27\CPU\avx</td><td>VS2017 15.4</td><td>No</td><td>AVX</td><td>Python 2.7</td></tr><tr><td>1.5.0\py27\CPU\avx2</td><td>VS2017 15.4</td><td>No</td><td>AVX2</td><td>Python 2.7</td></tr><tr><td>1.5.0\py27\GPU\cuda91cudnn7sse2</td><td>VS2017 15.4</td><td>9.1.85/7.0.5</td><td>x86_64</td><td>Python 2.7/Compute 3.0</td></tr><tr><td>1.5.0\py27\GPU\cuda91cudnn7avx2</td><td>VS2017 15.4</td><td>9.1.85/7.0.5</td><td>AVX2</td><td>Python 2.7/Compute 3.0,3.5,5.0,5.2,6.1,7.0</td></tr><tr><td>1.4.0\py36\CPU\avx</td><td>VS2017 15.4</td><td>No</td><td>AVX</td><td>Python 3.6</td></tr><tr><td>1.4.0\py36\CPU\avx2</td><td>VS2017 15.4</td><td>No</td><td>AVX2</td><td>Python 3.6</td></tr><tr><td>1.4.0\py36\GPU\cuda91cudnn7avx2</td><td>VS2017 15.4</td><td>9.1.85/7.0.5</td><td>AVX2</td><td>Python 3.6/Compute 3.0,3.5,5.0,5.2,6.1,7.0</td></tr><tr><td>1.3.0\py36\CPU\avx</td><td>VS2015 Update 3</td><td>No</td><td>AVX</td><td>Python 3.6</td></tr><tr><td>1.3.0\py36\CPU\avx2</td><td>VS2015 Update 3</td><td>No</td><td>AVX2</td><td>Python 3.6</td></tr><tr><td>1.3.0\py36\GPU\cuda8cudnn6avx2</td><td>VS2015 Update 3</td><td>8.0.61.2/6.0.21</td><td>AVX2</td><td>Python 3.6/Compute 3.0,3.5,5.0,5.2,6.1</td></tr><tr><td>1.2.1\py36\CPU\avx</td><td>VS2015 Update 3</td><td>No</td><td>AVX</td><td>Python 3.6</td></tr><tr><td>1.2.1\py36\CPU\avx2</td><td>VS2015 Update 3</td><td>No</td><td>AVX2</td><td>Python 3.6</td></tr><tr><td>1.2.1\py36\GPU\cuda8cudnn6avx2</td><td>VS2015 Update 3</td><td>8.0.61.2/6.0.21</td><td>AVX2</td><td>Python 3.6/Compute 3.0,3.5,5.0,5.2,6.1</td></tr><tr><td>1.1.0\py36\CPU\avx</td><td>VS2015 Update 3</td><td>No</td><td>AVX</td><td>Python 3.6</td></tr><tr><td>1.1.0\py36\CPU\avx2</td><td>VS2015 Update 3</td><td>No</td><td>AVX2</td><td>Python 3.6</td></tr><tr><td>1.1.0\py36\GPU\cuda8cudnn6avx2</td><td>VS2015 Update 3</td><td>8.0.61.2/6.0.21</td><td>AVX2</td><td>Python 3.6/Compute 3.0,3.5,5.0,5.2,6.1</td></tr><tr><td>1.0.0\py36\CPU\sse2</td><td>VS2015 Update 3</td><td>No</td><td>x86_64</td><td>Python 3.6</td></tr><tr><td>1.0.0\py36\CPU\avx</td><td>VS2015 Update 3</td><td>No</td><td>AVX</td><td>Python 3.6</td></tr><tr><td>1.0.0\py36\CPU\avx2</td><td>VS2015 Update 3</td><td>No</td><td>AVX2</td><td>Python 3.6</td></tr><tr><td>1.0.0\py36\GPU\cuda8cudnn51sse2</td><td>VS2015 Update 3</td><td>8.0.61.2/5.1.10</td><td>x86_64</td><td>Python 3.6/Compute 3.0</td></tr><tr><td>1.0.0\py36\GPU\cuda8cudnn51avx2</td><td>VS2015 Update 3</td><td>8.0.61.2/5.1.10</td><td>AVX2</td><td>Python 3.6/Compute 3.0,3.5,5.0,5.2,6.1</td></tr><tr><td>0.12.0\py35\CPU\avx</td><td>VS2015 Update 3</td><td>No</td><td>AVX</td><td>Python 3.5</td></tr><tr><td>0.12.0\py35\CPU\avx2</td><td>VS2015 Update 3</td><td>No</td><td>AVX2</td><td>Python 3.5</td></tr><tr><td>0.12.0\py35\GPU\cuda8cudnn51avx2</td><td>VS2015 Update 3</td><td>8.0.61.2/5.1.10</td><td>AVX2</td><td>Python 3.5/Compute 3.0,3.5,5.0,5.2,6.1</td></tr></tbody></table><p>找到对应的.whl文件<br><img src="https://img-blog.csdnimg.cn/20200712220439134.png" alt="在这里插入图片描述"><br>下载该文件，我用google浏览器下载一直显示无法访问<br><img src="https://img-blog.csdnimg.cn/20200712220536927.png" alt="在这里插入图片描述"><br>后来选用Edge浏览器打开就好啦，直接就下载成功了。<br>此处放上<strong>tensorflow-1.12.0-cp36-cp36m-win_amd64.whl</strong>的下载链接：<br>链接：<a href="https://pan.baidu.com/s/1CvKUtmM1zHyJyJk87eFEUA" target="_blank" rel="noopener">https://pan.baidu.com/s/1CvKUtmM1zHyJyJk87eFEUA</a><br>提取码：o85f<br>然后用activate 进入自己创建的虚拟环境<br><img src="https://img-blog.csdnimg.cn/20200712220832684.png" alt="在这里插入图片描述"><br>运行<code>pip install tensorflow-1.12.0-cp36-cp36m-win_amd64.whl</code>命令安装<br><img src="https://img-blog.csdnimg.cn/20200712221831560.png" alt="在这里插入图片描述"><br>最后用<code>conda list</code>命令看安装了那些包<br><img src="https://img-blog.csdnimg.cn/20200712221924711.png" alt="在这里插入图片描述"><br>然后再次运行代码，就不会报AVX2的错误啦<br><img src="https://img-blog.csdnimg.cn/20200712230627530.png" alt="在这里插入图片描述"></p><ul><li>参考链接：<a href="https://blog.csdn.net/beyond9305/article/details/95896135" target="_blank" rel="noopener">https://blog.csdn.net/beyond9305/article/details/95896135</a></li><li><a href="https://www.jb51.net/article/179405.htm" target="_blank" rel="noopener">https://www.jb51.net/article/179405.htm</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> tensorflow AVX2 pycharm 指令集加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Classification分类器|机器学习实战-基于Scikit-Learn和TensorFlow</title>
      <link href="/posts/f8eb.html"/>
      <url>/posts/f8eb.html</url>
      
        <content type="html"><![CDATA[<p><strong>Classification</strong></p><h2 id="监督学习任务（分类）"><a href="#监督学习任务（分类）" class="headerlink" title="监督学习任务（分类）"></a>监督学习任务（分类）</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To support both python 2 and python 3</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division, print_function, unicode_literals</span><br><span class="line"></span><br><span class="line"><span class="comment"># Common imports</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># to make this notebook's output stable across runs</span></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># To plot pretty figures</span></span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">'axes.labelsize'</span>] = <span class="number">14</span></span><br><span class="line">plt.rcParams[<span class="string">'xtick.labelsize'</span>] = <span class="number">12</span></span><br><span class="line">plt.rcParams[<span class="string">'ytick.labelsize'</span>] = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Where to save the figures</span></span><br><span class="line">PROJECT_ROOT_DIR = <span class="string">"."</span></span><br><span class="line">CHAPTER_ID = <span class="string">"classification"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_fig</span><span class="params">(fig_id, tight_layout=True)</span>:</span></span><br><span class="line">    path = os.path.join(PROJECT_ROOT_DIR, <span class="string">"images"</span>, CHAPTER_ID, fig_id + <span class="string">".png"</span>)</span><br><span class="line">    print(<span class="string">"Saving figure"</span>, fig_id)</span><br><span class="line">    <span class="keyword">if</span> tight_layout:</span><br><span class="line">        plt.tight_layout()</span><br><span class="line">    plt.savefig(path, format=<span class="string">'png'</span>, dpi=<span class="number">300</span>)</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><h1 id="MNIST"><a href="#MNIST" class="headerlink" title="MNIST"></a>MNIST</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_openml</span><br><span class="line">mnist = fetch_openml(<span class="string">'mnist_784'</span>)<span class="comment">#获得mnist数据集</span></span><br><span class="line">mnist</span><br></pre></td></tr></tbody></table></figure><pre><code>{'data': array([[0., 0., 0., ..., 0., 0., 0.],        [0., 0., 0., ..., 0., 0., 0.],        [0., 0., 0., ..., 0., 0., 0.],        ...,        [0., 0., 0., ..., 0., 0., 0.],        [0., 0., 0., ..., 0., 0., 0.],        [0., 0., 0., ..., 0., 0., 0.]]), 'target': array(['5', '0', '4', ..., '4', '5', '6'], dtype=object), 'frame': None, 'categories': {},</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X, y = mnist[<span class="string">"data"</span>], mnist[<span class="string">"target"</span>]<span class="comment">#共70000张图片，每张图片有784个特征，28x28像素，每个特征代表一个像素点的强度</span></span><br><span class="line">X.shape<span class="comment">#查看各个维度的维数</span></span><br></pre></td></tr></tbody></table></figure><pre><code>(70000, 784)</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y.shape</span><br></pre></td></tr></tbody></table></figure><pre><code>(70000,)</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">28</span>*<span class="number">28</span></span><br></pre></td></tr></tbody></table></figure><pre><code>784</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#先来看看数据集中的一个数字， 你只需要随手抓取一个实例的特征向量，将其重新形成一个28×28数组，然后使用Matplotlib的</span></span><br><span class="line"><span class="comment">#imshow（）函数将其显示出来：</span></span><br><span class="line">some_digit = X[<span class="number">36000</span>]</span><br><span class="line">some_digit_image = some_digit.reshape(<span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">plt.imshow(some_digit_image, cmap = matplotlib.cm.binary,</span><br><span class="line">           interpolation=<span class="string">"nearest"</span>)</span><br><span class="line">plt.axis(<span class="string">"off"</span>)</span><br><span class="line"></span><br><span class="line">save_fig(<span class="string">"some_digit_plot"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><pre><code>Saving figure some_digit_plot</code></pre><p><img src="https://img-blog.csdnimg.cn/2020071208521182.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_digit</span><span class="params">(data)</span>:</span></span><br><span class="line">    image = data.reshape(<span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">    plt.imshow(image, cmap = matplotlib.cm.binary,</span><br><span class="line">               interpolation=<span class="string">"nearest"</span>)</span><br><span class="line">    plt.axis(<span class="string">"off"</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># EXTRA</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_digits</span><span class="params">(instances, images_per_row=<span class="number">10</span>, **options)</span>:</span></span><br><span class="line">    size = <span class="number">28</span></span><br><span class="line">    images_per_row = min(len(instances), images_per_row)</span><br><span class="line">    images = [instance.reshape(size,size) <span class="keyword">for</span> instance <span class="keyword">in</span> instances]</span><br><span class="line">    n_rows = (len(instances) - <span class="number">1</span>) // images_per_row + <span class="number">1</span></span><br><span class="line">    row_images = []</span><br><span class="line">    n_empty = n_rows * images_per_row - len(instances)</span><br><span class="line">    images.append(np.zeros((size, size * n_empty)))</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(n_rows):</span><br><span class="line">        rimages = images[row * images_per_row : (row + <span class="number">1</span>) * images_per_row]</span><br><span class="line">        row_images.append(np.concatenate(rimages, axis=<span class="number">1</span>))</span><br><span class="line">    image = np.concatenate(row_images, axis=<span class="number">0</span>)</span><br><span class="line">    plt.imshow(image, cmap = matplotlib.cm.binary, **options)</span><br><span class="line">    plt.axis(<span class="string">"off"</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">9</span>,<span class="number">9</span>))</span><br><span class="line">example_images = np.r_[X[:<span class="number">12000</span>:<span class="number">600</span>], X[<span class="number">13000</span>:<span class="number">30600</span>:<span class="number">600</span>], X[<span class="number">30600</span>:<span class="number">60000</span>:<span class="number">590</span>]]</span><br><span class="line">plot_digits(example_images, images_per_row=<span class="number">10</span>)</span><br><span class="line">save_fig(<span class="string">"more_digits_plot"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><pre><code>Saving figure more_digits_plot</code></pre><p><img src="https://img-blog.csdnimg.cn/20200712090509325.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y[<span class="number">36000</span>]</span><br></pre></td></tr></tbody></table></figure><pre><code>'9'</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = X[:<span class="number">60000</span>], X[<span class="number">60000</span>:], y[:<span class="number">60000</span>], y[<span class="number">60000</span>:]<span class="comment">#创建一个测试集，分成训练集</span></span><br><span class="line"><span class="comment">#（前6万张图像）和测试集（最后1万张图像）</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">shuffle_index = np.random.permutation(<span class="number">60000</span>)</span><br><span class="line">X_train, y_train = X_train[shuffle_index], y_train[shuffle_index]</span><br><span class="line">print(X_train.shape)</span><br></pre></td></tr></tbody></table></figure><pre><code>(60000, 784)</code></pre><h1 id="Binary-classifier二分类"><a href="#Binary-classifier二分类" class="headerlink" title="Binary classifier二分类"></a>Binary classifier二分类</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#训练一个二元分类器</span></span><br><span class="line">y_train = y_train.astype(np.int8)<span class="comment">#将充满false的数组强制转换为int8</span></span><br><span class="line">print(y_train_5)</span><br><span class="line">y_train_5 = (y_train == <span class="number">5</span>)</span><br><span class="line">y_test_5 = (y_test == <span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>[False False  True ... False False False]</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> SGDClassifier</span><br><span class="line"><span class="comment">#挑选一个分类器并开始训练，SGDClassifier在训练时是完全随机的。</span></span><br><span class="line">sgd_clf = SGDClassifier(random_state=<span class="number">42</span>)</span><br><span class="line">sgd_clf.fit(X_train, y_train_5)</span><br></pre></td></tr></tbody></table></figure><pre><code>SGDClassifier(random_state=42)</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sgd_clf.predict([some_digit])</span><br></pre></td></tr></tbody></table></figure><pre><code>array([False])</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#交叉验证是评估模型的好办法</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="comment">##用cross_val_score（） 函数来评估SGDClassifier模型， 采用K-fold交叉验证法， 3个折叠。</span></span><br><span class="line"><span class="comment">#K-fold交叉验证的意思是将训练集分解成K个折叠（在本例中， 为3折） ， 然后每次留其中1个折叠进行预测， 剩余的折叠用来训练</span></span><br><span class="line">cross_val_score(sgd_clf, X_train, y_train_5, cv=<span class="number">3</span>, scoring=<span class="string">"accuracy"</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>array([0.9334, 0.9644, 0.9568])</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> clone</span><br><span class="line"></span><br><span class="line">skfolds = StratifiedKFold(n_splits=<span class="number">3</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> train_index, test_index <span class="keyword">in</span> skfolds.split(X_train, y_train_5):</span><br><span class="line">    clone_clf = clone(sgd_clf)</span><br><span class="line">    X_train_folds = X_train[train_index]</span><br><span class="line">    y_train_folds = (y_train_5[train_index])</span><br><span class="line">    X_test_fold = X_train[test_index]</span><br><span class="line">    y_test_fold = (y_train_5[test_index])</span><br><span class="line"></span><br><span class="line">    clone_clf.fit(X_train_folds, y_train_folds)</span><br><span class="line">    y_pred = clone_clf.predict(X_test_fold)</span><br><span class="line">    n_correct = sum(y_pred == y_test_fold)</span><br><span class="line">    print(n_correct / len(y_pred))</span><br></pre></td></tr></tbody></table></figure><pre><code>D:\Anaconda3\envs\learn\lib\site-packages\sklearn\model_selection\_split.py:297: FutureWarning: Setting a random_state has no effect since shuffle is False. This will raise an error in 0.24. You should leave random_state to its default (None), or set shuffle=True.  FutureWarning0.93340.96440.9568</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.base <span class="keyword">import</span> BaseEstimator</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Never5Classifier</span><span class="params">(BaseEstimator)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X, y=None)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.zeros((len(X), <span class="number">1</span>), dtype=bool)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">never_5_clf = Never5Classifier()</span><br><span class="line">cross_val_score(never_5_clf, X_train, y_train_5, cv=<span class="number">3</span>, scoring=<span class="string">"accuracy"</span>)</span><br><span class="line"><span class="comment">#准确率超过90%，这是因为只有大约10%的图像是数字9，所以如果你猜一张图不是9， 90%的时间你都是正确的</span></span><br><span class="line"><span class="comment">#说明准确率通常无法成为分类器的首要性能指标</span></span><br></pre></td></tr></tbody></table></figure><pre><code>array([0.90855, 0.9093 , 0.9111 ])</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_predict</span><br><span class="line"></span><br><span class="line">y_train_pred = cross_val_predict(sgd_clf, X_train, y_train_5, cv=<span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"></span><br><span class="line">confusion_matrix(y_train_5, y_train_pred)</span><br></pre></td></tr></tbody></table></figure><pre><code>array([[53124,  1455],       [ 949,  4472]], dtype=int64)</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">y_train_perfect_predictions = y_train_5</span><br><span class="line"><span class="string">'''混淆矩阵中的行表示实际类别， 列表示预测类别。 本例中第一行</span></span><br><span class="line"><span class="string">表示所有“非5”（负类） 的图片中： 53065张被正确地分为“非5”类别</span></span><br><span class="line"><span class="string">（真负类） ， 1455张被错误地分类成了“5”（假正类） ； 第二行表示</span></span><br><span class="line"><span class="string">所有“5”（正类） 的图片中： 949张被错误地分为“非5”类别（假负</span></span><br><span class="line"><span class="string">类） ， 4472张被正确地分在了“5”这一类别（真正类） 。 一个完美的</span></span><br><span class="line"><span class="string">分类器只有真正类和真负类， 所以它的混淆矩阵只会在其对角线（左</span></span><br><span class="line"><span class="string">上到右下） 上有非零值：'''</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">confusion_matrix(y_train_5, y_train_perfect_predictions)</span><br></pre></td></tr></tbody></table></figure><pre><code>array([[54579,     0],       [    0,  5421]], dtype=int64)</code></pre><p><strong>正类预测的准确度也可称为分类器的精度</strong></p><blockquote><p><img src="https://img-blog.csdnimg.cn/20200712101652169.png" alt="在这里插入图片描述"><br><strong>TP是真正类的数量， FP是假正类的数量。</strong></p></blockquote><blockquote><p>精度通常与另一个指标一起使用，这个指标就是召回率（recall），也称为灵敏度（sensitivity）或者真正类率（TPR）：它是分类器正确检测到的正类实例的比率<br><img src="https://img-blog.csdnimg.cn/20200712102437447.png" alt="在这里插入图片描述"></p></blockquote><p>FN是假负类的数量。</p><blockquote><p>图解混淆矩阵<img src="https://img-blog.csdnimg.cn/20200712102620453.png" alt="在这里插入图片描述"></p></blockquote><h5 id="精度和召回率"><a href="#精度和召回率" class="headerlink" title="精度和召回率"></a>精度和召回率</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score, recall_score</span><br><span class="line"></span><br><span class="line">precision_score(y_train_5, y_train_pred)<span class="comment">#TP/(TP+FP)    4472/ (4472+ 1455)</span></span><br><span class="line"><span class="comment">#array([[53124,  1455],     TN   FP</span></span><br><span class="line"> <span class="comment">#          [ 949,  4472]]   FN    TP</span></span><br></pre></td></tr></tbody></table></figure><pre><code>0.754513244474439</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recall_score(y_train_5, y_train_pred)<span class="comment">#TP/(TP+FN)  4472/(4472+949)</span></span><br></pre></td></tr></tbody></table></figure><pre><code>0.8249400479616307</code></pre><p>因此我们可以很方便地将精度和召回率组合成一个单一的指标，称为F1分数。 当你需要一个简单的方法来比较两种分类器时， 这是个非常不错的指标。 F1分数是精度和召回率的谐波平均值 。 正常的平均值平等对待所有的值， 而谐波平均值会给予较低的值更高的权重。 因此， 只有当召回率和精度都很高时， 分类器才能得到较高的F1分数</p><blockquote><p>F1分数<br><img src="https://img-blog.csdnimg.cn/20200712104926562.png" alt="在这里插入图片描述"></p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line">f1_score(y_train_5, y_train_pred)<span class="comment">#4472/ (4472+ (949+ 1455)/2)</span></span><br></pre></td></tr></tbody></table></figure><pre><code>0.7881565033486078</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4472</span>/ (<span class="number">4472</span>+ (<span class="number">949</span>+ <span class="number">1455</span>)/<span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>0.7881565033486078</code></pre><h4 id="精度-召回率权衡"><a href="#精度-召回率权衡" class="headerlink" title="精度/召回率权衡"></a>精度/召回率权衡</h4><p>Scikit-Learn不允许直接设置阈值，但是可以访问它用于预测的决策分数。不是调用分类器的predict（）方法，而是调用decision_function（）方法，这个方法返回每个实例的分数，然后就可以根据这些分数，使用任意阈值进行预测了：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y_scores = sgd_clf.decision_function([some_digit])</span><br><span class="line">y_scores</span><br></pre></td></tr></tbody></table></figure><pre><code>array([ 161855.74572176])</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threshold = <span class="number">0</span></span><br><span class="line">y_some_digit_pred = (y_scores &gt; threshold)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_some_digit_pred</span><br></pre></td></tr></tbody></table></figure><p>   array([ True], dtype=bool)<br>SGDClassifier分类器使用的阈值是0， 所以前面的代码返回结果<br>与predict（） 方法一样（也就是True） 。 我们来试试提升阈值：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">threshold = <span class="number">200000</span></span><br><span class="line">y_some_digit_pred = (y_scores &gt; threshold)</span><br><span class="line">y_some_digit_pred</span><br></pre></td></tr></tbody></table></figure><pre><code>array([False], dtype=bool)</code></pre><p>这证明了提高阈值确实可以降低召回率。 这张图确实是5， 当阈值为0时， 分类器可以检测到该图， 但是当阈值提高到200000时， 就错过了这张图。</p><ul><li>那么要如何决定使用什么阈值呢？ 首先， 使用cross_val_predict（） 函数获取训练集中所有实例的分数， 但是这次需要它返回的是决策分数而不是预测结果：<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y_scores = cross_val_predict(sgd_clf, X_train, y_train_5, cv=<span class="number">3</span>,</span><br><span class="line">                             method=<span class="string">"decision_function"</span>)</span><br></pre></td></tr></tbody></table></figure></li></ul><p>Note: there is an <a href="https://github.com/scikit-learn/scikit-learn/issues/9589" target="_blank" rel="noopener">issue</a> introduced in Scikit-Learn 0.19.0 where the result of <code>cross_val_predict()</code> is incorrect in the binary classification case when using <code>method="decision_function"</code>, as in the code above. The resulting array has an extra first dimension full of 0s. We need to add this small hack for now to work around this issue:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_scores.shape</span><br></pre></td></tr></tbody></table></figure><pre><code>(60000, 2)</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hack to work around issue #9589 introduced in Scikit-Learn 0.19.0</span></span><br><span class="line"><span class="keyword">if</span> y_scores.ndim == <span class="number">2</span>:</span><br><span class="line">    y_scores = y_scores[:, <span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure><p>有了这些分数， 可以使用precision_recall_curve（） 函数来计算<br>所有可能的阈值的精度和召回率：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_recall_curve</span><br><span class="line"></span><br><span class="line">precisions, recalls, thresholds = precision_recall_curve(y_train_5, y_scores)</span><br></pre></td></tr></tbody></table></figure><p>最后， 使用Matplotlib绘制精度和召回率相对于阈值的函数图</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_precision_recall_vs_threshold</span><span class="params">(precisions, recalls, thresholds)</span>:</span></span><br><span class="line">    plt.plot(thresholds, precisions[:<span class="number">-1</span>], <span class="string">"b--"</span>, label=<span class="string">"Precision"</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">    plt.plot(thresholds, recalls[:<span class="number">-1</span>], <span class="string">"g-"</span>, label=<span class="string">"Recall"</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">    plt.xlabel(<span class="string">"Threshold"</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">"upper left"</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">    plt.ylim([<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line">plot_precision_recall_vs_threshold(precisions, recalls, thresholds)</span><br><span class="line">plt.xlim([<span class="number">-700000</span>, <span class="number">700000</span>])</span><br><span class="line">save_fig(<span class="string">"precision_recall_vs_threshold_plot"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><pre><code>Saving figure precision_recall_vs_threshold_plot</code></pre><p><img src="https://img-blog.csdnimg.cn/20200712114715852.png" alt="在这里插入图片描述"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(y_train_pred == (y_scores &gt; <span class="number">0</span>)).all()</span><br></pre></td></tr></tbody></table></figure><pre><code>True</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_train_pred_90 = (y_scores &gt; <span class="number">70000</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">precision_score(y_train_5, y_train_pred_90)</span><br></pre></td></tr></tbody></table></figure><pre><code>0.86592051164915484</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recall_score(y_train_5, y_train_pred_90)</span><br></pre></td></tr></tbody></table></figure><pre><code>0.69931746910164172</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_precision_vs_recall</span><span class="params">(precisions, recalls)</span>:</span></span><br><span class="line">    plt.plot(recalls, precisions, <span class="string">"b-"</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">    plt.xlabel(<span class="string">"Recall"</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">    plt.ylabel(<span class="string">"Precision"</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">    plt.axis([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">plot_precision_vs_recall(precisions, recalls)</span><br><span class="line">save_fig(<span class="string">"precision_vs_recall_plot"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><pre><code>Saving figure precision_vs_recall_plot</code></pre><p><img src="https://img-blog.csdnimg.cn/20200712141839897.png" alt="在这里插入图片描述"></p><h1 id="ROC-曲线"><a href="#ROC-曲线" class="headerlink" title="ROC 曲线"></a>ROC 曲线</h1><p>ROC叫受试者工作特征曲线。它与精度/召回率曲线非常相似，但绘制的不<br>是精度和召回率，而是真正类率（召回率的另一名称）和假正类率（<code>FPR</code>）。 FPR是被错误分为正类的负类实例比率。它等于1减去真负类率<code>（TNR）</code>，后者是被正确分类为负类的负类实例比率，也称为特异度。因此， ROC曲线绘制的是灵敏度和（1-<code>特异度</code>）的关系。</p><pre><code>要绘制ROC曲线，首先需要使用roc_curve（）函数计算多种阈值的TPR和FPR：</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve</span><br><span class="line">fpr, tpr, thresholds = roc_curve(y_train_5, y_scores)</span><br></pre></td></tr></tbody></table></figure><pre><code>然后，使用Matplotlib绘制FPR对TPR的曲线。</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_roc_curve</span><span class="params">(fpr, tpr, label=None)</span>:</span></span><br><span class="line">    plt.plot(fpr, tpr, linewidth=<span class="number">2</span>, label=label)</span><br><span class="line">    plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], <span class="string">'k--'</span>)</span><br><span class="line">    plt.axis([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">    plt.xlabel(<span class="string">'False Positive Rate'</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'True Positive Rate'</span>, fontsize=<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">plot_roc_curve(fpr, tpr)</span><br><span class="line">save_fig(<span class="string">"roc_curve_plot"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><pre><code>Saving figure roc_curve_plot</code></pre><p><img src="https://img-blog.csdnimg.cn/20200712142233693.png" alt="在这里插入图片描述"><br><strong>召回率（TPR） 越高， 分类器产生的假正类（FPR） 就越多。 虚线表示纯随机分类器的ROC曲线；一个优秀的分类器应该离这条线越远越好（向左上角） 。</strong></p><hr><p>　　有一种比较分类器的方法是测量曲线下面积（AUC） 。 完美的分类器的ROC AUC等于1， 而纯随机分类器的ROC AUC等于0.5。Scikit-Learn提供计算ROC AUC的函数：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line">roc_auc_score(y_train_5, y_scores)</span><br></pre></td></tr></tbody></table></figure><pre><code>0.96244965559671547</code></pre><p>由于ROC曲线与精度/召回率（或PR） 曲线非常相似，有时候我们会选择使用哪种曲线，有一个经验法则是， 当正类非常少见或者你更关注假正类而不是假负类时， 你应该选择PR曲线， 反之则是ROC曲线。PR曲线可以暗示分类器还有改进的空间（曲线更接近右上角）。</p><p><strong>下面训练一个RandomForestClassifier分类器，并比较它和SGDClassifier分类器的ROC曲线和ROC AUC分数。</strong>    </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line">forest_clf = RandomForestClassifier(random_state=<span class="number">42</span>)</span><br><span class="line">y_probas_forest = cross_val_predict(forest_clf, X_train, y_train_5, cv=<span class="number">3</span>,</span><br><span class="line">                                    method=<span class="string">"predict_proba"</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y_scores_forest = y_probas_forest[:, <span class="number">1</span>] <span class="comment"># score = proba of positive class</span></span><br><span class="line">fpr_forest, tpr_forest, thresholds_forest = roc_curve(y_train_5,y_scores_forest)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">plt.plot(fpr, tpr, <span class="string">"b:"</span>, linewidth=<span class="number">2</span>, label=<span class="string">"SGD"</span>)</span><br><span class="line">plot_roc_curve(fpr_forest, tpr_forest, <span class="string">"Random Forest"</span>)</span><br><span class="line">plt.legend(loc=<span class="string">"lower right"</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">save_fig(<span class="string">"roc_curve_comparison_plot"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><pre><code>Saving figure roc_curve_comparison_plot</code></pre><p><img src="https://img-blog.csdnimg.cn/20200712144550778.png" alt="在这里插入图片描述"><br>如上图所示， RandomForestClassifier的ROC曲线看起来比SGDClassifier好很多： 它离左上角更接近。 因此它的ROC AUC分数也高得多：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roc_auc_score(y_train_5, y_scores_forest)</span><br></pre></td></tr></tbody></table></figure><pre><code>0.99312433660038291</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y_train_pred_forest = cross_val_predict(forest_clf, X_train, y_train_5, cv=<span class="number">3</span>)</span><br><span class="line">precision_score(y_train_5, y_train_pred_forest)<span class="comment">#精度</span></span><br></pre></td></tr></tbody></table></figure><pre><code>0.98529734474434938</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recall_score(y_train_5, y_train_pred_forest)<span class="comment">#召回率</span></span><br></pre></td></tr></tbody></table></figure><pre><code>0.82826046854823832再测一测精度和召回率的分数： 98.5%的精度和82.8%的召回率， 也还不错！</code></pre><h1 id="Multiclass-classification多类别分类器"><a href="#Multiclass-classification多类别分类器" class="headerlink" title="Multiclass classification多类别分类器"></a>Multiclass classification多类别分类器</h1><p>二元分类器在两个类别中区分，而多类别分类器（也称为多项分类器）可以区分两个以上的类别。</p><p>Scikit-Learn可以检测到你尝试使用二元分类算法进行多类别分类任务，它会自动运行OvA（SVM分类器除外，它会使用OvO）。我们用SGDClassifier试试：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sgd_clf.fit(X_train, y_train)</span><br><span class="line">sgd_clf.predict([some_digit])</span><br></pre></td></tr></tbody></table></figure><pre><code>array([ 5.])</code></pre><p>可以调用decision_function（ ） 方法，Scikit-Learns实际上训练了10个二元分类器，获得它们对图片的决策分数， 然后选择了分数最高的类别。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">some_digit_scores = sgd_clf.decision_function([some_digit])</span><br><span class="line">some_digit_scores</span><br></pre></td></tr></tbody></table></figure><pre><code>array([[-311402.62954431, -363517.28355739, -446449.5306454 ,        -183226.61023518, -414337.15339485,  161855.74572176,        -452576.39616343, -471957.14962573, -518542.33997148,        -536774.63961222]])</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.argmax(some_digit_scores)<span class="comment">#最好分是对应数字5这个类别</span></span><br></pre></td></tr></tbody></table></figure><pre><code>5</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sgd_clf.classes_</span><br></pre></td></tr></tbody></table></figure><pre><code>array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.])</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sgd_clf.classes_[<span class="number">5</span>]<span class="comment">#当训练分类器时， 目标类别的列表会存储在classes_这个属性中， 按值的大小排序。</span></span><br></pre></td></tr></tbody></table></figure><pre><code>5.0</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.multiclass <span class="keyword">import</span> OneVsOneClassifier</span><br><span class="line">ovo_clf = OneVsOneClassifier(SGDClassifier(random_state=<span class="number">42</span>))</span><br><span class="line">ovo_clf.fit(X_train, y_train)</span><br><span class="line">ovo_clf.predict([some_digit])</span><br></pre></td></tr></tbody></table></figure><pre><code>array([ 5.])</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(ovo_clf.estimators_)</span><br></pre></td></tr></tbody></table></figure><pre><code>45</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forest_clf.fit(X_train, y_train)</span><br><span class="line">forest_clf.predict([some_digit])</span><br></pre></td></tr></tbody></table></figure><pre><code>array([ 5.])</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forest_clf.predict_proba([some_digit])</span><br></pre></td></tr></tbody></table></figure><pre><code>array([[ 0.1,  0. ,  0. ,  0.1,  0. ,  0.8,  0. ,  0. ,  0. ,  0. ]])</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cross_val_score(sgd_clf, X_train, y_train, cv=<span class="number">3</span>, scoring=<span class="string">"accuracy"</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>array([ 0.84063187,  0.84899245,  0.86652998])</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">scaler = StandardScaler()</span><br><span class="line">X_train_scaled = scaler.fit_transform(X_train.astype(np.float64))</span><br><span class="line">cross_val_score(sgd_clf, X_train_scaled, y_train, cv=<span class="number">3</span>, scoring=<span class="string">"accuracy"</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>array([ 0.91011798,  0.90874544,  0.906636  ])</code></pre><h4 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h4><p>一般机器学习项目包含：探索数据准备的选项， 尝试多个模型， 列出最佳模型并用GridSearchCV对其超参数进行微调， 尽可能自动化。假设当前已经找到了一个由潜力的模型，现在想进一步微调参数。<br><strong>首先， 看看混淆矩阵。 就像之前做的， 使用cross_val_predict（）函数进行预测， 然后调用confusion_matrix（） 函数：</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y_train_pred = cross_val_predict(sgd_clf, X_train_scaled, y_train, cv=<span class="number">3</span>)</span><br><span class="line">conf_mx = confusion_matrix(y_train, y_train_pred)</span><br><span class="line">conf_mx</span><br></pre></td></tr></tbody></table></figure><pre><code>array([[5725,    3,   24,    9,   10,   49,   50,   10,   39,    4],       [   2, 6493,   43,   25,    7,   40,    5,   10,  109,    8],       [  51,   41, 5321,  104,   89,   26,   87,   60,  166,   13],       [  47,   46,  141, 5342,    1,  231,   40,   50,  141,   92],       [  19,   29,   41,   10, 5366,    9,   56,   37,   86,  189],       [  73,   45,   36,  193,   64, 4582,  111,   30,  193,   94],       [  29,   34,   44,    2,   42,   85, 5627,   10,   45,    0],       [  25,   24,   74,   32,   54,   12,    6, 5787,   15,  236],       [  52,  161,   73,  156,   10,  163,   61,   25, 5027,  123],       [  43,   35,   26,   92,  178,   28,    2,  223,   82, 5240]])</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_confusion_matrix</span><span class="params">(matrix)</span>:</span></span><br><span class="line">    <span class="string">"""If you prefer color and a colorbar"""</span></span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    cax = ax.matshow(matrix)</span><br><span class="line">    fig.colorbar(cax)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.matshow(conf_mx, cmap=plt.cm.gray)</span><br><span class="line">save_fig(<span class="string">"confusion_matrix_plot"</span>, tight_layout=<span class="literal">False</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><pre><code>Saving figure confusion_matrix_plot</code></pre><p><img src="https://img-blog.csdnimg.cn/20200712154942119.png" alt="在这里插入图片描述"><br>混淆矩阵看起来很不错，因为大多数图片都在主对角线上，这说明它们被正确分类。</p><p>让我们把焦点放在错误上。首先，你需要将混淆矩阵中的每个值除以相应类别中的图片数量，这样你比较的就是错误率而不是错误的绝对值（后者对图片数量较多的类别不公平）：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">row_sums = conf_mx.sum(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">norm_conf_mx = conf_mx / row_sums</span><br></pre></td></tr></tbody></table></figure><p>用0填充对角线，只保留错误，重新绘制结果：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.fill_diagonal(norm_conf_mx, <span class="number">0</span>)</span><br><span class="line">plt.matshow(norm_conf_mx, cmap=plt.cm.gray)</span><br><span class="line">save_fig(<span class="string">"confusion_matrix_errors_plot"</span>, tight_layout=<span class="literal">False</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><pre><code>Saving figure confusion_matrix_errors_plot</code></pre><p><img src="https://img-blog.csdnimg.cn/20200712155723349.png" alt="在这里插入图片描述"><br>　　现在可以清晰地看到分类器产生的错误种类了。 记住， 每行代表实际类别， 而每列表示预测类别。 第8列和第9列整体看起来非常亮，说明有许多图片被错误地分类为数字8或数字9了。 同样， 类别8和类别9的行看起来也偏亮， 说明数字8和数字9经常会跟其他数字混淆。相反， 一些行很暗， 比如行1， 这意味着大多数数字1都被正确地分类（有一些与数字8弄混， 但仅此而已） 。 注意， 错误不是完全对称的， 比如， 数字5被错误分类为数字8的数量比数字8被错误分类为数字5的数量要更多。<br>　　分析混淆矩阵通常可以帮助你深入了解如何改进分类器。 通过上面那张图来看， 你的精力可以花在改进数字8和数字9的分类， 以及修正数字3和数字5的混淆上。</p><blockquote><p>分析单个的错误也可以为分类器提供洞察： 它在做什么？ 它为什<br>么失败？ 但这通常更加困难和耗时。 例如， 我们来看看数字3和数字5<br>的例子：</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cl_a, cl_b = <span class="number">3</span>, <span class="number">5</span></span><br><span class="line">X_aa = X_train[(y_train == cl_a) &amp; (y_train_pred == cl_a)]</span><br><span class="line">X_ab = X_train[(y_train == cl_a) &amp; (y_train_pred == cl_b)]</span><br><span class="line">X_ba = X_train[(y_train == cl_b) &amp; (y_train_pred == cl_a)]</span><br><span class="line">X_bb = X_train[(y_train == cl_b) &amp; (y_train_pred == cl_b)]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">plt.subplot(<span class="number">221</span>); plot_digits(X_aa[:<span class="number">25</span>], images_per_row=<span class="number">5</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>); plot_digits(X_ab[:<span class="number">25</span>], images_per_row=<span class="number">5</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>); plot_digits(X_ba[:<span class="number">25</span>], images_per_row=<span class="number">5</span>)</span><br><span class="line">plt.subplot(<span class="number">224</span>); plot_digits(X_bb[:<span class="number">25</span>], images_per_row=<span class="number">5</span>)</span><br><span class="line">save_fig(<span class="string">"error_analysis_digits_plot"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><pre><code>Saving figure error_analysis_digits_plot</code></pre><p><img src="https://img-blog.csdnimg.cn/20200712155734642.png" alt="在这里插入图片描述"><br>　　左侧的两个5×5矩阵显示了被分类为数字3的图片，右侧的两个5×5矩阵显示了被分类为数字5的图片。分类器弄错的数字（即左下方和右上方的矩阵）里，确实有一些写得非常糟糕，即便是人类也很难做出区分（例如，第8行第1列的数字5看起来真的很像数字3）。然而，对我们来说，大多数错误分类的图片看起来还是非常明显的错误，我们很难理解分类器为什么会弄错。 原因在于，我们使用的简单的SGDClassifier模型是一个线性模型。它所做的就是为每个像素分配一个各个类别的权重，当它看到新的图像时，将加权后的像素强度汇总，从而得到一个分数进行分类。而数字3和数字5只在一部分像素位上有区别，所以分类器很容易将其弄混。<br>数字3和数字5之间的主要区别是在于连接顶线和下方弧线的中间那段小线条的位置。如果你写的数字3将连接点略往左移，分类器就可能将其分类为数字5，反之亦然。换言之，这个分类器对图像移位和旋转非常敏感。因此，减少数字3和数字5混淆的方法之一，就是对<code>图片进行预处理</code>， 确保它们位于中心位置并且没有旋转。 这也同样有助于减少其他错误。</p><h1 id="Multilabel-classification多标签分类"><a href="#Multilabel-classification多标签分类" class="headerlink" title="Multilabel classification多标签分类"></a>Multilabel classification多标签分类</h1><p>　　&nbsp; &nbsp; 到目前为止，每个实例都只会被分在一个类别里。而在某些情况下，你希望分类器为每个实例产出多个类别。例如，人脸识别的分类器：如果在一张照片里识别出多个人怎么办？当然，应该为识别出来的每个人都附上一个标签。假设分类器经过训练，已经可以识别出三张脸——爱丽丝、鲍勃和查理，那么当看到一张爱丽丝和查理的照片时，它应该输出[1， 0， 1]（意思是“是爱丽丝，不是鲍勃，是查理”）这种输出多个二元标签的分类系统称为多标签分类系统。<br>来看一个例子：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line">y_train_large = (y_train &gt;= <span class="number">7</span>)</span><br><span class="line">y_train_odd = (y_train % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">y_multilabel = np.c_[y_train_large, y_train_odd]</span><br><span class="line"></span><br><span class="line">knn_clf = KNeighborsClassifier()</span><br><span class="line">knn_clf.fit(X_train, y_multilabel)</span><br></pre></td></tr></tbody></table></figure><p>这段代码会创建一个y_multilabel数组，其中包含两个数字图片的目标标签：第一个表示数字是否是大数（7、 8、 9），第二个表示是否为奇数。下一行创建一个KNeighborsClassifier实例（它支持多标签分类，不是所有的分类器都支持），然后使用多个目标数组对它进行训练。现在用它做一个预测，注意它输出的两个标签：</p><pre><code>KNeighborsClassifier(algorithm='auto', leaf_size=30, metric='minkowski',           metric_params=None, n_jobs=1, n_neighbors=5, p=2,           weights='uniform')</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">knn_clf.predict([some_digit])</span><br></pre></td></tr></tbody></table></figure><pre><code>array([[False,  True]], dtype=bool)</code></pre><p><strong>结果是正确的！数字5确实不大（False），为奇数（True）。</strong><br>评估多标签分类器的方法很多，如何选择正确的度量指标取决于你的项目。比如方法之一是测量每个标签的F1分数（或者是之前讨论过的任何其他二元分类器指标），然后简单地平均。下面这段代码计算所有标签的平均F1分数：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y_train_knn_pred = cross_val_predict(knn_clf, X_train, y_multilabel, cv=<span class="number">3</span>)</span><br><span class="line">f1_score(y_multilabel, y_train_knn_pred, average=<span class="string">"macro"</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>0.97709078477525002</code></pre><p>这里假设了所有的标签都同等重要， 但实际可能不是这样。 特别是， 如果训练的照片里爱丽丝比鲍勃和查理要多很多， 你可能想给区分爱丽丝的分类器更高的权重。 一个简单的办法是给每个标签设置一个等于其自身支持的权重（也就是具有该目标标签的实例的数量） 。只需要在上面的代码中设置average=”weighted”即可。</p><h1 id="Multioutput-classification多输出-多类别分类"><a href="#Multioutput-classification多输出-多类别分类" class="headerlink" title="Multioutput classification多输出-多类别分类"></a>Multioutput classification多输出-多类别分类</h1><p>举个例子：为了说明这一点，构建一个系统去除图片中的噪声。给它输入一张有噪声的图片，它将（希望）输出一张干净的数字图片，跟其他MNIST图片一样，以像素强度的一个数组作为呈现方式。请注意，这个分类器的输出是多个标签（一个像素点一个标签），每个标签可以有多个值（像素强度范围为0到225）。所以这是个多输出分类器系统的例子</p><blockquote><p>还先从创建训练集和测试集开始，使用NumPy的randint（）函数为MNIST图片的像素强度增加噪声。目标是将图片还原为原始图片：</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">noise = np.random.randint(<span class="number">0</span>, <span class="number">100</span>, (len(X_train), <span class="number">784</span>))</span><br><span class="line">X_train_mod = X_train + noise</span><br><span class="line">noise = np.random.randint(<span class="number">0</span>, <span class="number">100</span>, (len(X_test), <span class="number">784</span>))</span><br><span class="line">X_test_mod = X_test + noise</span><br><span class="line">y_train_mod = X_train</span><br><span class="line">y_test_mod = X_test</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">some_index = <span class="number">5500</span></span><br><span class="line">plt.subplot(<span class="number">121</span>); plot_digit(X_test_mod[some_index])</span><br><span class="line">plt.subplot(<span class="number">122</span>); plot_digit(y_test_mod[some_index])</span><br><span class="line">save_fig(<span class="string">"noisy_digit_example_plot"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><pre><code>Saving figure noisy_digit_example_plot</code></pre><p><img src="https://img-blog.csdnimg.cn/20200712155747653.png" alt="在这里插入图片描述"><br>左边是有噪声的输入图片， 右边是干净的目标图片。 现在通过训练分类器， 清洗这张图片：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">knn_clf.fit(X_train_mod, y_train_mod)</span><br><span class="line">clean_digit = knn_clf.predict([X_test_mod[some_index]])</span><br><span class="line">plot_digit(clean_digit)</span><br><span class="line">save_fig(<span class="string">"cleaned_digit_example_plot"</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>Saving figure cleaned_digit_example_plot</code></pre><p><img src="https://img-blog.csdnimg.cn/20200712155756178.png" alt="在这里插入图片描述"></p><p>看起来这张图片离目标足够接近了。<br>`阅读《机器学习实战-基于Scikit-Learn和TensorFlow》这本书第三章，上述笔记基本参考此书。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习</title>
      <link href="/posts/fb35.html"/>
      <url>/posts/fb35.html</url>
      
        <content type="html"><![CDATA[<h3 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h3><h6 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h6><p>python中单行注释以<code>#</code>开头，多行注释可以用多个<code>#</code>号，或者采用<code>'''</code>和<code>"""</code></p><a id="more"></a><h6 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h6><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 <code>{ }</code></p><h6 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h6><p>python中单引号和双引号使用完全相同。<br>使用三引号(‘’’或”””)可以指定一个多行字符串。<br>转义符 ‘'<br>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r”this is a line with \n” 则\n会显示，并不是换行。这里的r指raw，即raw string原始字符串<br>按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。<br>字符串可以用 + 运算符连接在一起，用 * 运算符重复。<br>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。<br><img src="https://img-blog.csdnimg.cn/2020061716105559.png" alt="在这里插入图片描述"><br>Python中的字符串不能改变。<br>Python 没有单独的字符类型，都为字符串，一个字符就是长度为 1 的字符串。<br>字符串的截取的语法格式如下：<code>变量[头下标:尾下标:步长]</code></p><h6 id="等待用户输入"><a href="#等待用户输入" class="headerlink" title="等待用户输入"></a>等待用户输入</h6><p><img src="https://img-blog.csdnimg.cn/20200617161333659.png" alt="在这里插入图片描述"></p><h6 id="print输出"><a href="#print输出" class="headerlink" title="print输出"></a>print输出</h6><p>print默认输出是换行的，如果想要不换行需要在变量末尾加上end=” “</p><h6 id="import与from…import"><a href="#import与from…import" class="headerlink" title="import与from…import"></a>import与from…import</h6><p>在 python 用<code>import</code>或者<code>from...import</code>来导入相应的模块。</p><p>将整个模块(somemodule)导入，格式为：<code>import somemodule</code></p><p>从某个模块中导入某个函数,格式为： <code>from somemodule import somefunction</code></p><p>从某个模块中导入多个函数,格式为：<code>from somemodule import firstfunc, secondfunc, thirdfunc</code></p><p>将某个模块中的全部函数导入，格式为： <code>from somemodule import *</code></p><h4 id="python基本数据类型"><a href="#python基本数据类型" class="headerlink" title="python基本数据类型"></a>python基本数据类型</h4><p>Python 中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</p><p>在 Python 中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p><h5 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h5><p>python3中有6个标准的数据类型</p><ul><li>Number（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Set（集合）</li><li>Dictionary（字典）<h6 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h6>支持int，float，bool，complex（复数）<br>其中内置的type()函数可以用来查询变量所指的对象类型。<br><img src="https://img-blog.csdnimg.cn/20200617173243637.png" alt="在这里插入图片描述"><br>数值运算：</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> + <span class="number">4</span>  <span class="comment"># 加法</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4.3</span> - <span class="number">2</span> <span class="comment"># 减法</span></span><br><span class="line"><span class="number">2.3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="number">7</span>  <span class="comment"># 乘法</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> / <span class="number">4</span>  <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> // <span class="number">4</span> <span class="comment"># 除法，得到一个整数</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">17</span> % <span class="number">3</span> <span class="comment"># 取余</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> ** <span class="number">5</span> <span class="comment"># 乘方</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></tbody></table></figure><p>需要注意：一个变量可以通过赋值指向不同类型的对象，数值的除法包含两个运算符：<code>/</code>返回一个浮点数，<code>//</code>返回一个整数。</p><h6 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h6><p>字符串或串(String)是由数字、字母、下划线组成的一串字符。<br>Python中的字符串用单引号<code>'</code>或双引号<code>"</code>括起来，同时使用反斜杠<code>\</code>转义特殊字符。<br>python的字串列表有2种取值顺序:</p><ul><li>从左到右索引默认0开始的，最大范围是字符串长度少1</li><li>从右到左索引默认-1开始的，最大范围是字符串开头</li></ul><p>逆序输出字符串：<br><img src="https://img-blog.csdnimg.cn/20200617173956563.png" alt="在这里插入图片描述"><br>从字符串中截取一串字符：使用 <code>[头下标:尾下标]</code> 来截取相应的字符串<br><img src="https://img-blog.csdnimg.cn/20200709114150810.png" alt="在这里插入图片描述"><br><code>[头下标:尾下标]</code>获取的子字符串包含头下标的字符，但不包含尾下标的字符。</p><h6 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h6><p>List（列表） 是 Python 中使用最频繁的数据类型。<br>list是一种有序的集合，可以随时添加和删除其中的元素。<br>列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。<br><img src="https://img-blog.csdnimg.cn/2020070911494114.png" alt="在这里插入图片描述"><br>list是一个可变的有序表，所以，可以往list中追加元素到末尾：<br><img src="https://img-blog.csdnimg.cn/20200709160154717.png" alt="在这里插入图片描述"><br>也可以把元素插入到指定的位置，比如索引号为1的位置：<br><img src="https://img-blog.csdnimg.cn/20200709160843260.png" alt="在这里插入图片描述"><br>要删除list末尾的元素，用pop()方法：<br><img src="https://img-blog.csdnimg.cn/20200709161001775.png" alt="在这里插入图片描述"><br>要删除指定位置的元素，用<code>pop(i)</code>方法，其中<code>i</code>是索引位置：<br><img src="https://img-blog.csdnimg.cn/20200709161112490.png" alt="在这里插入图片描述"></p><h6 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h6><p>元组类似于列表（list，不同之处在于元组的元素不能修改。<br>元组用 () 标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。<br>当元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用：<img src="https://img-blog.csdnimg.cn/20200709123915509.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200709123942486.png" alt="在这里插入图片描述"><br>元组内置函数：</p><ul><li>len(tuple)：计算元组元素个数。<br><img src="https://img-blog.csdnimg.cn/20200709142004375.png" alt="在这里插入图片描述"></li><li>max(tuple)：返回元组中元素最大值。<br><img src="https://img-blog.csdnimg.cn/20200709142057162.png" alt="在这里插入图片描述"></li><li>min(tuple)：返回元组中元素最小值。<br><img src="https://img-blog.csdnimg.cn/20200709142124386.png" alt="在这里插入图片描述"></li><li>tuple(iterable) 将可迭代系列转换为元组。<br><img src="https://img-blog.csdnimg.cn/20200709142158426.png" alt="在这里插入图片描述"></li></ul><h6 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h6><p>字典是另一种可变容器模型，且可存储任意类型对象。<br>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。<br>字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中 ,格式如下所示：</p><blockquote><p>d = {key1 : value1, key2 : value2 }</p></blockquote><p>给定一个名字，要查找对应的成绩。用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下<br><img src="https://img-blog.csdnimg.cn/20200709193930995.png" alt="在这里插入图片描述"><br>注意，dict内部存放的顺序和key放入的顺序是没有关系的。<br>和list比较，dict有以下几个特点：</p><ul><li>1、查找和插入的速度极快，不会随着key的增加而变慢；</li><li>2、需要占用大量的内存，内存浪费多。<br>所以，dict是用空间来换取时间的一种方法。dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是<strong>不可变对象</strong>。<br>　　这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。<br>　　要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：</li></ul><h6 id="set"><a href="#set" class="headerlink" title="set"></a>set</h6><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。<br>重复的元素在set中会被自动过滤：<br><img src="https://img-blog.csdnimg.cn/20200709194518825.png" alt="在这里插入图片描述"><br>通过<code>add(key)</code>方法可以添加元素到set中，通过<code>remove(key)</code>方法可以删除元素：<br><img src="https://img-blog.csdnimg.cn/20200709194857284.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200709194929443.png" alt="在这里插入图片描述"><br>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。</p><h5 id="计算机系统通用的字符编码工作方式："><a href="#计算机系统通用的字符编码工作方式：" class="headerlink" title="计算机系统通用的字符编码工作方式："></a>计算机系统通用的字符编码工作方式：</h5><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。<br>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：<br><img src="https://img-blog.csdnimg.cn/20200709152320730.png" alt="在这里插入图片描述"><br>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：<img src="https://img-blog.csdnimg.cn/20200709152340373.png" alt="在这里插入图片描述"><br>所以当看到很多网页的源码上会有类似<meta charset="UTF-8">的信息，表示该网页正是用的UTF-8编码。</p><p>Python 3的字符串使用<code>Unicode</code>，直接支持多语言。</p><p>当<code>str</code>和<code>bytes</code>互相转换时，需要指定编码。最常用的编码是<code>UTF-8</code><br>要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。</p><p>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code>，例如：<br><img src="https://img-blog.csdnimg.cn/20200709153108903.png" alt="在这里插入图片描述"><br>如果我们从网络或磁盘上读取了字节流，那么读到的数据就是<code>bytes</code>。要把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法：<br><img src="https://img-blog.csdnimg.cn/20200709153321117.png" alt="在这里插入图片描述"></p><h5 id="谈谈input"><a href="#谈谈input" class="headerlink" title="谈谈input"></a>谈谈input</h5><p>很多时候我们会用<code>input()</code>读取用户的输入，<br><img src="https://img-blog.csdnimg.cn/20200709163056119.png" alt="在这里插入图片描述"><br>结果报错，这是因为input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。Python提供了int()函数来完成这件事情：<br><img src="https://img-blog.csdnimg.cn/20200709163145237.png" alt="在这里插入图片描述"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典排序算法</title>
      <link href="/posts/9a95.html"/>
      <url>/posts/9a95.html</url>
      
        <content type="html"><![CDATA[<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><blockquote><p>常说的十大排序算法为：冒泡、选择、插入、希尔、归并、快速、堆、计数、桶、基数</p></blockquote><a id="more"></a><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/20180705210330244.png" alt=""></p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序的本质在于交换，即每次通过交换的方式把当前剩余元素的最大值移动到一端。而当剩余元素减少为0时，排序结束。这个算法名字的由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p>算法步骤</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p><font color="orange">动图演示：</font></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/bubbleSort.b7d216a5.gif" alt=""></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//元素个数</span></span><br><span class="line"><span class="keyword">int</span> m;<span class="comment">//输入元素大小</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;<span class="comment">//动态数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">a.push_back(m);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.size(); i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.size() - i; j++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j + <span class="number">1</span>])</span><br><span class="line">{</span><br><span class="line"><span class="keyword">int</span> temp = a[j];</span><br><span class="line">a[j] = a[j + <span class="number">1</span>];</span><br><span class="line">a[j + <span class="number">1</span>] = temp;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>选择排序是指，对一个序列A中的元素A[1]~A[n]，令i从1到n枚举，进行n趟操作，每趟从待排序部分[i，n]中选择最小的元素，令其与待排序部分的第一个元素A[i]进行交换，这样元素A[i]就会与当前有序区间[1，i-1]形成新的有序区间[1，i]形成。于是在n趟操作后，所有元素就会是有序的。时间复杂度是O(n²)</p><p>算法步骤：</p><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ol><p><font color="orange">动图演示：</font></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/selectionSort.44be35da.gif" alt="动图演示"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//元素个数</span></span><br><span class="line"><span class="keyword">int</span> m;<span class="comment">//输入元素大小</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;<span class="comment">//动态数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">a.push_back(m);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//选择排序，</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size()<span class="number">-1</span>; i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">int</span> min = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; a.size(); j++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[min])</span><br><span class="line">min = j;<span class="comment">//记录目前能找到的最小值元素的下标</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i!= min)<span class="comment">//将找到的最小值和i进行交换</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">int</span> temp = a[i];</span><br><span class="line">a[i] = a[min];</span><br><span class="line">a[min] = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>插入排序是将待插入元素一个个插入初始已有序部分中的过程，而插入位置的选择遵循了使插入后仍然保持有序的原则，具体的做法一般是从后往前枚举已有序部分来确定插入位置。</p><p>算法步骤：</p><ol><li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ol><p><font color="orange">动图演示：</font></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/insertionSort.be81c151.gif" alt="动图演示"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//元素个数</span></span><br><span class="line"><span class="keyword">int</span> m;<span class="comment">//输入元素大小</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;<span class="comment">//动态数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">a.push_back(m);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.size(); i++)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">int</span> temp = a[i];<span class="comment">//待插入的数据</span></span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span> (j &gt; <span class="number">1</span> &amp;&amp; temp &lt; a[j - <span class="number">1</span>])</span><br><span class="line">{</span><br><span class="line">a[j] = a[j - <span class="number">1</span>];<span class="comment">//将待插入的数据不停的比较，向左移动</span></span><br><span class="line">j--;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (i != j)</span><br><span class="line">{</span><br><span class="line">a[j] = temp;<span class="comment">//插入数据</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序是排序算法中平均时间复杂度为O（nlogn）的一种算法，其实现需要先解决这样一个问题：对一个序列A[0]、A[1]、…、A[n-1]，调整序列中元素的位置，使得A[0]（原序列的A[1]，下同）的左侧所有元素都不超过A[1]、右侧所有元素都大于A[1]。例如对序列{5，3，9，6，4，1}来说，可以调整序列中元素的位置，形成序列{3，1，4，5，9，6}，这样就让A[0]=5左侧的所有元素都不超过它、右侧的所有元素都大于它。</p><blockquote><p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p></blockquote><p>算法步骤：</p><ol><li>从数列中挑出一个元素，称为 “基准”</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p>也就是:</p><p>①先将A[0]存至某个临时变量temp，并令两个下标left、right分别指向序列首尾（如令left=0、right=n-1）。<br>②只要right 指向的元素A[right]大于temp，就将right 不断左移；当某个时候A[right]<br>≤temp时，将元素A[right]挪到left指向的元素A[left]处。<br>③只要left指向的元素A[left]不超过temp，就将left不断右移；当某个时候A[left]&gt;temp时，将元素A[left]挪到right指向的元素A[right]处。<br>④重复②③，直到left与right相遇，把temp（也即原A[0]）放到相遇的地方。</p><p><font color="orange">动图演示：</font></p><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/quickSort.71c0f1c0.gif" alt="动图演示"></p><p>代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> temp = a[left];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) {</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; temp &lt; a[right]) right--;</span><br><span class="line">a[left] = a[right];</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; temp &gt;= a[left]) left++;</span><br><span class="line">a[right] = a[left];</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">a[left] = temp;</span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) {</span><br><span class="line"><span class="keyword">int</span> pos = partition(a, left, right);</span><br><span class="line">quicksort(a, left, pos - <span class="number">1</span>);</span><br><span class="line">quicksort(a, pos + <span class="number">1</span>, right);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//元素个数</span></span><br><span class="line"><span class="keyword">int</span> m;<span class="comment">//输入元素大小</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="comment">//vector&lt;int&gt; a;//动态数组</span></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="comment">//a.push_back(m);</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="comment">/*for (int gap = a.size() / 2; gap &gt; 0; gap /= 2) {</span></span><br><span class="line"><span class="comment">for (int i = gap; i &lt; a.size(); i++) {</span></span><br><span class="line"><span class="comment">int key = a[i];</span></span><br><span class="line"><span class="comment">int j;</span></span><br><span class="line"><span class="comment">for (j = i - gap; j &gt; 0 &amp;&amp; a[j] &gt; key; j = j - gap)</span></span><br><span class="line"><span class="comment">a[j + gap] = a[j];</span></span><br><span class="line"><span class="comment">a[j + gap] = key;</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment">}*/</span></span><br><span class="line">quicksort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>两路归并排序代码：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2路归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span> L2, <span class="keyword">int</span>  R2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i = L1;</span><br><span class="line"><span class="keyword">int</span> j = L2;</span><br><span class="line"><span class="keyword">int</span> temp[maxn], index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= R1 &amp;&amp; j &lt;= R2) {</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">{</span><br><span class="line">temp[index++] = a[i++];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">temp[index++] = a[j++];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span> (i &lt;= R1) {</span><br><span class="line">temp[index++] = a[i++];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span> (j &lt;= R2) {</span><br><span class="line">temp[index++] = a[j++];</span><br><span class="line">}</span><br><span class="line"><span class="comment">//合并后的序列赋值回数组a</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">a[i + L1] = temp[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) {</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">mergesort(a, left, mid);</span><br><span class="line">mergesort(a, mid + <span class="number">1</span>, right);</span><br><span class="line">merge(a, left, mid, mid + <span class="number">1</span>, right);<span class="comment">//两个有序的子区间合并</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//元素个数</span></span><br><span class="line"><span class="comment">//int m;//输入元素大小</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="comment">//vector&lt;int&gt; a;//动态数组</span></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="comment">//a.push_back(m);</span></span><br><span class="line">}</span><br><span class="line">mergesort(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span></span></span><br><span class="line"><span class="comment">//#include "pch.h"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* int partition(int a[], int left, int right)</span></span><br><span class="line"><span class="comment">{</span></span><br><span class="line"><span class="comment">int temp = a[left];</span></span><br><span class="line"><span class="comment">while (left &lt; right) {</span></span><br><span class="line"><span class="comment">while (left &lt; right &amp;&amp; temp &lt; a[right]) right--;</span></span><br><span class="line"><span class="comment">a[left] = a[right];</span></span><br><span class="line"><span class="comment">while (left &lt; right &amp;&amp; temp &gt;= a[left]) left++;</span></span><br><span class="line"><span class="comment">a[right] = a[left];</span></span><br><span class="line"><span class="comment">}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">a[left] = temp;</span></span><br><span class="line"><span class="comment">return left;</span></span><br><span class="line"><span class="comment">} */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2路归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span> L2, <span class="keyword">int</span>  R2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> i = L1;</span><br><span class="line"><span class="keyword">int</span> j = L2;</span><br><span class="line"><span class="keyword">int</span> temp[maxn], index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= R1 &amp;&amp; j &lt;= R2) {</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt;= a[j])</span><br><span class="line">{</span><br><span class="line">temp[index++] = a[i++];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> {</span><br><span class="line">temp[index++] = a[j++];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span> (i &lt;= R1) {</span><br><span class="line">temp[index++] = a[i++];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span> (j &lt; R2) {</span><br><span class="line">temp[index++] = a[j++];</span><br><span class="line">}</span><br><span class="line"><span class="comment">//合并后的序列赋值回数组a</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">a[i + L1] = temp[i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) {</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">mergesort(a, left, mid);</span><br><span class="line">mergesort(a, mid + <span class="number">1</span>, right);</span><br><span class="line">merge(a, left, mid, mid + <span class="number">1</span>, right);<span class="comment">//两个有序的子区间合并</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//元素个数</span></span><br><span class="line"><span class="comment">//int m;//输入元素大小</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="comment">//vector&lt;int&gt; a;//动态数组</span></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="comment">//a.push_back(m);</span></span><br><span class="line">}</span><br><span class="line">mergesort(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行程序: Ctrl + F5 或调试 &gt;“开始执行(不调试)”菜单</span></span><br><span class="line"><span class="comment">// 调试程序: F5 或调试 &gt;“开始调试”菜单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 入门提示: </span></span><br><span class="line"><span class="comment">//   1. 使用解决方案资源管理器窗口添加/管理文件</span></span><br><span class="line"><span class="comment">//   2. 使用团队资源管理器窗口连接到源代码管理</span></span><br><span class="line"><span class="comment">//   3. 使用输出窗口查看生成输出和其他消息</span></span><br><span class="line"><span class="comment">//   4. 使用错误列表窗口查看错误</span></span><br><span class="line"><span class="comment">//   5. 转到“项目”&gt;“添加新项”以创建新的代码文件，或转到“项目”&gt;“添加现有项”以将现有代码文件添加到项目</span></span><br><span class="line"><span class="comment">//   6. 将来，若要再次打开此项目，请转到“文件”&gt;“打开”&gt;“项目”并选择 .sln 文件</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://gitee.com/honor-ry/my_pic_bed/raw/master/insertionSort.be81c151.gif" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用的向量与矩阵的范数总结[L0、L1、L2范数]</title>
      <link href="/posts/f5c7.html"/>
      <url>/posts/f5c7.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="向量的范数"><a href="#向量的范数" class="headerlink" title="向量的范数"></a>向量的范数</h3><p>首先定义一个向量为：x=[-5，6，8, -10]<br>1-范数： </p><p><img src="https://img-blog.csdnimg.cn/20200709103835497.png" alt="在这里插入图片描述">，即向量的各个元素的绝对值之和，matlab调用函数norm(x, 1) 。则上述x的1-范数结果是29</p><!--more--><p>2-范数：</p><p><img src="https://img-blog.csdnimg.cn/2020070910384724.png" alt="在这里插入图片描述">，Euclid范数（欧几里得范数，常用计算向量长度），即向量元素绝对值的平方和再开方，matlab调用函数norm(x, 2)。</p><p><img src="https://img-blog.csdnimg.cn/20200709103901379.png" alt="在这里插入图片描述">-范数：</p><p><img src="https://img-blog.csdnimg.cn/20200709104135615.png" alt="在这里插入图片描述">，即所有向量元素绝对值中的最大值，matlab调用函数norm(x, inf)。</p><p><img src="https://img-blog.csdnimg.cn/20200709104145984.png" alt="在这里插入图片描述">-范数：</p><p><img src="https://img-blog.csdnimg.cn/20200709104150937.png" alt="在这里插入图片描述">，即所有向量元素绝对值中的最小值，matlab调用函数norm(x, -inf)。</p><p>p-范数：</p><p><img src="https://img-blog.csdnimg.cn/20200709104154540.png" alt="在这里插入图片描述">，即向量元素绝对值的p次方和的1/p次幂，matlab调用函数norm(x, p)。</p><h3 id="矩阵范数"><a href="#矩阵范数" class="headerlink" title="矩阵范数"></a>矩阵范数</h3><p>矩阵的1范数<br><img src="https://img-blog.csdnimg.cn/20200709104912722.png" alt="在这里插入图片描述">列和范数，即所有矩阵列向量绝对值之和的最大值，矩阵的每一列上的元素绝对值先求和，再从中取个最大的（列和最大）。matlab调用函数norm(A, 1)。</p><p>矩阵的2范数：<br>矩阵的2范数即：矩阵$A^{T} A$的最大特征值开平方根。</p><p>矩阵的无穷范数：<br>矩阵的每一行上的元素绝对值先求和，再从中取个最大的（行和最大）</p><h4 id="L0范数和L1范数"><a href="#L0范数和L1范数" class="headerlink" title="L0范数和L1范数"></a>L0范数和L1范数</h4><p>L0范数是指向量中非零元素的个数。如果用L0规则化一个参数矩阵W，就是希望W中大部分元素是零，实现稀疏。</p><p>L1范数是指向量中各个元素的绝对值之和，也叫”系数规则算子（Lasso regularization）“。L1范数也可以实现稀疏，通过将无用特征对应的参数W置为零实现。</p><p>L0和L1都可以实现稀疏化，不过一般选用L1而不用L0，原因包括：1）L0范数很难优化求解（NP难）；2）L1是L0的最优凸近似，比L0更容易优化求解。（这一段解释过于数学化，姑且当做结论记住）<br>稀疏化的好处是是什么？<br>1）特征选择<br>​实现特征的自动选择，去除无用特征。稀疏化可以去掉这些无用特征，将特征对应的权重置为零。<br>2）可解释性（interpretability）​<br>例如判断某种病的患病率时，最初有1000个特征，建模后参数经过稀疏化，最终只有5个特征的参数是非零的，那么就可以说影响患病率的主要就是这5个特征。</p><h4 id="L2范数"><a href="#L2范数" class="headerlink" title="L2范数"></a>L2范数</h4><p>L2范数​​是指向量各元素的平方和然后开方，用在回归模型中也称为岭回归（Ridge regression）。<br>L2避免过拟合的原理是：让L2范数的规则项||W||2 尽可能小，可以使得W每个元素都很小，接近于零，但是与L1不同的是，不会等于0；这样得到的模型抗干扰能力强，参数很小时，即使样本数据x发生很大的变化，模型预测值y的变化也会很有限。</p><p>参考链接：<a href="https://www.cnblogs.com/MengYan-LongYou/p/4050862.html" target="_blank" rel="noopener">https://www.cnblogs.com/MengYan-LongYou/p/4050862.html</a></p><p>  　　　　 <a href="https://blog.csdn.net/Michael__Corleone/article/details/75213123" target="_blank" rel="noopener">https://blog.csdn.net/Michael__Corleone/article/details/75213123</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 范数 矩阵算子范数 矩阵范数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>端到端的机器学习项目，预测房价</title>
      <link href="/posts/7b80.html"/>
      <url>/posts/7b80.html</url>
      
        <content type="html"><![CDATA[<h3 id="端到端的机器学习项目"><a href="#端到端的机器学习项目" class="headerlink" title="端到端的机器学习项目"></a>端到端的机器学习项目</h3><p>主要步骤：<br>1.观察大局。<br>2.获得数据。<br>3.从数据探索和可视化中获得洞见。<br>4.机器学习算法的数据准备。<br>5.选择和训练模型。<br>6.微调模型。<br>7.展示解决方案。<br>8.启动、监控和维护系统。</p><a id="more"></a><h4 id="使用的数据集"><a href="#使用的数据集" class="headerlink" title="使用的数据集"></a>使用的数据集</h4><p>选用StatLib库中选择了加州住房价格的数据集，该数据集基于1990年加州人口普查的数据。<br>链接：<a href="https://pan.baidu.com/s/10N6CHN9yxMvG1HHPL6yX2g" target="_blank" rel="noopener">https://pan.baidu.com/s/10N6CHN9yxMvG1HHPL6yX2g</a><br>提取码：xpzs</p><h4 id="观察大局"><a href="#观察大局" class="headerlink" title="观察大局"></a>观察大局</h4><p>首先要做的事是使用加州人口普查的数据建立起加州的房价模型。 数据中有许多指标， 诸如每个街区的人口数量、 收入中位数、 房价中位数等。 街区是美国人口普查局发布样本数据的最小地理单位（一个街区通常人口数为600～3000人） 。 这里， 我们将其简称为“区域”。</p><h4 id="获得数据"><a href="#获得数据" class="headerlink" title="获得数据"></a>获得数据</h4><p>所有数据——一个以逗号来分割之的CSV文档housing.csv<br>首先使用pandas来加载数据</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">HOUSING_PATH = os.path.join(<span class="string">"datasets"</span>, <span class="string">"housing"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_housing_data</span><span class="params">(housing_path=HOUSING_PATH)</span>:</span></span><br><span class="line">    csv_path = os.path.join(housing_path, <span class="string">"housing.csv"</span>)</span><br><span class="line">    <span class="keyword">return</span> pd.read_csv(csv_path)</span><br></pre></td></tr></tbody></table></figure><p>此函数会返回一个包含所有数据的Pandas DataFrame对象。<br>用DataFrame的head()方法查看数据集的前五行<br><img src="https://img-blog.csdnimg.cn/20200705171239900.png" alt="在这里插入图片描述"><br>每一行代表一个区， 总共有10个属性（上图中可以看到8个）longitude， latitude， housing_median_age， total_rooms，total_bed rooms， population， households， median_income，median_house_value以及ocean_proximity。<br>之后通过info()方法可以快速获取数据集的简单描述，比如总函数，每个属性的类型和非空值的数量。<br><img src="https://img-blog.csdnimg.cn/20200705171438778.png" alt="在这里插入图片描述"><br>数据集中包含20640个实例， total_bedrooms这个属性只有20433个非空值，这意味着有207个区域缺失这个特征。我们后面需要考虑到这一点。<br>所有属性的字段都是数字，除了ocean_proximity，其类型是object。之前通过head()方法查看前五行，发现该列中的值是重复的，表明它有可能是一个分类属性，采用value_counts()方法查看由多少种分类存在，每种类别下分别有多少个区域。<br><img src="https://img-blog.csdnimg.cn/20200705175541729.png" alt="在这里插入图片描述"><br>利用describe()方法可以显示数值属性的摘要。<br><img src="https://img-blog.csdnimg.cn/20200705180526902.png" alt="在这里插入图片描述"><br>count：非空值计数<br>mean：平均值<br>std：标准差<br>min：最小值<br>25%、50%、75%：表示一组观测值中给定百分比的观测值都低于该值。例如， 对于housing_median_age的值， 25%的区域低于18， 50%的区域低于29， 以及75%的区域低于<br>37。 </p><p>另外一种快速了解数据类型的方法是绘制每个数值属性的直方图。直方图用来显示给定范围（横轴）的实例数量（纵轴）。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline <span class="comment"># only in a Jupyter notebook</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">housing.hist(bins=<span class="number">50</span>, figsize=(<span class="number">20</span>,<span class="number">15</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><h5 id="创建测试集"><a href="#创建测试集" class="headerlink" title="创建测试集"></a>创建测试集</h5><p>理论上创建测试机非常简单：只需要随机选择一些实例，通常是数据集的20%，然后将它们放在一边。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#np.random.seed(42)</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># For illustration only. Sklearn has train_test_split()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_train_test</span><span class="params">(data, test_ratio)</span>:</span></span><br><span class="line">    shuffled_indices = np.random.permutation(len(data))</span><br><span class="line">    test_set_size = int(len(data) * test_ratio)</span><br><span class="line">    test_indices = shuffled_indices[:test_set_size]</span><br><span class="line">    train_indices = shuffled_indices[test_set_size:]</span><br><span class="line">    <span class="keyword">return</span> data.iloc[train_indices], data.iloc[test_indices]</span><br><span class="line">train_set, test_set = split_train_test(housing, <span class="number">0.2</span>)</span><br><span class="line">print(len(train_set), <span class="string">"train +"</span>, len(test_set), <span class="string">"test"</span>)</span><br></pre></td></tr></tbody></table></figure><p>如果这样，再运行一遍，又会产生一个不同的数据集。通常的解决方案是在第一次运行程序后随即保存测试机，之后只是加载它而已。另一种方法是在调用np.random.permutation()之前设置一个随机数生成器的种子np.random.seed(42)，从而让它始终生成相同的随机索引。<br>但是，这两种解决方案在下一次获取更新的数据时都会中断。常见的解决办法是每个实例都使用一个标识符（identifier）来决定是否进入测试集（假定每个实例都有一个唯一且不变的标识符）。举例来说，你可以计算每个实例标识符的hash值，只取hash的最后一个字节，如果该值小于等于51（约256的20%），则将该实例放入测试集。这样可以确保测试集在多个运行里都是一致的，即便更新数据集也仍然一致。新实例的20%将被放入新的测试集，而之前训练集中的实例也不会被放入新测试集。实现方式如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_set_check</span><span class="params">(identifier, test_ratio, hash)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> hash(np.int64(identifier)).digest()[<span class="number">-1</span>] &lt; <span class="number">256</span> * test_ratio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split_train_test_by_id</span><span class="params">(data, test_ratio, id_column, hash=hashlib.md5)</span>:</span></span><br><span class="line">    ids = data[id_column]</span><br><span class="line">    in_test_set = ids.apply(<span class="keyword">lambda</span> id_: test_set_check(id_, test_ratio, hash))</span><br><span class="line">    <span class="keyword">return</span> data.loc[~in_test_set], data.loc[in_test_set]</span><br></pre></td></tr></tbody></table></figure><p>这里housing数据集没有标识符列，最简单的办法是使用行索引作为ID：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">housing_with_id = housing.reset_index() <span class="comment"># adds an `index` column</span></span><br><span class="line">train_set, test_set = split_train_test_by_id(housing_with_id, <span class="number">0.2</span>, <span class="string">"index"</span>)</span><br></pre></td></tr></tbody></table></figure><p>同时Scikit-Learn提供了一些函数， 可以通过多种方式将数据集分成多个子集。 最简单的函数是<code>train_test_split</code>， 它与前面定义的函数<code>split_train_test</code>几乎相同， 除了几个额外特征。 首先， 它也有<code>random_state</code>参数， 让你可以像之前提到过的那样设置随机生成器种子； 其次， 你可以把行数相同的多个数据集一次性发送给它， 它会根据相同的索引将其拆分（例如， 当你有一个单独的DataFrame用于标记时， 这就非常有用） ：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">train_set, test_set = train_test_split(housing, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="从数据探索和可视化中获得洞见"><a href="#从数据探索和可视化中获得洞见" class="headerlink" title="从数据探索和可视化中获得洞见"></a>从数据探索和可视化中获得洞见</h4><p>在这个问题中，由于存在地理位置信息（经纬度），因此可建立一个各区域的分布图便于数据可视化。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">housing = strat_train_set.copy()</span><br><span class="line">housing.plot(kind=<span class="string">"scatter"</span>, x=<span class="string">"longitude"</span>, y=<span class="string">"latitude"</span>, alpha=<span class="number">0.1</span>)</span><br><span class="line">save_fig(<span class="string">"better_visualization_plot"</span>)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20200705212727930.png" alt="在这里插入图片描述"><br>现在，再来看看房价。每个圆的半径大小代表了每个地区的人口数量（选项s） ， 颜色代表价格（选项c） 。 我们使用一个名叫jet的预定义颜色表（选项cmap） 来进行可视化， 颜色范围从蓝（低） 到红（高） ： </p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">housing.plot(kind=<span class="string">"scatter"</span>, x=<span class="string">"longitude"</span>, y=<span class="string">"latitude"</span>, alpha=<span class="number">0.4</span>,</span><br><span class="line">s=housing[<span class="string">"population"</span>]/<span class="number">100</span>, label=<span class="string">"population"</span>,</span><br><span class="line">c=<span class="string">"median_house_value"</span>, cmap=plt.get_cmap(<span class="string">"jet"</span>), colorbar=<span class="literal">True</span>,</span><br><span class="line">)p</span><br><span class="line">lt.legend()</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20200705212957701.png" alt="在这里插入图片描述">　　这张图片告诉你房屋价格与地理位置（例如靠海）和人口密度息息相关，这点你可能早已知晓。一个通常很有用的方法是，使用聚类算法来检测主群体，然后再为各个聚类中心添加一个新的衡量邻近距离的特征。</p><h5 id="寻找相关性"><a href="#寻找相关性" class="headerlink" title="寻找相关性"></a>寻找相关性</h5><p>由于数据集不大，你可以使用corr（）方法轻松计算出每对属性之间的标准相关系数<br>得到每个属性与房屋中位数的相关性分别是：<br><img src="https://img-blog.csdnimg.cn/20200710213325531.png" alt="在这里插入图片描述"><br>相关系数的范围从-1变化到1。 越接近1， 表示有越强的正相关； 当系数接近于-1， 则表示有强烈的负相关； 注意看纬度和房价中位数之间呈现出轻微的负相关（也就是说， 越往北走， 房价倾向于下降） 。 最后， 系数靠近0则说明二者之间没有线性相关性。</p><h4 id="机器学习算法的数据准备"><a href="#机器学习算法的数据准备" class="headerlink" title="机器学习算法的数据准备"></a>机器学习算法的数据准备</h4><p>让我们先回到一个干净的数据集（再次复制strat_train_set），然后将预测器和标签分开，因为这里我们不一定对它们使用相同的转换方式（需要注意drop（）会创建一个数据副本，但是不影响strat_train_set）：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">housing = strat_train_set.drop(<span class="string">"median_house_value"</span>, axis=<span class="number">1</span>)<span class="comment">#strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。默认删除行，axis=1表示删除列</span></span><br><span class="line">housing_labels = strat_train_set[<span class="string">"median_house_value"</span>].copy()<span class="comment">#拷贝median_house_value作为label</span></span><br></pre></td></tr></tbody></table></figure><h5 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h5><p>针对前面提到的total_bedrooms属性有部分值缺失，可以采用以下选择：</p><ul><li>放弃这些响应的地区</li><li>放弃这个属性</li><li>将缺失的值设置为某个值（0、平均数或者中位数等都可以）</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">housing.dropna(subset=[<span class="string">"total_bedrooms"</span>]) <span class="comment"># option 1 dropna删除指定列中包含缺失值的行</span></span><br><span class="line">housing.drop(<span class="string">"total_bedrooms"</span>, axis=<span class="number">1</span>) <span class="comment"># option 2</span></span><br><span class="line">median = housing[<span class="string">"total_bedrooms"</span>].median() <span class="comment">#计算中位值</span></span><br><span class="line">housing[<span class="string">"total_bedrooms"</span>].fillna(median) <span class="comment"># option 3</span></span><br></pre></td></tr></tbody></table></figure><p>Scikit-Learn提供了一个非常容易上手的教程来处理缺失值：imputer。<br>下面是其使用方法：首先，需要创建一个Imputer实例，指定用该属性的中位数替换它的每个缺失值：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Imputer</span><br><span class="line">imputer = Imputer(strategy=<span class="string">"median"</span>)</span><br></pre></td></tr></tbody></table></figure><p>由于中位数值只能在数值属性上计算， 所以我们需要创建一个没有文本属性的数据副本ocean_proximity：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">housing_num = housing.drop(<span class="string">"ocean_proximity"</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><p>使用fit（） 方法将imputer实例适配到训练集:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imputer.fit(housing_num)</span><br></pre></td></tr></tbody></table></figure><p><code>imputer</code>计算出了每个属性的中位数，并将结果保存在了实例变量<code>statistics_</code>中。只有属性<code>total_bedrooms</code>有缺失值，但是我们要确保一旦系统运行起来，新的数据中没有缺失值，所以安全的做法是将<code>imputer</code>应用到每个数值：<br><img src="https://img-blog.csdnimg.cn/20200711115357697.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200711115426798.png" alt="在这里插入图片描述"><br>现在，你就可以使用这个“训练过的”<code>imputer</code>来对训练集进行转换，通过将缺失值替换为中位数：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X = imputer.transform(housing_num)</span><br></pre></td></tr></tbody></table></figure><p>结果是一个普通的Numpy数组，包含有转换后的特征。如果你想将其放回到Pandas DataFrame中，也很简单：<br><code>housing_tr = pd.DataFrame(X, columns=housing_num.columns)</code></p><h4 id="选择和训练模型"><a href="#选择和训练模型" class="headerlink" title="选择和训练模型"></a>选择和训练模型</h4><pre><code>现在是时候选择机器学习模型并展开训练</code></pre><h5 id="在训练集上训练和评估"><a href="#在训练集上训练和评估" class="headerlink" title="在训练集上训练和评估"></a>在训练集上训练和评估</h5><p>先训练一个线性回归模型</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line">lin_reg.fit(housing_prepared, housing_labels)</span><br></pre></td></tr></tbody></table></figure><p>完成后,现在就有了一个可用的线性回归模型。用一些训练集中的实例做以下验证：<br><img src="https://img-blog.csdnimg.cn/20200711124948118.png" alt="在这里插入图片描述"><br>比较预测值与标签值，看准确率如何。还可以使用Scikit-Learn的<code>mean_squared_error</code>函数，计算该线性回归模型的RMSE均方根误差。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line">housing_predictions = lin_reg.predict(housing_prepared)</span><br><span class="line">lin_mse = mean_squared_error(housing_labels, housing_predictions)</span><br><span class="line">lin_rmse = np.sqrt(lin_mse)</span><br><span class="line">lin_rmse</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20200711125130124.png" alt="在这里插入图片描述"><br>再来训练一个<code>DecisionTreeRegressor</code>决策树模型</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line">tree_reg = DecisionTreeRegressor(random_state=<span class="number">42</span>)</span><br><span class="line">tree_reg.fit(housing_prepared, housing_labels)</span><br></pre></td></tr></tbody></table></figure><p>训练完成后可以用训练集来评估一下</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">housing_predictions = tree_reg.predict(housing_prepared)</span><br><span class="line">tree_mse = mean_squared_error(housing_labels, housing_predictions)</span><br><span class="line">tree_rmse = np.sqrt(tree_mse)</span><br><span class="line">tree_rmse</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20200711130058345.png" alt="在这里插入图片描述"><br>均方误差为0，可能是由于模型对数据严重过拟合了。</p><p>尝试最后一个模型：<code>RandomForestRegressor</code>      　　随机森林的工作原理是通过对特征的随机子集进行许多个决策树的训练，然后对其预测取平均。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestRegressor</span><br><span class="line">forest_reg = RandomForestRegressor()</span><br><span class="line">forest_reg.fit(housing_prepared, housing_labels)</span><br><span class="line">housing_predictions = forest_reg.predict(housing_prepared)</span><br><span class="line">forest_mse = mean_squared_error(housing_labels, housing_predictions)</span><br><span class="line">forest_rmse = np.sqrt(forest_mse)</span><br><span class="line">forest_rmse</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20200711130901980.png" alt="在这里插入图片描述"></p><h4 id="微调模型"><a href="#微调模型" class="headerlink" title="微调模型"></a>微调模型</h4><h6 id="网格搜索"><a href="#网格搜索" class="headerlink" title="网格搜索"></a>网格搜索</h6><p>一种微调的方法是手动调整超参数，找到一组很好的超参数值组合。<br>还可以可以用Scikit-Learn的<code>GridSearchCV</code>来替你进行探索。你所要做的只是告诉<code>GridSearchCV</code>你要进行实验的超参数是什么，以及需要尝试的值，<code>GridSearchCV</code>将会使用交叉验证来评估超参数值的所有可能的组合。例如，下面这段代码搜索<code>RandomForestRegressor</code>的超参数值的最佳组合：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line">param_grid = [</span><br><span class="line">    {<span class="string">'n_estimators'</span>: [<span class="number">3</span>, <span class="number">10</span>, <span class="number">30</span>], <span class="string">'max_features'</span>: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]},</span><br><span class="line">    {<span class="string">'bootstrap'</span>: [<span class="literal">False</span>], <span class="string">'n_estimators'</span>: [<span class="number">3</span>, <span class="number">10</span>], <span class="string">'max_features'</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]},</span><br><span class="line">  ]</span><br><span class="line">forest_reg = RandomForestRegressor()</span><br><span class="line">grid_search = GridSearchCV(forest_reg, param_grid, cv=<span class="number">5</span>,</span><br><span class="line">                           scoring=<span class="string">'neg_mean_squared_error'</span>)</span><br><span class="line">grid_search.fit(housing_prepared, housing_labels)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>当你不能确定超参数该有什么值，一个简单的方法是尝试连续的10的次方（如果想要一个粒度更小的搜寻，可以用更小的数，就像在这个例子中对超参数n_estimators做的）。</p></blockquote><p><code>param_grid</code>告诉Scikit-Learn首先评估所有的列在第一个<code>dict</code>中的<code>n_estimators</code>和<code>max_features</code>的3 × 4 = 12种组合（不用担心这些超参数的含义，会在第7章中解释）。然后尝试第二个<code>dict中</code>超参数的2 × 3 = 6种组合，这次会将超参数bootstrap设为False而不是True（后者是该超参数的默认值）。</p><p>总之，网格搜索会探索12 + 6 = 18种<code>RandomForestRegressor</code>的超参数组合，会训练每个模型五次（因为用的是五折交叉验证）。换句话说，训练总共有18 × 5 = 90轮！折将要花费大量时间，完成后，你就能获得参数的最佳组合，如下所示：<br><img src="https://img-blog.csdnimg.cn/20200711142653582.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200711141939362.png" alt="在这里插入图片描述"></p><h4 id="随机搜索"><a href="#随机搜索" class="headerlink" title="随机搜索"></a>随机搜索</h4><p>当探索相对较少的组合时，就像前面的例子，网格搜索还可以。但是当超参数的搜索空间很大时，最好使用<code>RandomizedSearchCV</code>。这个类的使用方法和类<code>GridSearchCV</code>很相似，但它不是尝试所有可能的组合，而是通过选择每个超参数的一个随机值的特定数量的随机组合。这个方法有两个优点：</p><ul><li><p>如果你让随机搜索运行，比如1000次，它会探索每个超参数的1000个不同的值（而不是像网格搜索那样，只搜索每个超参数的几个值）。</p></li><li><p>你可以方便地通过设定搜索次数，控制超参数搜索的计算量。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP入门-情感分析|paddle</title>
      <link href="/posts/a21b.html"/>
      <url>/posts/a21b.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a><pre><code>### 任务介绍：在自然语言处理中，情感分析一般指判断一段文本所表达的情绪状态，属于文本分类问题。情绪：正面/负面</code></pre><!--more--><h4 id="数据集介绍："><a href="#数据集介绍：" class="headerlink" title="数据集介绍："></a>数据集介绍：</h4><pre><code>IMDB数据集包含来自互联网的50000条严重两极分化的评论，该数据被分为用于训练的25000条评论和用于测试的25000条评论，训练集和测试集都包含50%的正面评价和50%的负面评价。该数据集已经经过预处理：评论（单词序列）已经被转换为整数序列，其中每个整数代表字典中的某个单词。</code></pre><h1 id="1、准备数据"><a href="#1、准备数据" class="headerlink" title="1、准备数据:"></a><strong>1、准备数据:</strong></h1><p>创建数据读取器train_reader 和test_reader</p><h1 id="2、配置网络"><a href="#2、配置网络" class="headerlink" title="2、配置网络"></a><strong>2、配置网络</strong></h1><p>定义网络</p><p>定义损失函数</p><p>定义优化算法</p><h1 id="3、训练网络"><a href="#3、训练网络" class="headerlink" title="3、训练网络"></a><strong>3、训练网络</strong></h1><h1 id="4、模型评估"><a href="#4、模型评估" class="headerlink" title="4、模型评估"></a><strong>4、模型评估</strong></h1><h1 id="5、模型预测"><a href="#5、模型预测" class="headerlink" title="5、模型预测"></a><strong>5、模型预测</strong></h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入必要的包</span></span><br><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> paddle.dataset.imdb <span class="keyword">as</span> imdb</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> paddle.fluid <span class="keyword">as</span> fluid</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!mkdir -p /home/aistudio/.cache/paddle/dataset/imdb/</span><br><span class="line"></span><br><span class="line">!cp /home/aistudio/data/data69/aclImdb_v1.tar.gz /home/aistudio/.cache/paddle/dataset/imdb/</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取数据字典</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"加载数据字典中..."</span>)</span><br><span class="line"></span><br><span class="line">word_dict = imdb.word_dict()<span class="comment">#这个数据集是一个常用的数据集，已经被paddle封装到底层代码里面了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据字典长度</span></span><br><span class="line"></span><br><span class="line">dict_dim = len(word_dict)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'完成'</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>加载数据字典中...</code></pre><p>​    </p><pre><code>完成</code></pre><p>数据是以数据标签的方式表示一个句子。</p><p>所以每个句子都是以一串整数来表示的，每个数字都是对应一个单词。</p><p>数据集就会有一个数据集字典，这个字典是训练数据中出现单词对应的数字标签。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取训练和预测数据</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"加载训练数据中..."</span>)</span><br><span class="line"></span><br><span class="line">train_reader = paddle.batch(paddle.reader.shuffle(imdb.train(word_dict),</span><br><span class="line"></span><br><span class="line">                                                  <span class="number">512</span>),</span><br><span class="line"></span><br><span class="line">                            batch_size=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"加载测试数据中..."</span>)</span><br><span class="line"></span><br><span class="line">test_reader = paddle.batch(imdb.test(word_dict), </span><br><span class="line"></span><br><span class="line">                           batch_size=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'完成'</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>加载训练数据中...</code></pre><p>​<br>​    </p><pre><code>加载测试数据中...</code></pre><p>​<br>​    </p><pre><code>完成</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9haS1zdHVkaW8tc3RhdGljLW9ubGluZS5jZG4uYmNlYm9zLmNvbS84NTEyYTVjZjkzN2M0YzkxOTM0ZGNhYzcwYzkzYzg3YTdkY2Y0ZDJhNTJhNzRjZTM5ZDdmYTc3Y2E1MDQ3NzFj?x-oss-process=image/format,png" alt=""></p><ul><li>遗忘门：用来控制记忆消失程度。 </li><li>输入门：决定了当前时刻的输入信息，有多少信息将添加到记忆信息流中，与遗忘门计算公式几乎一致，输入门同样通过一个激活函数来实现。</li><li>记忆状态：计算当前输入与过去的记忆所具有的信息总量。</li><li>输出门：控制着有多少记忆信息将被用于下一阶段的更新中。<br>在防止梯度消失的问题上，LSTM效果比RNN要好，<br>随着任务难度的加深，文本序列长度的增加，模型后面一部分可能会丢失原始的信息，就出现了RNN的变体LSTM和GRU。</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义长短期记忆网络</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lstm_net</span><span class="params">(ipt, input_dim)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 以数据的IDs作为输入</span></span><br><span class="line"></span><br><span class="line">    emb = fluid.layers.embedding(input=ipt, size=[input_dim, <span class="number">128</span>], is_sparse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第一个全连接层</span></span><br><span class="line"></span><br><span class="line">    fc1 = fluid.layers.fc(input=emb, size=<span class="number">128</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行一个长短期记忆操作</span></span><br><span class="line"></span><br><span class="line">    lstm1, _ = fluid.layers.dynamic_lstm(input=fc1, <span class="comment">#返回：隐藏状态（hidden state），LSTM的神经元状态</span></span><br><span class="line"></span><br><span class="line">                                         size=<span class="number">128</span>) <span class="comment">#size=4*hidden_size</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第一个最大序列池操作</span></span><br><span class="line"></span><br><span class="line">    fc2 = fluid.layers.sequence_pool(input=fc1, pool_type=<span class="string">'max'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第二个最大序列池操作</span></span><br><span class="line"></span><br><span class="line">    lstm2 = fluid.layers.sequence_pool(input=lstm1, pool_type=<span class="string">'max'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 以softmax作为全连接的输出层，大小为2,也就是正负面</span></span><br><span class="line"></span><br><span class="line">    out = fluid.layers.fc(input=[fc2, lstm2], size=<span class="number">2</span>, act=<span class="string">'softmax'</span>)<span class="comment">#二分类，1x2的概率分布</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></tbody></table></figure><p>这里可以先定义一个输入层，这样要注意的是我们使用的数据属于序列数据，所以我们可以设置lod_level为1，当该参数不为0时，表示输入的数据为序列数据，默认lod_level的值是0.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义输入数据， lod_level不为0指定输入数据为序列数据</span></span><br><span class="line"></span><br><span class="line">words = fluid.layers.data(name=<span class="string">'words'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>, lod_level=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">label = fluid.layers.data(name=<span class="string">'label'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>)<span class="comment">#label：正向或者负向</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取长短期记忆网络</span></span><br><span class="line"></span><br><span class="line">model = lstm_net(words, dict_dim)</span><br></pre></td></tr></tbody></table></figure><p>接着定义损失函数，这里同样是一个分类任务，所以使用的损失函数也是交叉熵损失函数。这里也可以使用fluid.layers.accuracy()接口定义一个输出分类准确率的函数，可以方便在训练的时候，输出测试时的分类准确率，观察模型收敛的情况。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取损失函数和准确率</span></span><br><span class="line"></span><br><span class="line">cost = fluid.layers.cross_entropy(input=model, label=label)</span><br><span class="line"></span><br><span class="line">avg_cost = fluid.layers.mean(cost)</span><br><span class="line"></span><br><span class="line">acc = fluid.layers.accuracy(input=model, label=label)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取预测程序</span></span><br><span class="line"></span><br><span class="line">test_program = fluid.default_main_program().clone(for_test=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure><p>然后是定义优化方法，这里使用的时Adagrad优化方法，Adagrad优化方法多用于处理稀疏数据，设置学习率为0.002。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义优化方法</span></span><br><span class="line"></span><br><span class="line">optimizer = fluid.optimizer.AdagradOptimizer(learning_rate=<span class="number">0.002</span>)</span><br><span class="line"></span><br><span class="line">opt = optimizer.minimize(avg_cost)</span><br></pre></td></tr></tbody></table></figure><p>如果读取有GPU环境，可以尝试使用GPU来训练，使用方式是使用fluid.CUDAPlace(0)来创建。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义使用CPU还是GPU，使用CPU时use_cuda = False,使用GPU时use_cuda = True</span></span><br><span class="line">use_cuda = <span class="literal">True</span></span><br><span class="line">place = fluid.CUDAPlace(<span class="number">0</span>) <span class="keyword">if</span> use_cuda <span class="keyword">else</span> fluid.CPUPlace()</span><br><span class="line">exe = fluid.Executor(place)</span><br><span class="line"><span class="comment"># 进行参数初始化</span></span><br><span class="line">exe.run(fluid.default_startup_program())</span><br></pre></td></tr></tbody></table></figure><pre><code>[]</code></pre><p>定义数据数据的维度，数据的顺序是一条句子数据对应一个标签。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义输入数据的维度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据数据的维度，数据的顺序是一条句子数据对应一个标签</span></span><br><span class="line"></span><br><span class="line">feeder = fluid.DataFeeder(place=place, feed_list=[words, label])</span><br></pre></td></tr></tbody></table></figure><p>现在就可以开始训练了，这里设置训练的循环是2次，大家可以根据情况设置更多的训练轮数。我们在训练中，每40个Batch打印一层训练信息和进行一次测试，测试是使用测试集进行预测并输出损失值和准确率，测试完成之后，对之前预测的结果进行求平均值。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始训练</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pass_id <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行训练</span></span><br><span class="line"></span><br><span class="line">    train_cost = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> enumerate(train_reader()):              <span class="comment">#遍历train_reader迭代器</span></span><br><span class="line"></span><br><span class="line">        train_cost = exe.run(program=fluid.default_main_program(),<span class="comment">#运行主程序</span></span><br><span class="line"></span><br><span class="line">                             feed=feeder.feed(data),              <span class="comment">#喂入一个batch的数据</span></span><br><span class="line"></span><br><span class="line">                             fetch_list=[avg_cost])               <span class="comment">#fetch均方误差</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_id % <span class="number">40</span> == <span class="number">0</span>:                 <span class="comment">#每40次batch打印一次训练、进行一次测试</span></span><br><span class="line"></span><br><span class="line">            print(<span class="string">'Pass:%d, Batch:%d, Cost:%0.5f'</span> % (pass_id, batch_id, train_cost[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进行测试</span></span><br><span class="line"></span><br><span class="line">    test_costs = []   <span class="comment">#测试的损失值</span></span><br><span class="line"></span><br><span class="line">    test_accs = []    <span class="comment">#测试的准确率</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> enumerate(test_reader()):</span><br><span class="line"></span><br><span class="line">        test_cost, test_acc = exe.run(program=test_program,</span><br><span class="line"></span><br><span class="line">                                            feed=feeder.feed(data),</span><br><span class="line"></span><br><span class="line">                                             fetch_list=[avg_cost, acc])</span><br><span class="line"></span><br><span class="line">        test_costs.append(test_cost[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        test_accs.append(test_acc[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算平均预测损失在和准确率</span></span><br><span class="line"></span><br><span class="line">    test_cost = (sum(test_costs) / len(test_costs))</span><br><span class="line"></span><br><span class="line">    test_acc = (sum(test_accs) / len(test_accs))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'Test:%d, Cost:%0.5f, ACC:%0.5f'</span> % (pass_id, test_cost, test_acc))</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存模型</span></span><br><span class="line"></span><br><span class="line">model_save_dir = <span class="string">"/home/aistudio/work/emotionclassify.inference.model"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果保存路径不存在就创建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(model_save_dir):</span><br><span class="line"></span><br><span class="line">    os.makedirs(model_save_dir)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (<span class="string">'save models to %s'</span> % (model_save_dir))</span><br><span class="line"></span><br><span class="line">fluid.io.save_inference_model(model_save_dir, <span class="comment">#保存推理model的路径</span></span><br><span class="line"></span><br><span class="line">                                  [<span class="string">'words'</span>],      <span class="comment">#推理（inference）需要 feed 的数据</span></span><br><span class="line"></span><br><span class="line">                                  [model],         <span class="comment">#保存推理（inference）结果的 Variables</span></span><br><span class="line"></span><br><span class="line">                                  exe)            <span class="comment">#exe 保存 inference model</span></span><br></pre></td></tr></tbody></table></figure><pre><code>Pass:0, Batch:0, Cost:0.73125Pass:0, Batch:40, Cost:0.06795Pass:0, Batch:80, Cost:0.00722Pass:0, Batch:120, Cost:0.80844Pass:0, Batch:160, Cost:0.22205Test:0, Cost:1.12195, ACC:0.50171Pass:1, Batch:0, Cost:2.13347Pass:1, Batch:40, Cost:0.48804Pass:1, Batch:80, Cost:0.21535Pass:1, Batch:120, Cost:0.81571Pass:1, Batch:160, Cost:0.33186Test:1, Cost:0.83362, ACC:0.50191Pass:2, Batch:0, Cost:1.40742Pass:2, Batch:40, Cost:0.55047Pass:2, Batch:80, Cost:0.27269Pass:2, Batch:120, Cost:0.74456Pass:2, Batch:160, Cost:0.35957Test:2, Cost:0.71608, ACC:0.50769Pass:3, Batch:0, Cost:1.12344Pass:3, Batch:40, Cost:0.55675Pass:3, Batch:80, Cost:0.30137Pass:3, Batch:120, Cost:0.67230Pass:3, Batch:160, Cost:0.35690Test:3, Cost:0.63739, ACC:0.54560Pass:4, Batch:0, Cost:0.98897Pass:4, Batch:40, Cost:0.55052Pass:4, Batch:80, Cost:0.29672Pass:4, Batch:120, Cost:0.59823Pass:4, Batch:160, Cost:0.35738Test:4, Cost:0.57975, ACC:0.61902Pass:5, Batch:0, Cost:0.80312Pass:5, Batch:40, Cost:0.50581Pass:5, Batch:80, Cost:0.27092Pass:5, Batch:120, Cost:0.55160Pass:5, Batch:160, Cost:0.32211Test:5, Cost:0.53265, ACC:0.69416Pass:6, Batch:0, Cost:0.70552Pass:6, Batch:40, Cost:0.49984Pass:6, Batch:80, Cost:0.27171Pass:6, Batch:120, Cost:0.52073Pass:6, Batch:160, Cost:0.31178Test:6, Cost:0.49651, ACC:0.74736Pass:7, Batch:0, Cost:0.69794Pass:7, Batch:40, Cost:0.50185Pass:7, Batch:80, Cost:0.27300Pass:7, Batch:120, Cost:0.46273Pass:7, Batch:160, Cost:0.35845Test:7, Cost:0.46813, ACC:0.78116Pass:8, Batch:0, Cost:0.61882Pass:8, Batch:40, Cost:0.45831Pass:8, Batch:80, Cost:0.27965Pass:8, Batch:120, Cost:0.44373Pass:8, Batch:160, Cost:0.30215Test:8, Cost:0.44874, ACC:0.80029Pass:9, Batch:0, Cost:0.60523Pass:9, Batch:40, Cost:0.47129Pass:9, Batch:80, Cost:0.22142Pass:9, Batch:120, Cost:0.39324Pass:9, Batch:160, Cost:0.26854Test:9, Cost:0.43634, ACC:0.80823save models to /home/aistudio/work/emotionclassify.inference.model['save_infer_model/scale_0']</code></pre><p>我们先定义三个句子，第一句是中性的，第二句偏向正面，第三句偏向负面。然后把这些句子读取到一个列表中。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义预测数据</span></span><br><span class="line"></span><br><span class="line">reviews_str = [<span class="string">'read the book forget the movie'</span>, <span class="string">'this is a great movie'</span>, <span class="string">'this is very bad'</span>]<span class="comment">#第一句是中性，第二句是正向，第三局是负向</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把每个句子拆成一个个单词</span></span><br><span class="line"></span><br><span class="line">reviews = [c.split() <span class="keyword">for</span> c <span class="keyword">in</span> reviews_str]</span><br></pre></td></tr></tbody></table></figure><p>然后把句子转换成编码，根据数据集的字典，把句子中的单词转换成对应标签。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取结束符号的标签</span></span><br><span class="line"></span><br><span class="line">UNK = word_dict[<span class="string">'&lt;unk&gt;'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每句话对应的标签</span></span><br><span class="line"></span><br><span class="line">lod = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> reviews:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 需要把单词进行字符串编码转换</span></span><br><span class="line"></span><br><span class="line">    lod.append([word_dict.get(words.encode(<span class="string">'utf-8'</span>), UNK) <span class="keyword">for</span> words <span class="keyword">in</span> c])</span><br></pre></td></tr></tbody></table></figure><p>获取输入数据的维度和大小。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取每句话的单词数量</span></span><br><span class="line"></span><br><span class="line">base_shape = [[len(c) <span class="keyword">for</span> c <span class="keyword">in</span> lod]]</span><br></pre></td></tr></tbody></table></figure><p>将要预测的数据转换成张量，准备开始预测。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成预测数据</span></span><br><span class="line"></span><br><span class="line">tensor_words = fluid.create_lod_tensor(lod, base_shape, place)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">infer_exe = fluid.Executor(place)    <span class="comment">#创建推测用的executor</span></span><br><span class="line"></span><br><span class="line">inference_scope = fluid.core.Scope() <span class="comment">#Scope指定作用域</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> fluid.scope_guard(inference_scope):<span class="comment">#修改全局/默认作用域（scope）, 运行时中的所有变量都将分配给新的scope。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#从指定目录中加载 推理model(inference model)</span></span><br><span class="line"></span><br><span class="line">    [inference_program,                                            <span class="comment">#推理的program</span></span><br><span class="line"></span><br><span class="line">     feed_target_names,                                            <span class="comment">#str列表，包含需要在推理program中提供数据的变量名称</span></span><br><span class="line"></span><br><span class="line">     fetch_targets] = fluid.io.load_inference_model(model_save_dir,<span class="comment">#fetch_targets: 推断结果，model_save_dir:模型训练路径 </span></span><br><span class="line"></span><br><span class="line">                                                        infer_exe) <span class="comment">#infer_exe: 运行 inference model的 executor</span></span><br><span class="line"></span><br><span class="line">    results = infer_exe.run(inference_program,                                 <span class="comment">#运行预测程序</span></span><br><span class="line"></span><br><span class="line">                            feed={feed_target_names[<span class="number">0</span>]: tensor_words},<span class="comment">#喂入要预测的x值</span></span><br><span class="line"></span><br><span class="line">                            fetch_list=fetch_targets)                           <span class="comment">#得到推测结果 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印每句话的正负面概率</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, r <span class="keyword">in</span> enumerate(results[<span class="number">0</span>]):</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"\'%s\'的预测结果为：正面概率为：%0.5f，负面概率为：%0.5f"</span> % (reviews_str[i], r[<span class="number">0</span>], r[<span class="number">1</span>]))</span><br></pre></td></tr></tbody></table></figure><pre><code>'read the book forget the movie'的预测结果为：正面概率为：0.54671，负面概率为：0.45329'this is a great movie'的预测结果为：正面概率为：0.62144，负面概率为：0.37856'this is very bad'的预测结果为：正面概率为：0.37344，负面概率为：0.62656</code></pre><p>预测结果显示这个模型的预测较为准确，输出结果符合人类观察的预期；可以继续调整网络参数、结构，使其能够更好的对文本进行情感分类。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> NLP 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python 机器学习 paddle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP入门-文本分类|paddle</title>
      <link href="/posts/ac4f.html"/>
      <url>/posts/ac4f.html</url>
      
        <content type="html"><![CDATA[<h4 id="文本分类：自然语言处理领域中的一个经典问题，文本分类是利用电脑对文本按照一定的分类体系进行自动分类标记。"><a href="#文本分类：自然语言处理领域中的一个经典问题，文本分类是利用电脑对文本按照一定的分类体系进行自动分类标记。" class="headerlink" title="文本分类：自然语言处理领域中的一个经典问题，文本分类是利用电脑对文本按照一定的分类体系进行自动分类标记。"></a>文本分类：自然语言处理领域中的一个经典问题，文本分类是利用电脑对文本按照一定的分类体系进行自动分类标记。</h4><blockquote><ul><li>数据来源：从网站上爬取56821条数据中文新闻摘要<ul><li>数据内容：包含10种类别，国际、文化、娱乐、体育、财经、汽车、教育、科技、房产、证券</li></ul></li></ul></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9haS1zdHVkaW8tc3RhdGljLW9ubGluZS5jZG4uYmNlYm9zLmNvbS8xNzg5ZWQ1OTM5ZDI0MTM0YjljZTRkNDVjYTE1ZTBmZGYyMWYyNWFhNDAwYzRmNjg5OGNjNGUwMmFlYTVjNzRl?x-oss-process=image/format,png" alt=""><br>严格意义上来说这个新闻的数据集不是太好，每个类目的新闻数目不是一致的，一个好的数据集对于各个类别分布是比较均匀的。</p><a id="more"></a><h1 id="1、准备数据"><a href="#1、准备数据" class="headerlink" title="1、准备数据:"></a><strong>1、准备数据:</strong></h1><pre><code>数据进行预处理创建数据集和数据字典创建数据读取器train_reader 和test_reader</code></pre><h1 id="2、配置网络"><a href="#2、配置网络" class="headerlink" title="2、配置网络"></a><strong>2、配置网络</strong></h1><p>定义网络</p><p>定义损失函数：交叉熵损失函数</p><p>定义优化算法：选择优化器，adam，SGD等等</p><h1 id="3、训练网络"><a href="#3、训练网络" class="headerlink" title="3、训练网络"></a><strong>3、训练网络</strong></h1><p>需要对网络进行训练，丢入训练集，去训练我们的模型</p><h1 id="4、模型评估"><a href="#4、模型评估" class="headerlink" title="4、模型评估"></a><strong>4、模型评估</strong></h1><h1 id="5、模型预测"><a href="#5、模型预测" class="headerlink" title="5、模型预测"></a><strong>5、模型预测</strong></h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前挂载的数据集目录</span></span><br><span class="line">!ls /home/aistudio/data/</span><br><span class="line"><span class="comment">#将数据移动到 /home/aistudio/data/ 目录下</span></span><br><span class="line">!cp data/data6825/news_classify_data.txt data/</span><br></pre></td></tr></tbody></table></figure><pre><code>data6825</code></pre><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9haS1zdHVkaW8tc3RhdGljLW9ubGluZS5jZG4uYmNlYm9zLmNvbS81NGE4MzIxZWNkMDg0YWU1YjY1OWQ3M2IwYjFlNThiYzFlNDU4MzVkMDdiMjQyZTFhMmZjNWI0NmJiYWU3N2Yx?x-oss-process=image/format,png" alt=""></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入必要的包</span></span><br><span class="line"><span class="keyword">import</span> os  <span class="comment">#系统操作包</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> cpu_count</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment">#计算包</span></span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> paddle <span class="comment">#paddle的工具包</span></span><br><span class="line"><span class="keyword">import</span> paddle.fluid <span class="keyword">as</span> fluid</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据集和数据字典</span></span><br><span class="line"></span><br><span class="line">data_root_path=<span class="string">'/home/aistudio/data/'</span> <span class="comment">#选择数据路径</span></span><br><span class="line"><span class="comment">#对我们读取出来的路径创建数据词典</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_data_list</span><span class="params">(data_root_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(data_root_path + <span class="string">'test_list.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">with</span> open(data_root_path + <span class="string">'train_list.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(os.path.join(data_root_path, <span class="string">'dict_txt.txt'</span>), <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f_data:</span><br><span class="line">        dict_txt = eval(f_data.readlines()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(os.path.join(data_root_path, <span class="string">'news_classify_data.txt'</span>), <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f_data:</span><br><span class="line">        lines = f_data.readlines()</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        title = line.split(<span class="string">'_!_'</span>)[<span class="number">-1</span>].replace(<span class="string">'\n'</span>, <span class="string">''</span>)</span><br><span class="line">        l = line.split(<span class="string">'_!_'</span>)[<span class="number">1</span>]</span><br><span class="line">        labs = <span class="string">""</span></span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">with</span> open(os.path.join(data_root_path, <span class="string">'test_list.txt'</span>), <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f_test:</span><br><span class="line">                <span class="keyword">for</span> s <span class="keyword">in</span> title:</span><br><span class="line">                    lab = str(dict_txt[s])</span><br><span class="line">                    labs = labs + lab + <span class="string">','</span></span><br><span class="line">                labs = labs[:<span class="number">-1</span>]</span><br><span class="line">                labs = labs + <span class="string">'\t'</span> + l + <span class="string">'\n'</span></span><br><span class="line">                f_test.write(labs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">with</span> open(os.path.join(data_root_path, <span class="string">'train_list.txt'</span>), <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f_train:</span><br><span class="line">                <span class="keyword">for</span> s <span class="keyword">in</span> title:</span><br><span class="line">                    lab = str(dict_txt[s])</span><br><span class="line">                    labs = labs + lab + <span class="string">','</span></span><br><span class="line">                labs = labs[:<span class="number">-1</span>]</span><br><span class="line">                labs = labs + <span class="string">'\t'</span> + l + <span class="string">'\n'</span></span><br><span class="line">                f_train.write(labs)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    print(<span class="string">"数据列表生成完成！"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把下载得数据生成一个字典</span></span><br><span class="line"><span class="comment">#将每一个文本每一个子映射到词典得到一个数字ID，因为输入到模型里面的不是汉字，是一个数字ID</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_dict</span><span class="params">(data_path, dict_path)</span>:</span></span><br><span class="line">    dict_set = set()</span><br><span class="line">    <span class="comment"># 读取已经下载得数据</span></span><br><span class="line">    <span class="keyword">with</span> open(data_path, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    <span class="comment"># 把数据生成一个元组</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        title = line.split(<span class="string">'_!_'</span>)[<span class="number">-1</span>].replace(<span class="string">'\n'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> title:</span><br><span class="line">            dict_set.add(s)</span><br><span class="line">    <span class="comment"># 把元组转换成字典，一个字对应一个数字</span></span><br><span class="line">    dict_list = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> dict_set:</span><br><span class="line">        dict_list.append([s, i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 添加未知字符</span></span><br><span class="line">    dict_txt = dict(dict_list)</span><br><span class="line">    end_dict = {<span class="string">"&lt;unk&gt;"</span>: i}</span><br><span class="line">    dict_txt.update(end_dict)</span><br><span class="line">    <span class="comment"># 把这些字典保存到本地中</span></span><br><span class="line">    <span class="keyword">with</span> open(dict_path, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(str(dict_txt))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"数据字典生成完成！"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取字典的长度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dict_len</span><span class="params">(dict_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(dict_path, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        line = eval(f.readlines()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len(line.keys())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 把生产的数据列表都放在自己的总类别文件夹中</span></span><br><span class="line">    data_root_path = <span class="string">"/home/aistudio/data/"</span></span><br><span class="line">    data_path = os.path.join(data_root_path, <span class="string">'news_classify_data.txt'</span>)</span><br><span class="line">    dict_path = os.path.join(data_root_path, <span class="string">"dict_txt.txt"</span>)</span><br><span class="line">    <span class="comment"># 创建数据字典</span></span><br><span class="line">    create_dict(data_path, dict_path)</span><br><span class="line">    <span class="comment"># 创建数据列表</span></span><br><span class="line">    create_data_list(data_root_path)</span><br></pre></td></tr></tbody></table></figure><pre><code>数据字典生成完成！数据列表生成完成！</code></pre><p>创建好的字典：每一个字会对应一个数字ID<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9haS1zdHVkaW8tc3RhdGljLW9ubGluZS5jZG4uYmNlYm9zLmNvbS9lY2FkN2I3MTYzMzM0NjQ4YjE3NDkyOWEwM2M5NjI0Yjg2MGI5MjI0YjhhODRlMDg4MTZjMWU5MTQ2YjA2ZDkz?x-oss-process=image/format,png" alt=""></p><p>创建好的数据列表：文本转化为序列化的表示</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9haS1zdHVkaW8tc3RhdGljLW9ubGluZS5jZG4uYmNlYm9zLmNvbS84NDNkNTE3MjhlMDY0N2E3OWZhODNmYzdjZWRiY2NiZjliOGU1YjlhZGFhYjQyZGI5MGE0MTRkMDAzYTM1ZGQ4?x-oss-process=image/format,png" alt=""><br>每一行代表一句新闻，就是一个样本。</p><p>paddle.reader.xmap_readers():通过多线程方式，通过用户自定义的映射器mapper来映射reader返回的样本（到输出队列)。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据读取器train_reader 和test_reader</span></span><br><span class="line"><span class="comment"># 训练/测试数据的预处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_mapper</span><span class="params">(sample)</span>:</span></span><br><span class="line">    data, label = sample</span><br><span class="line">    data = [int(data) <span class="keyword">for</span> data <span class="keyword">in</span> data.split(<span class="string">','</span>)]</span><br><span class="line">    <span class="keyword">return</span> data, int(label)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据读取器train_reader</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_reader</span><span class="params">(train_list_path)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(train_list_path, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            lines = f.readlines()</span><br><span class="line">            <span class="comment"># 打乱数据</span></span><br><span class="line">            np.random.shuffle(lines)</span><br><span class="line">            <span class="comment"># 开始获取每张图像和标签</span></span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">                data, label = line.split(<span class="string">'\t'</span>)</span><br><span class="line">                <span class="keyword">yield</span> data, label</span><br><span class="line">    <span class="keyword">return</span> paddle.reader.xmap_readers(data_mapper, reader, cpu_count(), <span class="number">1024</span>)</span><br><span class="line"><span class="comment">#  创建数据读取器test_reader</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_reader</span><span class="params">(test_list_path)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(test_list_path, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            lines = f.readlines()</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">                data, label = line.split(<span class="string">'\t'</span>)</span><br><span class="line">                <span class="keyword">yield</span> data, label</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> paddle.reader.xmap_readers(data_mapper, reader, cpu_count(), <span class="number">1024</span>)</span><br></pre></td></tr></tbody></table></figure><p>至此，数据准备工作已经完成了。 </p><h1 id="卷积神经网络（Convolutional-Neural-Networks-CNN）"><a href="#卷积神经网络（Convolutional-Neural-Networks-CNN）" class="headerlink" title="卷积神经网络（Convolutional Neural Networks, CNN）"></a>卷积神经网络（Convolutional Neural Networks, CNN）</h1><p>输入词向量序列，产生一个特征图（feature map），对特征图采用时间维度上的最大池化（max pooling over time）操作得到此卷积核对应的整句话的特征，最后，将所有卷积核得到的特征拼接起来即为文本的定长向量表示，对于文本分类问题，将其连接至softmax即构建出完整的模型。</p><p>在实际应用中，我们会使用多个卷积核来处理句子，窗口大小相同的卷积核堆叠起来形成一个矩阵，这样可以更高效的完成运算。</p><p>另外，我们也可使用窗口大小不同的卷积核来处理句子.</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9haS1zdHVkaW8tc3RhdGljLW9ubGluZS5jZG4uYmNlYm9zLmNvbS8zNzY2MjYxZjI0YjU0NTE0YjZjYmMwZDMwMjcwYzZhM2YzOGMxZDBhYWY4ZjQ1MGM5N2U4MzAzZWNhNTFmMjA0?x-oss-process=image/format,png" alt=""></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建CNN网络</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CNN_net</span><span class="params">(data,dict_dim, class_dim=<span class="number">10</span>, emb_dim=<span class="number">128</span>, hid_dim=<span class="number">128</span>,hid_dim2=<span class="number">98</span>)</span>:</span></span><br><span class="line">        emb = fluid.layers.embedding(input=data,<span class="comment">#进模型之前需要得到一个emb词嵌入，得到一个矩阵的编码</span></span><br><span class="line">                                 size=[dict_dim, emb_dim])</span><br><span class="line">        conv_3 = fluid.nets.sequence_conv_pool(</span><br><span class="line">                                                 input=emb,</span><br><span class="line">                                                 num_filters=hid_dim,</span><br><span class="line">                                                 filter_size=<span class="number">3</span>,<span class="comment">#卷积核</span></span><br><span class="line">                                                 act=<span class="string">"tanh"</span>,</span><br><span class="line">                                                 pool_type=<span class="string">"sqrt"</span>)</span><br><span class="line">        conv_4 = fluid.nets.sequence_conv_pool(</span><br><span class="line">                                                 input=emb,</span><br><span class="line">                                                 num_filters=hid_dim2,</span><br><span class="line">                                                 filter_size=<span class="number">4</span>,</span><br><span class="line">                                                 act=<span class="string">"tanh"</span>,</span><br><span class="line">                                                 pool_type=<span class="string">"sqrt"</span>)</span><br><span class="line">                                                 </span><br><span class="line">        output = fluid.layers.fc(</span><br><span class="line">            input=[conv_3, conv_4], size=class_dim, act=<span class="string">'softmax'</span>)<span class="comment">#经过全连接层，将两个cnn的结果拼接起来</span></span><br><span class="line">        <span class="keyword">return</span> output<span class="comment">#1x10的概率分布的矩阵，10个数，概率最大的数就是当前模型的预测结果</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义输入数据， lod_level不为0指定输入数据为序列数据</span></span><br><span class="line">words = fluid.layers.data(name=<span class="string">'words'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>, lod_level=<span class="number">1</span>)<span class="comment">#lod_level 处理变长序列，paddle官网的文档中LoDtensor lodlayer的索引 定长的数据不需要考虑这个问题</span></span><br><span class="line">label = fluid.layers.data(name=<span class="string">'label'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int64'</span>)</span><br><span class="line"><span class="comment"># 获取数据字典长度</span></span><br><span class="line">dict_dim = get_dict_len(<span class="string">'/home/aistudio/data/dict_txt.txt'</span>)</span><br><span class="line"><span class="comment"># 获取卷积神经网络</span></span><br><span class="line"><span class="comment"># model = CNN_net(words, dict_dim, 15)</span></span><br><span class="line"><span class="comment"># 获取分类器</span></span><br><span class="line">model = CNN_net(words, dict_dim)</span><br><span class="line"><span class="comment"># 获取损失函数和准确率</span></span><br><span class="line">cost = fluid.layers.cross_entropy(input=model, label=label)<span class="comment">#损失函数</span></span><br><span class="line">avg_cost = fluid.layers.mean(cost)<span class="comment">#每次训练都是一个batch，求一个平均</span></span><br><span class="line">acc = fluid.layers.accuracy(input=model, label=label)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取预测程序</span></span><br><span class="line">test_program = fluid.default_main_program().clone(for_test=<span class="literal">True</span>)<span class="comment">#clone克隆函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义优化方法</span></span><br><span class="line">optimizer = fluid.optimizer.AdagradOptimizer(learning_rate=<span class="number">0.002</span>)</span><br><span class="line">opt = optimizer.minimize(avg_cost)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个执行器，CPU训练速度比较慢</span></span><br><span class="line"><span class="comment">#place = fluid.CPUPlace()</span></span><br><span class="line">place = fluid.CUDAPlace(<span class="number">0</span>)<span class="comment">#GPU执行</span></span><br><span class="line">exe = fluid.Executor(place)</span><br><span class="line"><span class="comment"># 进行参数初始化</span></span><br><span class="line">exe.run(fluid.default_startup_program())</span><br></pre></td></tr></tbody></table></figure><pre><code>[]</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取训练数据读取器和测试数据读取器</span></span><br><span class="line">train_reader = paddle.batch(reader=train_reader(<span class="string">'/home/aistudio/data/train_list.txt'</span>), batch_size=<span class="number">128</span>)</span><br><span class="line">test_reader = paddle.batch(reader=test_reader(<span class="string">'/home/aistudio/data/test_list.txt'</span>), batch_size=<span class="number">128</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义数据映射器</span></span><br><span class="line">feeder = fluid.DataFeeder(place=place, feed_list=[words, label])</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">EPOCH_NUM=<span class="number">20</span><span class="comment">#迭代次数</span></span><br><span class="line">model_save_dir = <span class="string">'/home/aistudio/work/infer_model/'</span></span><br><span class="line"><span class="comment"># 开始训练</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pass_id <span class="keyword">in</span> range(EPOCH_NUM):</span><br><span class="line">    <span class="comment"># 进行训练</span></span><br><span class="line">    <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> enumerate(train_reader()):</span><br><span class="line">        train_cost, train_acc = exe.run(program=fluid.default_main_program(),</span><br><span class="line">                             feed=feeder.feed(data),</span><br><span class="line">                             fetch_list=[avg_cost, acc])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> batch_id % <span class="number">100</span> == <span class="number">0</span>:<span class="comment">#每执行100次，打印一次</span></span><br><span class="line">            print(<span class="string">'Pass:%d, Batch:%d, Cost:%0.5f, Acc:%0.5f'</span> % (pass_id, batch_id, train_cost[<span class="number">0</span>], train_acc[<span class="number">0</span>]))</span><br><span class="line">    <span class="comment"># 进行测试，读入一批陌生的数据，模型没有见过的数据，</span></span><br><span class="line">    test_costs = []</span><br><span class="line">    test_accs = []</span><br><span class="line">    <span class="keyword">for</span> batch_id, data <span class="keyword">in</span> enumerate(test_reader()):</span><br><span class="line">        test_cost, test_acc = exe.run(program=test_program,</span><br><span class="line">                                              feed=feeder.feed(data),</span><br><span class="line">                                              fetch_list=[avg_cost, acc])</span><br><span class="line">        test_costs.append(test_cost[<span class="number">0</span>])</span><br><span class="line">        test_accs.append(test_acc[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 计算平均预测损失在和准确率</span></span><br><span class="line">    test_cost = (sum(test_costs) / len(test_costs))</span><br><span class="line">    test_acc = (sum(test_accs) / len(test_accs))</span><br><span class="line">    print(<span class="string">'Test:%d, Cost:%0.5f, ACC:%0.5f'</span> % (pass_id, test_cost, test_acc))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存预测模型，可以考虑将这段保存模型的代码放到for循环里面，将每一轮的模型都保存起来</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(model_save_dir): </span><br><span class="line">    os.makedirs(model_save_dir) </span><br><span class="line">fluid.io.save_inference_model(model_save_dir, </span><br><span class="line">                            feeded_var_names=[words.name], </span><br><span class="line">                            target_vars=[model], </span><br><span class="line">                            executor=exe)</span><br><span class="line">print(<span class="string">'训练模型保存完成！'</span>)</span><br></pre></td></tr></tbody></table></figure><pre><code>Pass:0, Batch:0, Cost:2.30681, Acc:0.09375Pass:0, Batch:100, Cost:0.99743, Acc:0.68750Pass:0, Batch:200, Cost:0.89360, Acc:0.76562Pass:0, Batch:300, Cost:0.92248, Acc:0.70312Test:0, Cost:0.81883, ACC:0.73921Pass:1, Batch:0, Cost:0.90457, Acc:0.67969Pass:1, Batch:100, Cost:0.67305, Acc:0.83594Pass:1, Batch:200, Cost:0.63098, Acc:0.80469Pass:1, Batch:300, Cost:0.76019, Acc:0.77344Test:1, Cost:0.75819, ACC:0.75909Pass:2, Batch:0, Cost:0.73232, Acc:0.76562Pass:2, Batch:100, Cost:0.70476, Acc:0.77344Pass:2, Batch:200, Cost:0.71542, Acc:0.75781Pass:2, Batch:300, Cost:0.63258, Acc:0.78125Test:2, Cost:0.73717, ACC:0.76160Pass:3, Batch:0, Cost:0.56025, Acc:0.82812Pass:3, Batch:100, Cost:0.48580, Acc:0.86719Pass:3, Batch:200, Cost:0.54991, Acc:0.84375Pass:3, Batch:300, Cost:0.67272, Acc:0.78906Test:3, Cost:0.72726, ACC:0.76317Pass:4, Batch:0, Cost:0.53660, Acc:0.82812Pass:4, Batch:100, Cost:0.73550, Acc:0.78906Pass:4, Batch:200, Cost:0.53774, Acc:0.80469Pass:4, Batch:300, Cost:0.46155, Acc:0.85156Test:4, Cost:0.72185, ACC:0.76169Pass:5, Batch:0, Cost:0.65421, Acc:0.78906Pass:5, Batch:100, Cost:0.59889, Acc:0.80469Pass:5, Batch:200, Cost:0.71301, Acc:0.79688Pass:5, Batch:300, Cost:0.69682, Acc:0.81250Test:5, Cost:0.71626, ACC:0.76525Pass:6, Batch:0, Cost:0.72434, Acc:0.75000Pass:6, Batch:100, Cost:0.59109, Acc:0.77344Pass:6, Batch:200, Cost:0.48783, Acc:0.81250Pass:6, Batch:300, Cost:0.57463, Acc:0.81250Test:6, Cost:0.71520, ACC:0.76447Pass:7, Batch:0, Cost:0.50502, Acc:0.84375Pass:7, Batch:100, Cost:0.62133, Acc:0.79688Pass:7, Batch:200, Cost:0.68593, Acc:0.76562Pass:7, Batch:300, Cost:0.55528, Acc:0.80469Test:7, Cost:0.71300, ACC:0.76769Pass:8, Batch:0, Cost:0.60046, Acc:0.76562Pass:8, Batch:100, Cost:0.47617, Acc:0.82812Pass:8, Batch:200, Cost:0.59591, Acc:0.79688Pass:8, Batch:300, Cost:0.66050, Acc:0.76562Test:8, Cost:0.71475, ACC:0.76594Pass:9, Batch:0, Cost:0.40968, Acc:0.84375Pass:9, Batch:100, Cost:0.50980, Acc:0.81250Pass:9, Batch:200, Cost:0.55923, Acc:0.85156Pass:9, Batch:300, Cost:0.42255, Acc:0.87500Test:9, Cost:0.71282, ACC:0.76717Pass:10, Batch:0, Cost:0.44147, Acc:0.88281Pass:10, Batch:100, Cost:0.55140, Acc:0.85938Pass:10, Batch:200, Cost:0.50935, Acc:0.84375Pass:10, Batch:300, Cost:0.56366, Acc:0.83594Test:10, Cost:0.71520, ACC:0.76586Pass:11, Batch:0, Cost:0.55133, Acc:0.79688Pass:11, Batch:100, Cost:0.45308, Acc:0.80469Pass:11, Batch:200, Cost:0.63471, Acc:0.78125Pass:11, Batch:300, Cost:0.52810, Acc:0.80469Test:11, Cost:0.71511, ACC:0.76673Pass:12, Batch:0, Cost:0.51947, Acc:0.83594Pass:12, Batch:100, Cost:0.63086, Acc:0.80469Pass:12, Batch:200, Cost:0.57166, Acc:0.82812Pass:12, Batch:300, Cost:0.59658, Acc:0.75781Test:12, Cost:0.71533, ACC:0.76673Pass:13, Batch:0, Cost:0.34512, Acc:0.89062Pass:13, Batch:100, Cost:0.47249, Acc:0.82812Pass:13, Batch:200, Cost:0.51224, Acc:0.85156Pass:13, Batch:300, Cost:0.45350, Acc:0.84375Test:13, Cost:0.71736, ACC:0.76647Pass:14, Batch:0, Cost:0.45494, Acc:0.85156Pass:14, Batch:100, Cost:0.68085, Acc:0.78125Pass:14, Batch:200, Cost:0.48124, Acc:0.83594Pass:14, Batch:300, Cost:0.47296, Acc:0.85938Test:14, Cost:0.71745, ACC:0.76760Pass:15, Batch:0, Cost:0.73750, Acc:0.77344Pass:15, Batch:100, Cost:0.55038, Acc:0.83594Pass:15, Batch:200, Cost:0.59775, Acc:0.74219Pass:15, Batch:300, Cost:0.47932, Acc:0.82812Test:15, Cost:0.72163, ACC:0.76673Pass:16, Batch:0, Cost:0.31890, Acc:0.90625Pass:16, Batch:100, Cost:0.38017, Acc:0.85156Pass:16, Batch:200, Cost:0.57517, Acc:0.79688Pass:16, Batch:300, Cost:0.44878, Acc:0.87500Test:16, Cost:0.72158, ACC:0.76786Pass:17, Batch:0, Cost:0.43048, Acc:0.88281Pass:17, Batch:100, Cost:0.47145, Acc:0.82031Pass:17, Batch:200, Cost:0.47934, Acc:0.82812Pass:17, Batch:300, Cost:0.36709, Acc:0.89062Test:17, Cost:0.72381, ACC:0.76647Pass:18, Batch:0, Cost:0.35568, Acc:0.88281Pass:18, Batch:100, Cost:0.61057, Acc:0.82031Pass:18, Batch:200, Cost:0.40052, Acc:0.88281Pass:18, Batch:300, Cost:0.45469, Acc:0.83594Test:18, Cost:0.72549, ACC:0.76743Pass:19, Batch:0, Cost:0.41658, Acc:0.86719Pass:19, Batch:100, Cost:0.48703, Acc:0.86719Pass:19, Batch:200, Cost:0.47010, Acc:0.83594Pass:19, Batch:300, Cost:0.35333, Acc:0.84375Test:19, Cost:0.72887, ACC:0.76690训练模型保存完成！</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用训练好的模型进行预测并输出预测结果</span></span><br><span class="line"><span class="comment"># 创建执行器</span></span><br><span class="line"><span class="comment">#place = fluid.CPUPlace()</span></span><br><span class="line">place = fluid.CUDAPlace(<span class="number">0</span>)</span><br><span class="line">exe = fluid.Executor(place)</span><br><span class="line">exe.run(fluid.default_startup_program())</span><br><span class="line"></span><br><span class="line">save_path = <span class="string">'/home/aistudio/work/infer_model/'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从模型中获取预测程序、输入数据名称列表、分类器</span></span><br><span class="line">[infer_program, feeded_var_names, target_var] = fluid.io.load_inference_model(dirname=save_path, executor=exe)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(sentence)</span>:</span></span><br><span class="line">    <span class="comment"># 读取数据字典</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/home/aistudio/data/dict_txt.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f_data:</span><br><span class="line">        dict_txt = eval(f_data.readlines()[<span class="number">0</span>])</span><br><span class="line">    dict_txt = dict(dict_txt)</span><br><span class="line">    <span class="comment"># 把字符串数据转换成列表数据</span></span><br><span class="line">    keys = dict_txt.keys()</span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> sentence:</span><br><span class="line">        <span class="comment"># 判断是否存在未知字符</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s <span class="keyword">in</span> keys:</span><br><span class="line">            s = <span class="string">'&lt;unk&gt;'</span></span><br><span class="line">        data.append(int(dict_txt[s]))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = []</span><br><span class="line"><span class="comment"># 获取图片数据</span></span><br><span class="line">data1 = get_data(<span class="string">'在获得诺贝尔文学奖7年之后，莫言15日晚间在山西汾阳贾家庄如是说'</span>)</span><br><span class="line">data2 = get_data(<span class="string">'综合“今日美国”、《世界日报》等当地媒体报道，芝加哥河滨警察局表示，'</span>)</span><br><span class="line">data.append(data1)</span><br><span class="line">data.append(data2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取每句话的单词数量</span></span><br><span class="line">base_shape = [[len(c) <span class="keyword">for</span> c <span class="keyword">in</span> data]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成预测数据</span></span><br><span class="line">tensor_words = fluid.create_lod_tensor(data, base_shape, place)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行预测</span></span><br><span class="line">result = exe.run(program=infer_program,</span><br><span class="line">                 feed={feeded_var_names[<span class="number">0</span>]: tensor_words},</span><br><span class="line">                 fetch_list=target_var)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类名称</span></span><br><span class="line">names = [ <span class="string">'文化'</span>, <span class="string">'娱乐'</span>, <span class="string">'体育'</span>, <span class="string">'财经'</span>,<span class="string">'房产'</span>, <span class="string">'汽车'</span>, <span class="string">'教育'</span>, <span class="string">'科技'</span>, <span class="string">'国际'</span>, <span class="string">'证券'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取结果概率最大的label</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">    lab = np.argsort(result)[<span class="number">0</span>][i][<span class="number">-1</span>]<span class="comment">#10个概率值，对其进行排序，选择最大的那个概率，(-1)</span></span><br><span class="line">    print(<span class="string">'预测结果标签为：%d， 名称为：%s， 概率为：%f'</span> % (lab, names[lab], result[<span class="number">0</span>][i][lab]))</span><br></pre></td></tr></tbody></table></figure><pre><code>预测结果标签为：0， 名称为：文化， 概率为：0.949490预测结果标签为：8， 名称为：国际， 概率为：0.472569</code></pre><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> NLP 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成对抗样本的方法|攻击方法</title>
      <link href="/posts/8a27.html"/>
      <url>/posts/8a27.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="对抗样本"><a href="#对抗样本" class="headerlink" title="对抗样本"></a>对抗样本</h2><h3 id="1-Biggio′s-attack"><a href="#1-Biggio′s-attack" class="headerlink" title="1.Biggio′s attack"></a>1.Biggio′s attack</h3><p>Biggio[22]等人首先针对传统机器学习分类器（如SVM和三层全连接神经网络）的MNIST手写数字识别数据集生成对抗样本。<br>它通过优化判别函数来误导分类器。</p><!--more--><h3 id="2-Szegedy′s-limited-memory-BFGS-L-BFGS-attack"><a href="#2-Szegedy′s-limited-memory-BFGS-L-BFGS-attack" class="headerlink" title="2. Szegedy′s limited-memory BFGS (L-BFGS) attack"></a>2. Szegedy′s limited-memory BFGS (L-BFGS) attack</h3><p>Szegedy[8]等人首次证明了可以通过对图像添加小量的人类察觉不到的扰动误导深度神经网络图像分类器做出错误的分类。他们首先尝试求解让神经网络做出误分类的最小扰动的方程。作者认为，深度神经网络所具有的强大的非线性表达能力和模型的过拟合是可能产生对抗性样本原因之一。<br><img src="https://img-blog.csdnimg.cn/20200703112535194.png" alt="在这里插入图片描述"><br>其中，x表示原始图像，x’表示添加微小扰动后的图片，x-x’则表示扰动大小，$\left|x-x^{\prime}\right|_{2}^{2}$表示扰动的L2范数，C()是深度神经网络的分类器。<br>Szegedy等人引入损失函数，即寻找最小的损失函数添加项，使得神经网络做出误分类，这就将此问题转化成了凸优化过程。</p><p>$\min c\left|x-x^{\prime}\right|_{2}^{2}+\mathcal{L}\left(\theta, x^{\prime}, t\right), \quad$ s.t. $\quad x^{\prime} \in[0,1]^{m}$<br>L( , , )计算分类器的loss</p><h3 id="3-Fast-gradient-sign-method-FGSM"><a href="#3-Fast-gradient-sign-method-FGSM" class="headerlink" title="3.Fast gradient sign method (FGSM)"></a>3.Fast gradient sign method (FGSM)</h3><p>Goodfellow等人[9]认为高维空间下深度神经网络的线性线性行为是导致该问题（存在对抗样本）的根本原因。提出了一种一步生成法来快速生成对抗样本，可以有效计算对抗扰动。<br><img src="https://img-blog.csdnimg.cn/20200703141115231.png" alt="在这里插入图片描述"><br>$\eta=\varepsilon \operatorname{sgn}\left(\nabla_{x} \mathcal{L}(\theta, x, t)\right)$<br>$x$：原始图像<br>$\eta$：扰动<br>$\varepsilon$：表示控制扰动大小的自定义参数<br>$\mathcal{L}$：损失函数<br>$\operatorname{sgn}$：符号函数<br>FGSM的核心思想是：通过让扰动方向与梯度方向一致，使损失函数值变化最大，进而使分类器分类结果变化最大。sign函数保证了扰动方向与梯度方向一致；对损失函数求偏导。<br>FGSM 算法优点是只需一步迭代就能生成对抗样本，并且可以通过控制参数$\varepsilon$生成任意$L_{\infty}$范数距离的对抗样本；缺点是扰动自身抗干扰能力不强，容易受到其他噪声的影响； 另外，模型损失函数与模型输入并不是完全线性的，这说明该算法生成的对抗样本扰动不是最优扰动。</p><h3 id="4-DeepFool"><a href="#4-DeepFool" class="headerlink" title="4.DeepFool"></a>4.DeepFool</h3><p>Moosavi-Dezfooli 等人 [32] 通过迭代计算的方法生成能够使分类器模型产生误识别的最小规范对抗扰动，将位于分类边界内的图像逐步推到边界外，直到出现错误分类。作者证明他们生成的扰动比 FGSM 更小，同时有相似的欺骗率。<br>Deepfool 算法生成对抗样本过程与使用 L-BFGS 生成对抗样本过程类似，主要区别是： Deepfool 算法每次迭代都计算当前样本和各决策边界的距离，然后选择向最近的决策边界迭代生成扰动。</p><h3 id="5-Jacobian-based-saliency-map-attack（JSMA）"><a href="#5-Jacobian-based-saliency-map-attack（JSMA）" class="headerlink" title="5.Jacobian-based saliency map attack（JSMA）"></a>5.Jacobian-based saliency map attack（JSMA）</h3><p>基于雅可比矩阵的显着性图攻击（JSMA）[33]介绍了一种基于计分函数F的雅可比矩阵的方法。 通过迭代操纵对模型输出影响最大的像素，可以将其视为贪婪攻击算法。<br>对抗攻击文献中通常使用的方法是限制扰动的 L∞或 L2 范数的值以使对抗样本中的扰动无法被人察觉。但 JSMA[33] 提出了限制 L0 范数的方法，即仅改变几个像素的值，而不是扰动整张图像。</p><h3 id="6-Basic-iterative-method-BIM-Projected-gradient-descent-PGD-attack"><a href="#6-Basic-iterative-method-BIM-Projected-gradient-descent-PGD-attack" class="headerlink" title="6.Basic iterative method (BIM)/Projected gradient descent (PGD) attack"></a>6.Basic iterative method (BIM)/Projected gradient descent (PGD) attack</h3><p>针对 FGSM 算法存在的问题， Kurakin 等人[15,31]在 FGSM 算法基础上提出了一种以多步迭代的方式生成对抗样本的方法 BIM。<br>one-step 方法通过一大步运算增大分类器的损失函数而进行图像扰动，因而可以直接将其扩展为通过多个小步增大损失函数的变体，从而我们得到 Basic Iterative Methods（BIM）</p><h3 id="7-Carlini-amp-Wagner′s-attack（CW）"><a href="#7-Carlini-amp-Wagner′s-attack（CW）" class="headerlink" title="7.Carlini &amp; Wagner′s attack（CW）"></a>7.Carlini &amp; Wagner′s attack（CW）</h3><p>Carlini 和 Wagner[36] 提出了三种对抗攻击方法，通过限制 L∞、L2 和 L0 范数使得扰动无法被察觉。实验证明 defensive distillation （防御性蒸馏）完全无法防御这三种攻击。该算法生成的对抗扰动可以从 unsecured 的网络迁移到 secured 的网络上，从而实现黑盒攻击。<br>C&amp;W是一种基于目标函数优化的对抗样本攻击算法，其核心思想是：假设对抗样本是一个变量，那么要使其成功攻击分类器模型，必须满足两个条件， 一是其与原始样本的距离要尽可能的小，二是其能够误导分类器模型对其进行错误分类。</p><h3 id="8-Ground-truth-attack"><a href="#8-Ground-truth-attack" class="headerlink" title="8.Ground truth attack"></a>8.Ground truth attack</h3><p>Carlini等人[35]试图找到可证明的最强攻击，即找到理论上最小失真的对抗样本的方法。<br>该攻击基于Reluplex [36]，Reluplex是一种用于验证神经网络属性的算法。 它将模型参数F和数据（x,y）编码为线性编程系统的主体，然后求解该系统以检查在x’的邻居中是否存在可以欺骗模型的合格样本x’。 如果我们一直减小搜索区域的半径，直到系统确定不存在一个x’会欺骗模型，那么最后发现的对抗样本被称为标注的真实数据的对抗样本，因为事实证明它与x的相似性最小。<br>Ground truth攻击是计算分类器精确鲁棒性（最小扰动）的第一项工作。但是，该方法涉及使用可满足性模理论（SMT）求解器，（一种复杂算法， 用于检验一系列理论的可满足性），这将使其效率变慢并且无法扩展到大型网络。近期的研究工作[37,38]提高了    Ground truth攻击的效率。</p><p><img src="https://img-blog.csdnimg.cn/20200703104729496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="附录（上述提到算法的论文）"><a href="#附录（上述提到算法的论文）" class="headerlink" title="附录（上述提到算法的论文）"></a>附录（上述提到算法的论文）</h3><ul><li>[22]B. Biggio, I. Corona, D. Maiorca, B. Nelson, N. Šrndić, P. Laskov, G. Giacinto, F. Roli. Evasion attacks against machine learning at test time. In Proceedings of European Conference on Machine Learning and Knowledge Discovery in Databases, Springer, Prague, Czech Republic, pp.387–402, 2013. DOI: 10.1007/978-3-642-40994-3_25</li><li>[8]C. Szegedy, W. Zaremba, I. Sutskever, J. Bruna, D. Erhan, I. Goodfellow, R. Fergus. Intriguing properties of neural networks. ArXiv: 1312.6199, 2013.</li><li>[9]I. J. Goodfellow, J. Shlens, C. Szegedy. Explaining and harnessing adversarial examples. ArXiv: 1412.6572, 2014.</li><li>[32]S. M. Moosavi-Dezfooli, A. Fawzi, P. Frossard. DeepFool:A simple and accurate method to fool deep neural networks. In Proceedings of IEEE Conference on Computer Vision and Pattern Recognition, IEEE, Las Vegas, USA, pp.2574–2582, 2016. DOI: 10.1109/CVPR.2016.282.</li><li>[33]N. Papernot, P. McDaniel, S. Jha, M. Fredrikson, Z. B.Celik, A. Swami. The limitations of deep learning in adversarial settings. In Proceedings of IEEE European Symposium on Security and Privacy, IEEE, Saarbrucken, Germany, pp.372−387, 2016. DOI: 10.1109/EuroSP. 2016.36.</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kaggle-泰坦尼克号生存者预测比赛|初级入门</title>
      <link href="/posts/d25d.html"/>
      <url>/posts/d25d.html</url>
      
        <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>泰坦尼克号的沉没是历史上最臭名昭著的沉船事件之一。1912年4月15日，泰坦尼克号在处女航中撞上冰山沉没，2224名乘客和船员中1502人遇难。这一耸人听闻的悲剧震惊了国际社会，并导致了更好的船舶安全条例。</li><li>沉船造成如此巨大人员伤亡的原因之一是没有足够的救生艇来容纳乘客和船员。虽然在沉船事件中幸存下来也有一些运气的因素，但有些人比其他人更有可能幸存下来，比如妇女、儿童和上层阶级。</li><li>在这个挑战中，我们要求你完成对可能存活下来的人的分析。我们特别要求你们运用机器学习工具来预测哪些乘客在灾难中幸存下来。<br>数据来源：<a href="https://www.kaggle.com/c/titanic/data" target="_blank" rel="noopener">https://www.kaggle.com/c/titanic/data</a></li></ul><a id="more"></a><h3 id="初探数据"><a href="#初探数据" class="headerlink" title="初探数据"></a>初探数据</h3><p>首先看看数据，长什么样</p><p>pandas是常用的python数据处理包，把csv文件读入称dataframe格式，数据分为两部分：训练集和测试集，训练集891行12列，测试集419行11列（无survived列）。<br><img src="https://img-blog.csdnimg.cn/20200626190549962.png" alt="在这里插入图片描述"><br>各列的含义如下：<br>|PassengerId   |乘客ID编号  |<br>|–|–|<br>| Pclass | 乘客等级|<br>|Name   | 姓名 |<br>|Sex   | 性别 |<br>| Age  | 年龄 |<br>| SibSp  |堂兄弟/妹个数  |<br>| Parch  |父母与小孩个数  |<br>| Ticket   |船票信息  |<br>| Fare   |票价  |<br>|Cabin    |客舱  |<br>| Embarked   |登船港口C,Q,S  |</p><h4 id="1-数据初步认识"><a href="#1-数据初步认识" class="headerlink" title="1.数据初步认识"></a>1.数据初步认识</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(df_train.info())</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20200627073604715.png" alt="在这里插入图片描述"><br>上面的数据告诉我们训练集共有891名乘客，但是他们有些属性不全，比如：</p><ul><li>Age属性只有714名乘客有记录</li><li>Cabin则只有204名乘客有记录<br>可以采用pandans中的describe()方法，对数据中的每一列数进行统计分析。得到数值型数据的一些分布（而有些属性比如姓名是文本型，登船港口是类目性，这些用describe()方法是看不到的）<br>df_train.describe()<br><img src="https://img-blog.csdnimg.cn/20200627074330643.png" alt="在这里插入图片描述"><br>上面可以得出，大概有38.3%的人获救了，乘客的平均年龄是29.7岁。<h4 id="2-数据初步分析"><a href="#2-数据初步分析" class="headerlink" title="2.数据初步分析"></a>2.数据初步分析</h4>每个乘客都有这么多属性，如何知道哪些属性更有用，又该如何使用呢。所以我们要知道，对数据的认识非常重要！看看单一/多个属性和最后的survived之间有什么样的关系。<br>下面使用统计学与绘图，了解数据之间的相关性，主要在以下方面：</li><li>1.性别与幸存率的关系</li><li>2.乘客社会等级与幸存率的关系</li><li>3.配偶及兄弟姐妹数与幸存率的关系</li><li>4.父母及子女数与幸存率的关系</li><li>5.年龄与幸存率的关系</li><li>6.Embarked登港港口与幸存率的关系</li><li>7.称呼与幸存率的关系</li><li>8.家庭人数与幸存率的关系</li><li>9.不同船舱的乘客与幸存率的关系<h5 id="2-1性别与幸存率的关系"><a href="#2-1性别与幸存率的关系" class="headerlink" title="2.1性别与幸存率的关系"></a>2.1性别与幸存率的关系</h5><img src="https://img-blog.csdnimg.cn/20200627082626924.png" alt="在这里插入图片描述"><h5 id="2-乘客社会等级与幸存率的关系"><a href="#2-乘客社会等级与幸存率的关系" class="headerlink" title="2.乘客社会等级与幸存率的关系"></a>2.乘客社会等级与幸存率的关系</h5></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.barplot(x=<span class="string">'Pclass'</span>, y=<span class="string">'Survived'</span>, data=train)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20200627082753277.png" alt="在这里插入图片描述"><br>由图看出，乘客社会等级越高，幸存率越高。</p><h5 id="3-配偶及兄弟姐妹数与幸存率的关系"><a href="#3-配偶及兄弟姐妹数与幸存率的关系" class="headerlink" title="3.配偶及兄弟姐妹数与幸存率的关系"></a>3.配偶及兄弟姐妹数与幸存率的关系</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.barplot(x=<span class="string">'SibSp'</span>, y=<span class="string">'Survived'</span>, data=train)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20200627082847917.png" alt="在这里插入图片描述"><br>4.父母及子女数与幸存率的关系</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.barplot(x=<span class="string">'Parch'</span>, y=<span class="string">'Survived'</span>, data=train)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/2020062708292029.png" alt="在这里插入图片描述"><br>父母与子女数适中的乘客幸存率较高</p><h5 id="5-年龄与幸存率的关系"><a href="#5-年龄与幸存率的关系" class="headerlink" title="5.年龄与幸存率的关系"></a>5.年龄与幸存率的关系</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">facet = sns.FacetGrid(train, hue=<span class="string">"Survived"</span>,aspect=<span class="number">2</span>)</span><br><span class="line">facet.map(sns.kdeplot,<span class="string">'Age'</span>,shade= <span class="literal">True</span>)</span><br><span class="line">facet.set(xlim=(<span class="number">0</span>, train[<span class="string">'Age'</span>].max()))</span><br><span class="line">facet.add_legend()</span><br><span class="line">plt.xlabel(<span class="string">'Age'</span>) </span><br><span class="line">plt.ylabel(<span class="string">'density'</span>)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20200627084408414.png" alt="在这里插入图片描述"><br>从不同生还情况的密度图可以看出，在年龄15岁的左侧，生还率有明显差别，密度图非交叉区域面积非常大，但在其他年龄段，则差别不是很明显，认为是随机所致，因此可以考虑将年龄偏小的区域分离出来。</p><h5 id="6-Embarked登港港口与幸存率的关系"><a href="#6-Embarked登港港口与幸存率的关系" class="headerlink" title="6.Embarked登港港口与幸存率的关系"></a>6.Embarked登港港口与幸存率的关系</h5><p>登船港口（Embarked）：</p><ul><li>出发地点：S = 英国南安普顿Southampton</li><li>途径地点1：C = 法国 瑟堡市Cherbourg</li><li>途径地点2：Q = 爱尔兰 昆士敦Queenstown<br><img src="https://img-blog.csdnimg.cn/20200627084910905.png" alt="在这里插入图片描述"><br>由图发现C地的生存率更高。</li></ul><p>7.称呼与幸存率的关系<br>定义以下几种头衔类型，</p><ul><li>Officer政府官员</li><li>Royalty王室（皇室）</li><li>Mr已婚男士</li><li>Mrs已婚妇女</li><li>Miss年轻未婚女子</li><li>Master有技能的人/教师<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">all_data = pd.concat([train, test], ignore_index=<span class="literal">True</span>)</span><br><span class="line">all_data[<span class="string">'Title'</span>] = all_data[<span class="string">'Name'</span>].apply(<span class="keyword">lambda</span> x:x.split(<span class="string">','</span>)[<span class="number">1</span>].split(<span class="string">'.'</span>)[<span class="number">0</span>].strip())</span><br><span class="line">Title_Dict = {}</span><br><span class="line">Title_Dict.update(dict.fromkeys([<span class="string">'Capt'</span>, <span class="string">'Col'</span>, <span class="string">'Major'</span>, <span class="string">'Dr'</span>, <span class="string">'Rev'</span>], <span class="string">'Officer'</span>))</span><br><span class="line">Title_Dict.update(dict.fromkeys([<span class="string">'Don'</span>, <span class="string">'Sir'</span>, <span class="string">'the Countess'</span>, <span class="string">'Dona'</span>, <span class="string">'Lady'</span>], <span class="string">'Royalty'</span>))</span><br><span class="line">Title_Dict.update(dict.fromkeys([<span class="string">'Mme'</span>, <span class="string">'Ms'</span>, <span class="string">'Mrs'</span>], <span class="string">'Mrs'</span>))</span><br><span class="line">Title_Dict.update(dict.fromkeys([<span class="string">'Mlle'</span>, <span class="string">'Miss'</span>], <span class="string">'Miss'</span>))</span><br><span class="line">Title_Dict.update(dict.fromkeys([<span class="string">'Mr'</span>], <span class="string">'Mr'</span>))</span><br><span class="line">Title_Dict.update(dict.fromkeys([<span class="string">'Master'</span>,<span class="string">'Jonkheer'</span>], <span class="string">'Master'</span>))</span><br><span class="line"></span><br><span class="line">all_data[<span class="string">'Title'</span>] = all_data[<span class="string">'Title'</span>].map(Title_Dict)</span><br><span class="line">sns.barplot(x=<span class="string">"Title"</span>, y=<span class="string">"Survived"</span>, data=all_data)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure></li></ul><p><img src="https://img-blog.csdnimg.cn/20200627085132971.png" alt="在这里插入图片描述"></p><p>8.家庭人数与幸存率的关系<br>这里新增FamilyLabel特征，这个特征等于父母儿童+配偶兄弟姐妹+1，在文中就是 FamilyLabel=Parch+SibSp+1，然后将FamilySize分为三类：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">all_data[<span class="string">'FamilySize'</span>]=all_data[<span class="string">'SibSp'</span>]+all_data[<span class="string">'Parch'</span>]+<span class="number">1</span></span><br><span class="line">sns.barplot(x=<span class="string">"FamilySize"</span>, y=<span class="string">"Survived"</span>, data=all_data)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20200627094509738.png" alt="在这里插入图片描述"></p><h5 id="数据探索"><a href="#数据探索" class="headerlink" title="数据探索"></a>数据探索</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(action=<span class="string">"ignore"</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">plt.figure(figsize=[<span class="number">12</span>, <span class="number">10</span>])</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">sns.barplot(<span class="string">'Pclass'</span>, <span class="string">'Survived'</span>, data=train)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">sns.barplot(<span class="string">'SibSp'</span>, <span class="string">'Survived'</span>, data=train)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">sns.barplot(<span class="string">'Parch'</span>, <span class="string">'Survived'</span>, data=train)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">sns.barplot(<span class="string">'Sex'</span>, <span class="string">'Survived'</span>, data=train)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">sns.barplot(<span class="string">'Ticket'</span>, <span class="string">'Survived'</span>, data=train)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>)</span><br><span class="line">sns.barplot(<span class="string">'Cabin'</span>, <span class="string">'Survived'</span>, data=train)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">7</span>)</span><br><span class="line">sns.barplot(<span class="string">'Embarked'</span>, <span class="string">'Survived'</span>, data=train)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line">sns.distplot(train[train.Survived==<span class="number">1</span>].Age, color=<span class="string">'green'</span>, kde=<span class="literal">False</span>)</span><br><span class="line">sns.distplot(train[train.Survived==<span class="number">0</span>].Age, color=<span class="string">'orange'</span>, kde=<span class="literal">False</span>)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">3</span>,<span class="number">9</span>)</span><br><span class="line">sns.distplot(train[train.Survived==<span class="number">1</span>].Fare, color=<span class="string">'green'</span>, kde=<span class="literal">False</span>)</span><br><span class="line">sns.distplot(train[train.Survived==<span class="number">0</span>].Fare, color=<span class="string">'orange'</span>, kde=<span class="literal">False</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">train.drop([<span class="string">'PassengerId'</span>,<span class="string">'Name'</span>,<span class="string">'Ticket'</span>,<span class="string">'SibSp'</span>,<span class="string">'Parch'</span>,<span class="string">'Ticket'</span>,<span class="string">'Cabin'</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">test.drop([<span class="string">'PassengerId'</span>,<span class="string">'Name'</span>,<span class="string">'Ticket'</span>,<span class="string">'SibSp'</span>,<span class="string">'Parch'</span>,<span class="string">'Ticket'</span>,<span class="string">'Cabin'</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">titanic=pd.concat([train, test], sort=<span class="literal">False</span>)</span><br><span class="line">titanic=pd.get_dummies(titanic)<span class="comment">#get_dummies one-hot encoding将离散特征的取值扩展到欧式空间，比如性别本事是一个特征，经过one-hot编码后，就变成了男或女两个特征</span></span><br><span class="line">train=titanic[:len_train]<span class="comment">#前len_train行为训练集</span></span><br><span class="line">test=titanic[len_train:]<span class="comment">#后面的为测试集</span></span><br><span class="line"><span class="comment"># Lets change type of target</span></span><br><span class="line">train.Survived=train.Survived.astype(<span class="string">'int'</span>)</span><br><span class="line">train.Survived.dtype</span><br><span class="line">xtrain=train.drop(<span class="string">"Survived"</span>,axis=<span class="number">1</span>)</span><br><span class="line">ytrain=train[<span class="string">'Survived'</span>]</span><br><span class="line">xtest=test.drop(<span class="string">"Survived"</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="模型的构建及训练"><a href="#模型的构建及训练" class="headerlink" title="模型的构建及训练"></a>模型的构建及训练</h4><p>随机森林</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RF=RandomForestClassifier(random_state=<span class="number">1</span>)</span><br><span class="line">PRF=[{<span class="string">'n_estimators'</span>:[<span class="number">10</span>,<span class="number">100</span>],<span class="string">'max_depth'</span>:[<span class="number">3</span>,<span class="number">6</span>],<span class="string">'criterion'</span>:[<span class="string">'gini'</span>,<span class="string">'entropy'</span>]}]</span><br><span class="line">GSRF=GridSearchCV(estimator=RF, param_grid=PRF, scoring=<span class="string">'accuracy'</span>,cv=<span class="number">2</span>)</span><br><span class="line">scores_rf=cross_val_score(GSRF,xtrain,ytrain,scoring=<span class="string">'accuracy'</span>,cv=<span class="number">5</span>)</span><br><span class="line">np.mean(scores_rf)</span><br></pre></td></tr></tbody></table></figure><p>SVC</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">svc=make_pipeline(StandardScaler(),SVC(random_state=<span class="number">1</span>))</span><br><span class="line">r=[<span class="number">0.0001</span>,<span class="number">0.001</span>,<span class="number">0.1</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">100</span>]</span><br><span class="line">PSVM=[{<span class="string">'svc__C'</span>:r, <span class="string">'svc__kernel'</span>:[<span class="string">'linear'</span>]},</span><br><span class="line">      {<span class="string">'svc__C'</span>:r, <span class="string">'svc__gamma'</span>:r, <span class="string">'svc__kernel'</span>:[<span class="string">'rbf'</span>]}]</span><br><span class="line">GSSVM=GridSearchCV(estimator=svc, param_grid=PSVM, scoring=<span class="string">'accuracy'</span>, cv=<span class="number">2</span>)</span><br><span class="line">scores_svm=cross_val_score(GSSVM, xtrain.astype(float), ytrain,scoring=<span class="string">'accuracy'</span>, cv=<span class="number">5</span>)</span><br><span class="line">np.mean(scores_svm)</span><br></pre></td></tr></tbody></table></figure><h4 id="完整实现代码"><a href="#完整实现代码" class="headerlink" title="完整实现代码"></a>完整实现代码</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(action=<span class="string">"ignore"</span>)</span><br><span class="line"></span><br><span class="line">train=pd.read_csv(<span class="string">"input/train.csv"</span>)</span><br><span class="line">test=pd.read_csv(<span class="string">"input/test.csv"</span>)</span><br><span class="line">test2=pd.read_csv(<span class="string">"input/test.csv"</span>)</span><br><span class="line">titanic=pd.concat([train, test], sort=<span class="literal">False</span>)</span><br><span class="line">len_train=train.shape[<span class="number">0</span>]<span class="comment">#train数据的行数</span></span><br><span class="line">print(titanic)</span><br><span class="line">print(titanic.dtypes.sort_values())<span class="comment">#对数据进行排序</span></span><br><span class="line">titanic.select_dtypes(include=<span class="string">'int'</span>).tail()</span><br><span class="line"></span><br><span class="line">titanic.select_dtypes(include=<span class="string">'object'</span>).head() <span class="comment">#查看特定类型的数据行</span></span><br><span class="line"></span><br><span class="line">titanic.select_dtypes(include= <span class="string">'float'</span>).head()</span><br><span class="line"></span><br><span class="line">print(titanic.isnull().sum()[titanic.isnull().sum()&gt;<span class="number">0</span>])<span class="comment">#只显示存在缺失值的属性，如果没有titanic.isnull().sum()&gt;0则不确实的特征属性会显示为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train.Fare=train.Fare.fillna(train.Fare.mean())<span class="comment">#Fare票价的缺失值用平均值填充</span></span><br><span class="line">test.Fare=test.Fare.fillna(train.Fare.mean())</span><br><span class="line"></span><br><span class="line">train.Cabin=train.Cabin.fillna(<span class="string">"unknow"</span>)<span class="comment">#船舱座位号空的用unknow填充</span></span><br><span class="line">test.Cabin=test.Cabin.fillna(<span class="string">"unknow"</span>)</span><br><span class="line"></span><br><span class="line">train.Embarked=train.Embarked.fillna(train.Embarked.mode()[<span class="number">0</span>])<span class="comment">#mode为求众数(频数最高的值)</span></span><br><span class="line">test.Embarked=test.Embarked.fillna(train.Embarked.mode()[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">train[<span class="string">'title'</span>]=train.Name.apply(<span class="keyword">lambda</span> x: x.split(<span class="string">'.'</span>)[<span class="number">0</span>].split(<span class="string">','</span>)[<span class="number">1</span>].strip())</span><br><span class="line">test[<span class="string">'title'</span>]=test.Name.apply(<span class="keyword">lambda</span> x: x.split(<span class="string">'.'</span>)[<span class="number">0</span>].split(<span class="string">','</span>)[<span class="number">1</span>].strip())</span><br><span class="line"><span class="comment">#对年龄缺失值的补全，先提取姓名中的称谓，判断大致身份，然后根据各不同称谓的平均年龄，对同类</span></span><br><span class="line"><span class="comment">#缺失值进行补齐。</span></span><br><span class="line">newtitles={</span><br><span class="line">    <span class="string">"Capt"</span>:       <span class="string">"Officer"</span>,</span><br><span class="line">    <span class="string">"Col"</span>:        <span class="string">"Officer"</span>,</span><br><span class="line">    <span class="string">"Major"</span>:      <span class="string">"Officer"</span>,</span><br><span class="line">    <span class="string">"Jonkheer"</span>:   <span class="string">"Royalty"</span>,</span><br><span class="line">    <span class="string">"Don"</span>:        <span class="string">"Royalty"</span>,</span><br><span class="line">    <span class="string">"Sir"</span> :       <span class="string">"Royalty"</span>,</span><br><span class="line">    <span class="string">"Dr"</span>:         <span class="string">"Officer"</span>,</span><br><span class="line">    <span class="string">"Rev"</span>:        <span class="string">"Officer"</span>,</span><br><span class="line">    <span class="string">"the Countess"</span>:<span class="string">"Royalty"</span>,</span><br><span class="line">    <span class="string">"Dona"</span>:       <span class="string">"Royalty"</span>,</span><br><span class="line">    <span class="string">"Mme"</span>:        <span class="string">"Mrs"</span>,</span><br><span class="line">    <span class="string">"Mlle"</span>:       <span class="string">"Miss"</span>,</span><br><span class="line">    <span class="string">"Ms"</span>:         <span class="string">"Mrs"</span>,</span><br><span class="line">    <span class="string">"Mr"</span> :        <span class="string">"Mr"</span>,</span><br><span class="line">    <span class="string">"Mrs"</span> :       <span class="string">"Mrs"</span>,</span><br><span class="line">    <span class="string">"Miss"</span> :      <span class="string">"Miss"</span>,</span><br><span class="line">    <span class="string">"Master"</span> :    <span class="string">"Master"</span>,</span><br><span class="line">    <span class="string">"Lady"</span> :      <span class="string">"Royalty"</span>}</span><br><span class="line"></span><br><span class="line">train[<span class="string">'title'</span>]=train.title.map(newtitles)</span><br><span class="line">test[<span class="string">'title'</span>]=test.title.map(newtitles)</span><br><span class="line"></span><br><span class="line">train.groupby([<span class="string">'title'</span>,<span class="string">'Sex'</span>]).Age.mean()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newage</span> <span class="params">(cols)</span>:</span></span><br><span class="line">    title=cols[<span class="number">0</span>]</span><br><span class="line">    Sex=cols[<span class="number">1</span>]</span><br><span class="line">    Age=cols[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> pd.isnull(Age):</span><br><span class="line">        <span class="keyword">if</span> title==<span class="string">'Master'</span> <span class="keyword">and</span> Sex==<span class="string">"male"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">4.57</span></span><br><span class="line">        <span class="keyword">elif</span> title==<span class="string">'Miss'</span> <span class="keyword">and</span> Sex==<span class="string">'female'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">21.8</span></span><br><span class="line">        <span class="keyword">elif</span> title==<span class="string">'Mr'</span> <span class="keyword">and</span> Sex==<span class="string">'male'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">32.37</span></span><br><span class="line">        <span class="keyword">elif</span> title==<span class="string">'Mrs'</span> <span class="keyword">and</span> Sex==<span class="string">'female'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">35.72</span></span><br><span class="line">        <span class="keyword">elif</span> title==<span class="string">'Officer'</span> <span class="keyword">and</span> Sex==<span class="string">'female'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">49</span></span><br><span class="line">        <span class="keyword">elif</span> title==<span class="string">'Officer'</span> <span class="keyword">and</span> Sex==<span class="string">'male'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">46.56</span></span><br><span class="line">        <span class="keyword">elif</span> title==<span class="string">'Royalty'</span> <span class="keyword">and</span> Sex==<span class="string">'female'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">40.50</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">42.33</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Age</span><br><span class="line">train.Age = train[[<span class="string">'title'</span>, <span class="string">'Sex'</span>, <span class="string">'Age'</span>]].apply(newage, axis=<span class="number">1</span>)</span><br><span class="line">test.Age = test[[<span class="string">'title'</span>, <span class="string">'Sex'</span>, <span class="string">'Age'</span>]].apply(newage, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#droping features I won't use in model</span></span><br><span class="line"><span class="comment">#train.drop(['PassengerId','Name','Ticket','SibSp','Parch','Ticket','Cabin']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 数据准备</span></span><br><span class="line">train.drop([<span class="string">'PassengerId'</span>,<span class="string">'Name'</span>,<span class="string">'Ticket'</span>,<span class="string">'SibSp'</span>,<span class="string">'Parch'</span>,<span class="string">'Ticket'</span>,<span class="string">'Cabin'</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">test.drop([<span class="string">'PassengerId'</span>,<span class="string">'Name'</span>,<span class="string">'Ticket'</span>,<span class="string">'SibSp'</span>,<span class="string">'Parch'</span>,<span class="string">'Ticket'</span>,<span class="string">'Cabin'</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">titanic=pd.concat([train, test], sort=<span class="literal">False</span>)</span><br><span class="line">titanic=pd.get_dummies(titanic)<span class="comment">#get_dummies one-hot encoding将离散特征的取值扩展到欧式空间，比如性别本事是一个特征，经过one-hot编码后，就变成了男或女两个特征</span></span><br><span class="line">train=titanic[:len_train]<span class="comment">#前len_train行为训练集</span></span><br><span class="line">test=titanic[len_train:]<span class="comment">#后面的为测试集</span></span><br><span class="line"><span class="comment"># Lets change type of target</span></span><br><span class="line">train.Survived=train.Survived.astype(<span class="string">'int'</span>)</span><br><span class="line">train.Survived.dtype</span><br><span class="line">xtrain=train.drop(<span class="string">"Survived"</span>,axis=<span class="number">1</span>)</span><br><span class="line">ytrain=train[<span class="string">'Survived'</span>]</span><br><span class="line">xtest=test.drop(<span class="string">"Survived"</span>, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">RF=RandomForestClassifier(random_state=<span class="number">1</span>)</span><br><span class="line">PRF=[{<span class="string">'n_estimators'</span>:[<span class="number">10</span>,<span class="number">100</span>],<span class="string">'max_depth'</span>:[<span class="number">3</span>,<span class="number">6</span>],<span class="string">'criterion'</span>:[<span class="string">'gini'</span>,<span class="string">'entropy'</span>]}]</span><br><span class="line">GSRF=GridSearchCV(estimator=RF, param_grid=PRF, scoring=<span class="string">'accuracy'</span>,cv=<span class="number">2</span>)</span><br><span class="line">scores_rf=cross_val_score(GSRF,xtrain,ytrain,scoring=<span class="string">'accuracy'</span>,cv=<span class="number">5</span>)</span><br><span class="line">np.mean(scores_rf)</span><br><span class="line"></span><br><span class="line">svc=make_pipeline(StandardScaler(),SVC(random_state=<span class="number">1</span>))</span><br><span class="line">r=[<span class="number">0.0001</span>,<span class="number">0.001</span>,<span class="number">0.1</span>,<span class="number">1</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">100</span>]</span><br><span class="line">PSVM=[{<span class="string">'svc__C'</span>:r, <span class="string">'svc__kernel'</span>:[<span class="string">'linear'</span>]},</span><br><span class="line">      {<span class="string">'svc__C'</span>:r, <span class="string">'svc__gamma'</span>:r, <span class="string">'svc__kernel'</span>:[<span class="string">'rbf'</span>]}]</span><br><span class="line">GSSVM=GridSearchCV(estimator=svc, param_grid=PSVM, scoring=<span class="string">'accuracy'</span>, cv=<span class="number">2</span>)</span><br><span class="line">scores_svm=cross_val_score(GSSVM, xtrain.astype(float), ytrain,scoring=<span class="string">'accuracy'</span>, cv=<span class="number">5</span>)</span><br><span class="line">np.mean(scores_svm)</span><br><span class="line"></span><br><span class="line">model=GSSVM.fit(xtrain, ytrain)</span><br><span class="line">pred=model.predict(xtest)</span><br><span class="line">output=pd.DataFrame({<span class="string">'PassengerId'</span>:test2[<span class="string">'PassengerId'</span>],<span class="string">'Survived'</span>:pred})</span><br><span class="line">output.to_csv(<span class="string">'submission.csv'</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python kaggle 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python+opencv实现人脸识别|采用现成训练好的模型</title>
      <link href="/posts/63ec.html"/>
      <url>/posts/63ec.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、图片人脸检测（opencv）"><a href="#一、图片人脸检测（opencv）" class="headerlink" title="一、图片人脸检测（opencv）"></a>一、图片人脸检测（opencv）</h3><h4 id="1、安装opencv环境"><a href="#1、安装opencv环境" class="headerlink" title="1、安装opencv环境"></a>1、安装opencv环境</h4><p>介绍windows中opencv在python3上的实现，我的系统环境win10+python3.6+opcv3.4.1</p><a id="more"></a><p>首先去网站下载OpenCV对应的.whl版本压缩包，网址：<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#opencv" target="_blank" rel="noopener">https://www.lfd.uci.edu/~gohlke/pythonlibs/#opencv</a> 本人下载的版本是：opencv_python‑3.4.1‑cp36‑cp36m‑win_amd64.whl 64位系统对应python3.6的，下载到F盘根目录。<br>链接：<a href="https://pan.baidu.com/s/1aXK97tnxFVA15fH7TFi1_Q" target="_blank" rel="noopener">百度云链接</a><br>提取码：j5uy<br>接着用pip命令安装</p><blockquote><p><code>pip install F:\opencv_python-3.4.1-cp36-cp36m-win_amd64.whl</code></p></blockquote><p>当命令行窗口显示：</p><blockquote><p>Processing F:\opencv_python-3.4.1-cp36-cp36m-win_amd64.whl<br>Installing collected packages: opencv-python<br>Successfully installed opencv-python-3.4.1</p></blockquote><p>说明已经安装成功。<br>到此，opencv的环境配置已经弄好了，可以在命令行中运行python，然后import cv2  打印输出opencv的版本号，看能否正常输出。<br><img src="https://img-blog.csdnimg.cn/2020062316223081.png" alt="在这里插入图片描述"></p><h4 id="2、具体实现代码"><a href="#2、具体实现代码" class="headerlink" title="2、具体实现代码"></a>2、具体实现代码</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'img/1.png'</span>)  <span class="comment"># 读取图片</span></span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)  <span class="comment"># 转换灰色</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># OpenCV人脸识别分类器</span></span><br><span class="line">classifier = cv2.CascadeClassifier(<span class="string">r'F:\python-project\opencv-master\haarcascade_frontalface_default.xml'</span>)<span class="comment">#创建人脸检测级联分类器对象实例</span></span><br><span class="line">color = (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)  <span class="comment"># 定义绘制颜色为绿色</span></span><br><span class="line"><span class="comment"># 调用识别人脸</span></span><br><span class="line">faceRects = classifier.detectMultiScale(</span><br><span class="line">    gray, scaleFactor=<span class="number">1.2</span>, minNeighbors=<span class="number">3</span>, minSize=(<span class="number">24</span>, <span class="number">24</span>))</span><br><span class="line"><span class="comment">#参数说明，scaleFactor：图像缩放比例，可理解为相机的X倍镜，minNeighbors：对特征检测点周边多少有效点同时检测，这样可避免因选取的特征检测点太小而导致遗漏</span></span><br><span class="line"><span class="comment">#minSize：特征检测点的最小尺寸</span></span><br><span class="line"><span class="keyword">if</span> len(faceRects):  <span class="comment"># 大于0则检测到人脸</span></span><br><span class="line">    <span class="keyword">for</span> faceRect <span class="keyword">in</span> faceRects:  <span class="comment"># 单独框出每一张人脸</span></span><br><span class="line">        x, y, w, h = faceRect</span><br><span class="line">        <span class="comment"># 框出人脸</span></span><br><span class="line">        cv2.rectangle(img, (x, y), (x + h, y + w), color, <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 左眼</span></span><br><span class="line">        <span class="comment">#cv2.circle(img, (x + w // 4, y + h // 4 + 30), min(w // 8, h // 8),</span></span><br><span class="line">          <span class="comment">#         color)</span></span><br><span class="line">        <span class="comment">#右眼</span></span><br><span class="line">        <span class="comment">#cv2.circle(img, (x + 3 * w // 4, y + h // 4 + 30), min(w // 8, h // 8),</span></span><br><span class="line">         <span class="comment">#          color)</span></span><br><span class="line">        <span class="comment">#嘴巴</span></span><br><span class="line">        cv2.rectangle(img, (x + <span class="number">3</span> * w // <span class="number">8</span>, y + <span class="number">3</span> * h // <span class="number">4</span>),</span><br><span class="line">                      (x + <span class="number">5</span> * w // <span class="number">8</span>, y + <span class="number">7</span> * h // <span class="number">8</span>), color)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">"image-detection"</span>, img)  <span class="comment"># 显示图像</span></span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>) <span class="comment">#表示程序会无限制的等待用户的按键事件</span></span><br><span class="line">cv2.destroyAllWindows()<span class="comment">#关闭所有窗口</span></span><br></pre></td></tr></tbody></table></figure><h4 id="3、识别结果"><a href="#3、识别结果" class="headerlink" title="3、识别结果"></a>3、识别结果</h4><p><img src="https://img-blog.csdnimg.cn/20200623192140868.png" alt="在这里插入图片描述"></p><h3 id="二、图片人脸检测（dlib）"><a href="#二、图片人脸检测（dlib）" class="headerlink" title="二、图片人脸检测（dlib）"></a>二、图片人脸检测（dlib）</h3><p>比opencv更加精准的图片人脸检测库Dlib，Dlib可以检测脸部68甚至更多的特征点。</p><h4 id="1、安装dlib"><a href="#1、安装dlib" class="headerlink" title="1、安装dlib"></a>1、安装dlib</h4><p>下载地址：<a href="https://pypi.org/simple/dlib/" target="_blank" rel="noopener">https://pypi.org/simple/dlib/</a><br>我的环境为win10+python3.6.5<br>选择dlib的版本为：<code>dlib-19.8.1-cp36-cp36m-win_amd64.whl</code><br><img src="https://img-blog.csdnimg.cn/2020062318571914.png" alt="在这里插入图片描述"><br>接着用pip命令安装：</p><blockquote><p>pip install dlib-19.8.1-cp36-cp36m-win_amd64.whl</p></blockquote><h4 id="2、训练模型"><a href="#2、训练模型" class="headerlink" title="2、训练模型"></a>2、训练模型</h4><p>下载链接：<a href="https://pan.baidu.com/s/1xai1X_L8JvDfFJyU3f_0Ig" target="_blank" rel="noopener">https://pan.baidu.com/s/1xai1X_L8JvDfFJyU3f_0Ig </a><br>提取码：g24q</p><h4 id="3、具体实现代码"><a href="#3、具体实现代码" class="headerlink" title="3、具体实现代码"></a>3、具体实现代码</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> dlib</span><br><span class="line"></span><br><span class="line">path = <span class="string">"img/1.png"</span></span><br><span class="line">img = cv2.imread(path)</span><br><span class="line">gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<span class="comment">#转成灰度图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#人脸分类器</span></span><br><span class="line">detector = dlib.get_frontal_face_detector()</span><br><span class="line"><span class="comment"># 获取人脸检测器</span></span><br><span class="line">predictor = dlib.shape_predictor(</span><br><span class="line">        <span class="string">"F:\\python-project\\shape_predictor_68_face_landmarks.dat"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">dets = detector(gray, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> face <span class="keyword">in</span> dets:</span><br><span class="line">    shape = predictor(img, face)  <span class="comment"># 寻找人脸的68个标定点</span></span><br><span class="line">    <span class="comment"># 遍历所有点，打印出其坐标，并圈出来</span></span><br><span class="line">    <span class="keyword">for</span> pt <span class="keyword">in</span> shape.parts():</span><br><span class="line">        pt_pos = (pt.x, pt.y)</span><br><span class="line">        cv2.circle(img, pt_pos, <span class="number">2</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">    cv2.imshow(<span class="string">"image"</span>, img)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></tbody></table></figure><h4 id="4、识别结果"><a href="#4、识别结果" class="headerlink" title="4、识别结果"></a>4、识别结果</h4><p><img src="https://img-blog.csdnimg.cn/20200623192047787.png" alt="在这里插入图片描述"><br>参考链接：<a href="https://github.com/vipstone/faceai/blob/master/doc/detectionOpenCV.md" target="_blank" rel="noopener">https://github.com/vipstone/faceai/blob/master/doc/detectionOpenCV.md</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> opencv 人脸识别 python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习课程|paddle|入门</title>
      <link href="/posts/7277.html"/>
      <url>/posts/7277.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>强化学习入门路线：</p><ul><li>基础入门：基础概念，基本原理</li><li>理论补充：专业教材，高校课程</li><li>经典算法复现:DQN、DDPG、PPO、A3C</li><li>前沿论文阅读：顶会论文</li></ul><!--more--><h3 id="什么是强化学习"><a href="#什么是强化学习" class="headerlink" title="什么是强化学习"></a>什么是强化学习</h3><p>简单来说就是让机器像人一样学习：</p><ul><li>对已知环境进行规划</li><li>对未知环境进行探索/试错</li></ul><p>强化学习（英语：<code>Reinforcement learning</code>，简称RL）是机器学习中的一个领域，强调如何基于环境而行动，以取得最大化的预期利益。<br>核心思想：智能体<code>agent</code>在环境<code>environment</code>中学习，根据环境的状态state（或观测到的<code>observation</code>），执行动作<code>action</code>，并根据环境的反馈<code>reward</code>（奖励）来指导更好的动作。<br>注意：从环境中获取的状态，有时候叫state，有时候叫<code>observation</code>，这两个其实一个代表全局状态，一个代表局部观测值，在多智能体环境里会有差别，但我们刚开始学习遇到的环境还没有那么复杂，可以先把这两个概念划上等号。</p><p><img src="https://img-blog.csdnimg.cn/20200620175111245.png" alt="在这里插入图片描述"><br>这里地球来表示environment环境，大脑表示agent，agent从environment里面去观察导state状态，然后输出action动作来去和environment做交互，会从环境中得到反馈reward来指导自己的action动作是不是正确的。</p><p><img src="https://img-blog.csdnimg.cn/20200620175420753.png" alt="在这里插入图片描述"></p><h3 id="列举强化学习的一些应用"><a href="#列举强化学习的一些应用" class="headerlink" title="列举强化学习的一些应用"></a>列举强化学习的一些应用</h3><p><img src="https://img-blog.csdnimg.cn/20200620175802913.png" alt="在这里插入图片描述"></p><h3 id="强化学习与其他机器学习的关系"><a href="#强化学习与其他机器学习的关系" class="headerlink" title="强化学习与其他机器学习的关系"></a>强化学习与其他机器学习的关系</h3><p><img src="https://img-blog.csdnimg.cn/20200620180038547.png" alt="在这里插入图片描述"></p><ul><li>监督学习（分类、回归；）：（认知：是什么）可理解为输入一个x，输出你想要的y。监督学习的训练数据一般样本和样本之间是独立同分布的，</li><li>非监督学习（聚类）：输入一批x，需要分辨这个x和那个x不一样，</li><li>强化学习（决策：怎么做）：输入的是环境的state，输出是action跟环境去交互。<br>上一个样本可能和下一个样本有联系，上一个样本输出的动作可能会影响下一个样本的状态。序列决策数据</li></ul><h3 id="强化学习的两种学习方案"><a href="#强化学习的两种学习方案" class="headerlink" title="强化学习的两种学习方案"></a>强化学习的两种学习方案</h3><p>1、基于价值 Value-based （每一步 State 给奖励）—— 最终 Agent 获得每一步最优解（确定性策略）</p><ul><li>Sarsa</li><li>Q-learning</li><li>DQN<br><img src="https://img-blog.csdnimg.cn/2020062018221986.png" alt="在这里插入图片描述"><br>2、基于策略 Policy-based （最终给出奖励）—— 最终 Agent 获得每一步的概率分布（随机性策略）</li><li>Policy gradient<br><img src="https://img-blog.csdnimg.cn/20200620182314856.png" alt="在这里插入图片描述"><h4 id="PARL实现DQN训练"><a href="#PARL实现DQN训练" class="headerlink" title="PARL实现DQN训练"></a>PARL实现DQN训练</h4><h5 id="1、导入依赖"><a href="#1、导入依赖" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h5></li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> parl</span><br><span class="line"><span class="keyword">from</span> parl <span class="keyword">import</span> layers</span><br><span class="line"><span class="keyword">import</span> paddle.fluid <span class="keyword">as</span> fluid</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> gym</span><br><span class="line"><span class="keyword">from</span> parl.utils <span class="keyword">import</span> logger</span><br></pre></td></tr></tbody></table></figure><h5 id="2、设定一些hyperparameter超参数"><a href="#2、设定一些hyperparameter超参数" class="headerlink" title="2、设定一些hyperparameter超参数"></a>2、设定一些hyperparameter超参数</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LEARN_FREQ = <span class="number">5</span> <span class="comment"># 训练频率，不需要每一个step都learn，攒一些新增经验后再learn，提高效率</span></span><br><span class="line">MEMORY_SIZE = <span class="number">20000</span>    <span class="comment"># replay memory的大小，越大越占用内存</span></span><br><span class="line">MEMORY_WARMUP_SIZE = <span class="number">200</span>  <span class="comment"># replay_memory 里需要预存一些经验数据，再从里面sample一个batch的经验让agent去learn</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span>   <span class="comment"># 每次给agent learn的数据数量，从replay memory随机里sample一批数据出来</span></span><br><span class="line">GAMMA = <span class="number">0.99</span> <span class="comment"># reward 的衰减因子，一般取 0.9 到 0.999 不等</span></span><br><span class="line">LEARNING_RATE = <span class="number">0.005</span> <span class="comment"># 学习率</span></span><br></pre></td></tr></tbody></table></figure><h5 id="3、搭建Model、Algorithm、Agent架构"><a href="#3、搭建Model、Algorithm、Agent架构" class="headerlink" title="3、搭建Model、Algorithm、Agent架构"></a>3、搭建Model、Algorithm、Agent架构</h5><ul><li>Agent把产生的数据传给algorithm，algorithm根据model的模型结构计算出Loss，使用SGD或者其他优化器不断的优化，PARL架构可以很方便的应用在各类深度强化学习问题中。</li><li>Agent直接跟环境来交互</li><li>Model 是一个神经网络模型，输入State输出对于所有 action 估计的Q Values（我们会使用2个神经网络模型，一个是 Current Q Network 一个是 Target Q Network）</li><li>Algorithm 提供Loss Function和Optimization Algorithm，接收Agent的信息，用来优化神经网络</li></ul><h5 id="4、Model"><a href="#4、Model" class="headerlink" title="4、Model"></a>4、Model</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Model用来定义前向(Forward)网络，用户可以自由的定制自己的网络结构。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span><span class="params">(parl.Model)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, act_dim)</span>:</span></span><br><span class="line">        hid1_size = <span class="number">128</span></span><br><span class="line">        hid2_size = <span class="number">128</span></span><br><span class="line">        <span class="comment"># 3层全连接网络</span></span><br><span class="line">        self.fc1 = layers.fc(size=hid1_size, act=<span class="string">'relu'</span>)</span><br><span class="line">        self.fc2 = layers.fc(size=hid2_size, act=<span class="string">'relu'</span>)</span><br><span class="line">        self.fc3 = layers.fc(size=act_dim, act=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">value</span><span class="params">(self, obs)</span>:</span></span><br><span class="line">        <span class="comment"># 定义网络</span></span><br><span class="line">        <span class="comment"># 输入state，输出所有action对应的Q，[Q(s,a1), Q(s,a2), Q(s,a3)...]</span></span><br><span class="line">        </span><br><span class="line">        h1 = self.fc1(obs)</span><br><span class="line">        h2 = self.fc2(h1)</span><br><span class="line">        Q = self.fc3(h2)</span><br><span class="line">        <span class="keyword">return</span> Q</span><br></pre></td></tr></tbody></table></figure><h5 id="5、Algorithm"><a href="#5、Algorithm" class="headerlink" title="5、Algorithm"></a>5、Algorithm</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from parl.algorithms import DQN # 也可以直接从parl库中导入DQN算法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DQN</span><span class="params">(parl.Algorithm)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, model, act_dim=None, gamma=None, lr=None)</span>:</span></span><br><span class="line">        <span class="string">""" DQN algorithm</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            model (parl.Model): 定义Q函数的前向网络结构</span></span><br><span class="line"><span class="string">            act_dim (int): action空间的维度，即有几个action</span></span><br><span class="line"><span class="string">            gamma (float): reward的衰减因子</span></span><br><span class="line"><span class="string">            lr (float): learning rate 学习率.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.model = model <span class="comment"># 我们用来获取 current Q 的模型</span></span><br><span class="line">        self.target_model = copy.deepcopy(model) <span class="comment"># 创建一个target Q模型，创建的策略是直接从model复制给target</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> isinstance(act_dim, int)</span><br><span class="line">        <span class="keyword">assert</span> isinstance(gamma, float)</span><br><span class="line">        <span class="keyword">assert</span> isinstance(lr, float)</span><br><span class="line">        self.act_dim = act_dim <span class="comment"># 把这些参数变成class properties</span></span><br><span class="line">        self.gamma = gamma</span><br><span class="line">        self.lr = lr</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, obs)</span>:</span> <span class="comment"># 使用 current Q network 获取所有action的 Q values</span></span><br><span class="line">        <span class="string">""" 使用self.model的value网络来获取 [Q(s,a1),Q(s,a2),...]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.model.value(obs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span><span class="params">(self, obs, action, reward, next_obs, terminal)</span>:</span></span><br><span class="line">        <span class="string">""" 使用DQN算法更新self.model的value网络</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 从target_model中获取 max Q' 的值，用于计算target_Q</span></span><br><span class="line">        next_pred_value = self.target_model.value(next_obs) <span class="comment"># 获取 target Q network 的所有action的 Q values</span></span><br><span class="line">        best_v = layers.reduce_max(next_pred_value, dim=<span class="number">1</span>) <span class="comment"># 获取最大的Q值</span></span><br><span class="line">        best_v.stop_gradient = <span class="literal">True</span>  <span class="comment"># 阻止梯度传递</span></span><br><span class="line">        terminal = layers.cast(terminal, dtype=<span class="string">'float32'</span>) <span class="comment"># 把terminal （是否终止）换为一个float32类型的数组，如果终止里面存储1，如果不终止里面存储0</span></span><br><span class="line">        target = reward + (<span class="number">1.0</span> - terminal) * self.gamma * best_v <span class="comment"># 这里如果终止， 1-terminal 对应的元素为0，就不需要取best_v，不然还是要取best_v</span></span><br><span class="line"></span><br><span class="line">        pred_value = self.model.value(obs)  <span class="comment"># 获取 current Q network 的所有action的 Q values</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接着我们需要获取action对应的Q，这里使用了一个one-hot encoding来做乘法运算，相当于选中了Q values中action对应的那个值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将action转one-hot向量，比如：3 =&gt; [0,0,0,1,0]</span></span><br><span class="line">        action_onehot = layers.one_hot(action, self.act_dim)</span><br><span class="line">        action_onehot = layers.cast(action_onehot, dtype=<span class="string">'float32'</span>)</span><br><span class="line">        <span class="comment"># 下面一行是逐元素相乘，拿到action对应的 Q(s,a)</span></span><br><span class="line">        <span class="comment"># 比如：pred_value = [[2.3, 5.7, 1.2, 3.9, 1.4]], action_onehot = [[0,0,0,1,0]]</span></span><br><span class="line">        <span class="comment">#  ==&gt; pred_action_value = [[3.9]]</span></span><br><span class="line">        pred_action_value = layers.reduce_sum(</span><br><span class="line">            layers.elementwise_mul(action_onehot, pred_value), dim=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算 Q(s,a) 与 target_Q的MSE均方差，得到loss</span></span><br><span class="line">        cost = layers.square_error_cost(pred_action_value, target)</span><br><span class="line">        cost = layers.reduce_mean(cost) <span class="comment"># Loss 对于每一个样本都是一个数字，为了优化我们求平均数</span></span><br><span class="line">        optimizer = fluid.optimizer.Adam(learning_rate=self.lr)  <span class="comment"># 使用Adam优化器，Adam是一种优化算法</span></span><br><span class="line">        optimizer.minimize(cost)</span><br><span class="line">        <span class="keyword">return</span> cost</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sync_target</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">""" 把 self.model 的模型参数值同步到 self.target_model</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.model.sync_weights_to(self.target_model) <span class="comment"># 这个函数主要是为了更新 Target Q，因为每一段时间我们就需要使用 Current Q Network 更新一次Target Q Network</span></span><br></pre></td></tr></tbody></table></figure><h5 id="6、Agent"><a href="#6、Agent" class="headerlink" title="6、Agent"></a>6、Agent</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Algorithm定义了具体的算法来更新前向网络(Model)，也就是通过定义损失函数来更新Model，和算法相关的计算都放在algorithm中。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Agent</span><span class="params">(parl.Agent)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,</span></span></span><br><span class="line"><span class="function"><span class="params">                 algorithm,</span></span></span><br><span class="line"><span class="function"><span class="params">                 obs_dim,</span></span></span><br><span class="line"><span class="function"><span class="params">                 act_dim,</span></span></span><br><span class="line"><span class="function"><span class="params">                 e_greed=<span class="number">0.1</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 e_greed_decrement=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> isinstance(obs_dim, int)</span><br><span class="line">        <span class="keyword">assert</span> isinstance(act_dim, int)</span><br><span class="line">        self.obs_dim = obs_dim</span><br><span class="line">        self.act_dim = act_dim</span><br><span class="line">        super(Agent, self).__init__(algorithm)</span><br><span class="line"></span><br><span class="line">        self.global_step = <span class="number">0</span></span><br><span class="line">        self.update_target_steps = <span class="number">200</span>  <span class="comment"># 每隔200个training steps再把model的参数复制到target_model中</span></span><br><span class="line"></span><br><span class="line">        self.e_greed = e_greed  <span class="comment"># 有一定概率随机选取动作，探索</span></span><br><span class="line">        self.e_greed_decrement = e_greed_decrement  <span class="comment"># 随着训练逐步收敛，探索的程度慢慢降低</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_program</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.pred_program = fluid.Program()</span><br><span class="line">        self.learn_program = fluid.Program()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> fluid.program_guard(self.pred_program):  <span class="comment"># 搭建计算图用于 预测动作，定义输入输出变量</span></span><br><span class="line">            obs = layers.data(</span><br><span class="line">                name=<span class="string">'obs'</span>, shape=[self.obs_dim], dtype=<span class="string">'float32'</span>)</span><br><span class="line">            self.value = self.alg.predict(obs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> fluid.program_guard(self.learn_program):  <span class="comment"># 搭建计算图用于 更新Q网络，定义输入输出变量</span></span><br><span class="line">            obs = layers.data(</span><br><span class="line">                name=<span class="string">'obs'</span>, shape=[self.obs_dim], dtype=<span class="string">'float32'</span>)</span><br><span class="line">            action = layers.data(name=<span class="string">'act'</span>, shape=[<span class="number">1</span>], dtype=<span class="string">'int32'</span>)</span><br><span class="line">            reward = layers.data(name=<span class="string">'reward'</span>, shape=[], dtype=<span class="string">'float32'</span>)</span><br><span class="line">            next_obs = layers.data(</span><br><span class="line">                name=<span class="string">'next_obs'</span>, shape=[self.obs_dim], dtype=<span class="string">'float32'</span>)</span><br><span class="line">            terminal = layers.data(name=<span class="string">'terminal'</span>, shape=[], dtype=<span class="string">'bool'</span>)</span><br><span class="line">            self.cost = self.alg.learn(obs, action, reward, next_obs, terminal)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sample</span><span class="params">(self, obs)</span>:</span></span><br><span class="line">        sample = np.random.rand()  <span class="comment"># 产生0~1之间的小数</span></span><br><span class="line">        <span class="keyword">if</span> sample &lt; self.e_greed:</span><br><span class="line">            act = np.random.randint(self.act_dim)  <span class="comment"># 探索：每个动作都有概率被选择</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            act = self.predict(obs)  <span class="comment"># 选择最优动作</span></span><br><span class="line">        self.e_greed = max(</span><br><span class="line">            <span class="number">0.01</span>, self.e_greed - self.e_greed_decrement)  <span class="comment"># 随着训练逐步收敛，探索的程度慢慢降低</span></span><br><span class="line">        <span class="keyword">return</span> act</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, obs)</span>:</span>  <span class="comment"># 选择最优动作</span></span><br><span class="line">        obs = np.expand_dims(obs, axis=<span class="number">0</span>)</span><br><span class="line">        pred_Q = self.fluid_executor.run(</span><br><span class="line">            self.pred_program,</span><br><span class="line">            feed={<span class="string">'obs'</span>: obs.astype(<span class="string">'float32'</span>)},</span><br><span class="line">            fetch_list=[self.value])[<span class="number">0</span>]</span><br><span class="line">        pred_Q = np.squeeze(pred_Q, axis=<span class="number">0</span>)</span><br><span class="line">        act = np.argmax(pred_Q)  <span class="comment"># 选择Q最大的下标，即对应的动作</span></span><br><span class="line">        <span class="keyword">return</span> act</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">learn</span><span class="params">(self, obs, act, reward, next_obs, terminal)</span>:</span></span><br><span class="line">        <span class="comment"># 每隔200个training steps同步一次model和target_model的参数</span></span><br><span class="line">        <span class="keyword">if</span> self.global_step % self.update_target_steps == <span class="number">0</span>:</span><br><span class="line">            self.alg.sync_target()</span><br><span class="line">        self.global_step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        act = np.expand_dims(act, <span class="number">-1</span>)</span><br><span class="line">        feed = {</span><br><span class="line">            <span class="string">'obs'</span>: obs.astype(<span class="string">'float32'</span>),</span><br><span class="line">            <span class="string">'act'</span>: act.astype(<span class="string">'int32'</span>),</span><br><span class="line">            <span class="string">'reward'</span>: reward,</span><br><span class="line">            <span class="string">'next_obs'</span>: next_obs.astype(<span class="string">'float32'</span>),</span><br><span class="line">            <span class="string">'terminal'</span>: terminal</span><br><span class="line">        }</span><br><span class="line">        cost = self.fluid_executor.run(</span><br><span class="line">            self.learn_program, feed=feed, fetch_list=[self.cost])[<span class="number">0</span>]  <span class="comment"># 训练一次网络</span></span><br><span class="line">        <span class="keyword">return</span> cost</span><br></pre></td></tr></tbody></table></figure><h5 id="7、ReplayMemory"><a href="#7、ReplayMemory" class="headerlink" title="7、ReplayMemory"></a>7、ReplayMemory</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># replay_memory.py</span></span><br><span class="line"><span class="comment"># 经验池，用于存储多条经验，实现经验回放。</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplayMemory</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_size)</span>:</span></span><br><span class="line">        self.buffer = collections.deque(maxlen=max_size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 增加一条经验到经验池中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, exp)</span>:</span></span><br><span class="line">        self.buffer.append(exp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从经验池中选取N条经验出来</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sample</span><span class="params">(self, batch_size)</span>:</span></span><br><span class="line">        mini_batch = random.sample(self.buffer, batch_size)</span><br><span class="line">        obs_batch, action_batch, reward_batch, next_obs_batch, done_batch = [], [], [], [], []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> experience <span class="keyword">in</span> mini_batch:</span><br><span class="line">            s, a, r, s_p, done = experience</span><br><span class="line">            obs_batch.append(s)</span><br><span class="line">            action_batch.append(a)</span><br><span class="line">            reward_batch.append(r)</span><br><span class="line">            next_obs_batch.append(s_p)</span><br><span class="line">            done_batch.append(done)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> np.array(obs_batch).astype(<span class="string">'float32'</span>), \</span><br><span class="line">            np.array(action_batch).astype(<span class="string">'float32'</span>), np.array(reward_batch).astype(<span class="string">'float32'</span>),\</span><br><span class="line">            np.array(next_obs_batch).astype(<span class="string">'float32'</span>), np.array(done_batch).astype(<span class="string">'float32'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.buffer)</span><br></pre></td></tr></tbody></table></figure><h5 id="8、Training-amp-amp-Test（训练-amp-amp-测试）"><a href="#8、Training-amp-amp-Test（训练-amp-amp-测试）" class="headerlink" title="8、Training &amp;&amp; Test（训练&amp;&amp;测试）"></a>8、Training &amp;&amp; Test（训练&amp;&amp;测试）</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练一个episode</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_episode</span><span class="params">(env, agent, rpm)</span>:</span></span><br><span class="line">    total_reward = <span class="number">0</span></span><br><span class="line">    obs = env.reset()</span><br><span class="line">    step = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        step += <span class="number">1</span></span><br><span class="line">        action = agent.sample(obs)  <span class="comment"># 采样动作，所有动作都有概率被尝试到</span></span><br><span class="line">        next_obs, reward, done, _ = env.step(action)</span><br><span class="line">        rpm.append((obs, action, reward, next_obs, done))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># train model</span></span><br><span class="line">        <span class="keyword">if</span> (len(rpm) &gt; MEMORY_WARMUP_SIZE) <span class="keyword">and</span> (step % LEARN_FREQ == <span class="number">0</span>):</span><br><span class="line">            (batch_obs, batch_action, batch_reward, batch_next_obs,</span><br><span class="line">             batch_done) = rpm.sample(BATCH_SIZE)</span><br><span class="line">            train_loss = agent.learn(batch_obs, batch_action, batch_reward,</span><br><span class="line">                                     batch_next_obs,</span><br><span class="line">                                     batch_done)  <span class="comment"># s,a,r,s',done</span></span><br><span class="line"></span><br><span class="line">        total_reward += reward</span><br><span class="line">        obs = next_obs</span><br><span class="line">        <span class="keyword">if</span> done:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> total_reward</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估 agent, 跑 5 个episode，总reward求平均</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(env, agent, render=False)</span>:</span></span><br><span class="line">    eval_reward = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        obs = env.reset()</span><br><span class="line">        episode_reward = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            action = agent.predict(obs)  <span class="comment"># 预测动作，只选最优动作</span></span><br><span class="line">            obs, reward, done, _ = env.step(action)</span><br><span class="line">            episode_reward += reward</span><br><span class="line">            <span class="keyword">if</span> render:</span><br><span class="line">                env.render()</span><br><span class="line">            <span class="keyword">if</span> done:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        eval_reward.append(episode_reward)</span><br><span class="line">    <span class="keyword">return</span> np.mean(eval_reward)</span><br></pre></td></tr></tbody></table></figure><h5 id="9、创建环境和Agent，创建经验池，启动训练，保存模型，运行代码"><a href="#9、创建环境和Agent，创建经验池，启动训练，保存模型，运行代码" class="headerlink" title="9、创建环境和Agent，创建经验池，启动训练，保存模型，运行代码"></a>9、创建环境和Agent，创建经验池，启动训练，保存模型，运行代码</h5><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建环境</span></span><br><span class="line">env = gym.make(<span class="string">'MountainCar-v0'</span>)</span><br><span class="line">action_dim = env.action_space.n  <span class="comment"># MountainCar-v0: 3</span></span><br><span class="line">obs_shape = env.observation_space.shape  <span class="comment"># MountainCar-v0: (2,)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建经验池</span></span><br><span class="line">rpm = ReplayMemory(MEMORY_SIZE)  <span class="comment"># DQN的经验回放池</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据parl框架构建agent</span></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#请参考课堂Demo，嵌套Model, DQN, Agent构建 agent</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">######################################################################</span></span><br><span class="line">model = Model(act_dim=action_dim)</span><br><span class="line">algorithm = DQN(model, act_dim=action_dim, gamma=GAMMA, lr=LEARNING_RATE)</span><br><span class="line">agent = Agent(</span><br><span class="line">    algorithm,</span><br><span class="line">    obs_dim=obs_shape[<span class="number">0</span>],</span><br><span class="line">    act_dim=action_dim,</span><br><span class="line">    e_greed=<span class="number">0.1</span>,  <span class="comment"># 有一定概率随机选取动作，探索</span></span><br><span class="line">    e_greed_decrement=<span class="number">1e-6</span>)  <span class="comment"># 随着训练逐步收敛，探索的程度慢慢降低</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 加载模型</span></span><br><span class="line"><span class="comment"># save_path = './dqn_model.ckpt'</span></span><br><span class="line"><span class="comment"># agent.restore(save_path)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先往经验池里存一些数据，避免最开始训练的时候样本丰富度不够</span></span><br><span class="line"><span class="keyword">while</span> len(rpm) &lt; MEMORY_WARMUP_SIZE:</span><br><span class="line">    run_episode(env, agent, rpm)</span><br><span class="line"></span><br><span class="line">max_episode = <span class="number">2000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始训练</span></span><br><span class="line">episode = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> episode &lt; max_episode:  <span class="comment"># 训练max_episode个回合，test部分不计算入episode数量</span></span><br><span class="line">    <span class="comment"># train part</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">50</span>):</span><br><span class="line">        total_reward = run_episode(env, agent, rpm)</span><br><span class="line">        episode += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># test part</span></span><br><span class="line">    eval_reward = evaluate(env, agent, render=<span class="literal">False</span>)  <span class="comment"># render=True 查看显示效果</span></span><br><span class="line">    logger.info(<span class="string">'episode:{}    e_greed:{}   test_reward:{}'</span>.format(</span><br><span class="line">        episode, agent.e_greed, eval_reward))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练结束，保存模型</span></span><br><span class="line">save_path = <span class="string">'./dqn_model.ckpt'</span></span><br><span class="line">agent.save(save_path)</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python 人工智能 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python安装dlib遇到的错误:AttributeError:module ‘dlib’ has no attribute ‘get_frontal_face_detector’问题解决</title>
      <link href="/posts/3826.html"/>
      <url>/posts/3826.html</url>
      
        <content type="html"><![CDATA[<p>dlib是一个非常好用的跨平台的通用库，但是在安装过程中遇到了许多问题，我在使用Anaconda安装dlib过程中，用pip install 安装，安装成功后，import没有问题</p><a id="more"></a><p>如下图，import cv2没有报错。<br><img src="https://img-blog.csdnimg.cn/20200616220032833.png" alt="在这里插入图片描述"><br>但是在pycharm使用里面的函数时出现错误AttributeError: module ‘dlib’ has no attribute ‘get_frontal_face_detecetor’<br><img src="https://img-blog.csdnimg.cn/20200616220141763.png" alt="在这里插入图片描述"><br>找了好久都没找到原因，后来才发现是因为文件名的问题。自己建立的文件名和使用的模块重名了。<br><img src="https://img-blog.csdnimg.cn/20200616220444449.png" alt="在这里插入图片描述"><br>以后得注意，不能犯这种低级错误了。<br>将文件名dlib.py更改为learn.py，再次运行，就不会报错啦。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> python opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab对控制系统进行时域和频域联合分析</title>
      <link href="/posts/4d65.html"/>
      <url>/posts/4d65.html</url>
      
        <content type="html"><![CDATA[<h2 id="时域频域联合分析"><a href="#时域频域联合分析" class="headerlink" title="时域频域联合分析"></a>时域频域联合分析</h2><p>   这个例子说明如何使用交互式线性系统分析及应用程序并排比较多种类型的响应，包括时域和频域响应。<br>   创建一个想要比较其响应的模型，如比较一个三阶模型G和G与两个不同控制器C1和C2的闭环响应。</p><a id="more"></a><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">G = zpk([],[<span class="number">-5</span> <span class="number">-5</span> <span class="number">-10</span>],<span class="number">100</span>);%z,p,k</span><br><span class="line">C1 = pid(<span class="number">0</span>,<span class="number">4.4</span>);</span><br><span class="line">T1 = feedback(G*C1,<span class="number">1</span>);</span><br><span class="line">C2 = pid(<span class="number">2.9</span>,<span class="number">7.1</span>);</span><br><span class="line">T2 = feedback(G*C2,<span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><p>　　&nbsp; &nbsp; &nbsp; 打开线性系统分析器工具，检查受控对象和闭环系统的响应。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linearSystemAnalyzer(G,T1,T2)</span><br></pre></td></tr></tbody></table></figure><p>默认情况下，线性系统分析器启动时带有三个系统的阶跃响应图<br> <img src="https://img-blog.csdnimg.cn/20200609192243778.png" alt="在这里插入图片描述"><br>　　在线性系统分析器中，选择Edit &gt; Plot Configurations以打开该绘图配置对话框。选择two-plot配置。在响应类型区域中，选择第二个plot类型的Bode幅频图等。<br> <img src="https://img-blog.csdnimg.cn/20200609192314313.png" alt="在这里插入图片描述"></p><p>　在幅频响应图中的任何位置，右键单击选择特征-峰值，得到系统的峰值响应。<br> <img src="https://img-blog.csdnimg.cn/20200609192323409.png" alt="在这里插入图片描述"><br>  　　之后图上出现了指示峰值响应值的标记。水平和垂直的虚线表示这些响应的频率和振幅。单击一个标记查看数据提示中峰值响应的值。<br> <img src="https://img-blog.csdnimg.cn/20200609192335159.png" alt="在这里插入图片描述"><br>　　还可以使用类似的过程从特征菜单中选择其他特征，例如确定时间和上升时间，并查看这些值。<br>　　同时还可以更改线性系统分析器中显示的绘图类型。比如<code>阶跃响应、冲激响应、伯德图、奈奎斯特图</code>等等<br> <img src="https://img-blog.csdnimg.cn/20200609192344694.png" alt="在这里插入图片描述"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 控制 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ |标准模板库STL</title>
      <link href="/posts/988f.html"/>
      <url>/posts/988f.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>vector是线性容器，可叫做“变长数组”，即“长度可根据需要而自动改变的数组”调整存储空间大小。它的元素存储在一块连续的存储空间中，可以使用迭代器iterator和指针的偏移地址访问元素。</p><!--more--><h5 id="1-vector的定义"><a href="#1-vector的定义" class="headerlink" title="1.vector的定义"></a>1.vector的定义</h5><p>单独定义一个vector：<code>vector&lt;typename&gt; name;</code><br>这个定义相当于是一维数组name[SIZE],不过长度可以根据需要进行变化，比较节省空间。<br>typename可以是任何基本类型，例如int,double、char、结构体等，也可以是STL标准容器，例如vector、set、queue等。<br>如果typename是vector，可以按下面这样定义：<br><code>vector&lt;vector&lt;int&gt; &gt; name;</code></p><h5 id="2-vector容器内元素的访问"><a href="#2-vector容器内元素的访问" class="headerlink" title="2.vector容器内元素的访问"></a>2.vector容器内元素的访问</h5><p>（1）通过下标访问<br>和访问普通数组是一样，对一个定义为vector<typename> vec的vector容器来说，直接访问vec[index]（如vec[0]、vec[1]),这里的下标是从0到vec.siz()-1.<br>（2）通过迭代器访问<br>迭代器（iterator）定义：<br><code>vector&lt;typename&gt;::iterator it;</code><br>可以将迭代器理解为一种类似指针的东西。<br>可通过类似下表和指针访问数组的方式来访问容器内的元素：</typename></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        vec.push_back(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=vec.begin();<span class="comment">//vec.begin()为取vec的首元素地址，it指向这个地址</span></span><br><span class="line"><span class="comment">/* 另一种遍历vector中元素的写法：</span></span><br><span class="line"><span class="comment">for(vector&lt;int&gt;::iterator it=vec.begin();it!=vec.end();it++)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*(it+i));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}siz</span><br></pre></td></tr></tbody></table></figure><p>vec[i]和*(vec.begin()+i)是等价的。</p><h5 id="3-vector常用函数"><a href="#3-vector常用函数" class="headerlink" title="3.vector常用函数"></a>3.vector常用函数</h5><ol><li>push_back(x),在vector后面添加一个元素x。</li><li>pop_back(),删除vector的尾元素。</li><li>size()，获取vector中元素的个数</li><li>clear()，清空vector中的所有元素，时间复杂度为O(N),其中N为vector中元素的个数。</li><li>insert(),插入元素到某个位置中，insert(iterator loc，x)用来向vector的指定位置loc前插入一个元素x。</li><li>erase(),有两种用法:删除单个元素，删除一个区间内的所有元素。erase(it)删除迭代器为it处的元素，earse(first,last)删除[first,last)内的所有元素。<br>empty(),表示判断vector是否为空，如果为空，则返回true.<br>容器的大小和容器的容量是有区别的，大小 是指元素的个数，容量是分配的内存大小，容量一般不小于容器的大小。vector::size()返回容器的大小，vector::capacity()返回容量值。<h6 id="vector的特点如下"><a href="#vector的特点如下" class="headerlink" title="vector的特点如下:"></a><code>vector</code>的特点如下:</h6></li></ol><ul><li>随机访问元素效率很高</li><li>push_back的效率也会很高</li><li>push_front的效率非常低，不建议使用</li><li>vector在末尾添加和删除元素相对较好，而在其他位置添加和删除元素则不及其他顺序容器，在迭代器和引用也没有list支持的好</li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ol><li><p>string的定义<br>定义string的方式跟基本数据类型相同，只需要在stirng后面跟上变量名，<code>string str;</code>，初始化可以海子街给string类型的变量赋值。<br><code>string str="abcd";</code></p></li><li><p>string中内容的访问：<br>(1)可以直接通过下标访问，str[i]<br>(2)通过迭代器访问,string::iterator it;</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">string</span> str=<span class="string">"abcd"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">string</span>::iterator it=str.begin();it!=str.end();it++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>string和vector一样，可以直接对迭代器进行加减某个数字，如str.begin()+3</p></li><li><p>常用函数实例</p></li><li><p>两个string可以直接通过+拼接起来。</p></li><li><p>两个string类型可以直接使用==、!=、&lt;、&lt;=、&gt;、&gt;=比较大小，比较规则是字典序。(比较两个字符串对应的ASCII码值)</p></li><li><p>length()/size()，length()返回string的长度，即存放的字符数，时间复杂度为O(1)。</p></li><li><p>insert()</p></li><li><p>erase()<br>两种用法:删除单个元素，删除一个区间内的所有元素。<br>str.erase(it)用于删除单个元素，it为需要删除的元素的迭代器。</p></li></ol><h5 id="string类的构造函数："><a href="#string类的构造函数：" class="headerlink" title="string类的构造函数："></a>string类的构造函数：</h5><hr><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str：生成空字符串</span><br><span class="line"></span><br><span class="line">string s(str)：生成字符串为str的复制品</span><br><span class="line"></span><br><span class="line">string s(str, strbegin,strlen)：将字符串str中从下标strbegin开始、长度为strlen的部分作为字符串初值</span><br><span class="line"></span><br><span class="line">string s(cstr, char_len)：以C_string类型cstr的前char_len个字符串作为字符串s的初值</span><br><span class="line"></span><br><span class="line">string s(num ,c)：生成num个c字符的字符串</span><br><span class="line"></span><br><span class="line">string s(str, stridx)：将字符串str中从下标stridx开始到字符串结束的位置作为字符串初值</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> str1;               <span class="comment">//生成空字符串</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str2</span><span class="params">(<span class="string">"123456789"</span>)</span></span>;  <span class="comment">//生成"1234456789"的复制品</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str3</span><span class="params">(<span class="string">"12345"</span>, <span class="number">0</span>, <span class="number">3</span>)</span></span>;<span class="comment">//结果为"123"</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str4</span><span class="params">(<span class="string">"012345"</span>, <span class="number">5</span>)</span></span>;  <span class="comment">//结果为"01234"</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str5</span><span class="params">(<span class="number">5</span>, <span class="string">'1'</span>)</span></span>;       <span class="comment">//结果为"11111"</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str6</span><span class="params">(str2, <span class="number">2</span>)</span></span>;      <span class="comment">//结果为"3456789"</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">string</span> str1;               <span class="comment">//生成空字符串</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str2</span><span class="params">(<span class="string">"123456789"</span>)</span></span>;  <span class="comment">//生成"1234456789"的复制品</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str3</span><span class="params">(<span class="string">"12345"</span>, <span class="number">0</span>, <span class="number">3</span>)</span></span>;<span class="comment">//结果为"123"</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str4</span><span class="params">(<span class="string">"0123456"</span>, <span class="number">5</span>)</span></span>;  <span class="comment">//结果为"01234"</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str5</span><span class="params">(<span class="number">5</span>, <span class="string">'1'</span>)</span></span>;       <span class="comment">//结果为"11111"</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str6</span><span class="params">(str2, <span class="number">2</span>)</span></span>;      <span class="comment">//结果为"3456789"</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str2:"</span>&lt;&lt;str2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str3:"</span>&lt;&lt;str3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str4:"</span>&lt;&lt;str4&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str5:"</span>&lt;&lt;str5&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"str6:"</span>&lt;&lt;str6&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果：<br><img src="https://img-blog.csdnimg.cn/20200421154845469.png" alt="在这里插入图片描述"></p><h5 id="string的大小和容量"><a href="#string的大小和容量" class="headerlink" title="string的大小和容量"></a>string的大小和容量</h5><blockquote><ol><li>size()和length()：返回string对象的字符个数，它们执行效果相同。</li><li>max_size()：返回string对象最多包含的字符数，超出会抛出length_error异常</li><li>capacity()：重新分配内存之前，string对象能包含的最大字符数</li></ol></blockquote><h5 id="string的大小写转换-tolower-和toupper-函数-或者-STL中的transform算法"><a href="#string的大小写转换-tolower-和toupper-函数-或者-STL中的transform算法" class="headerlink" title="string的大小写转换:tolower()和toupper()函数 或者 STL中的transform算法"></a><font color="red">string的大小写转换:tolower()和toupper()函数 或者 STL中的transform算法</font></h5><p>方法一：使用C语言的函数，进行转换</p><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">string</span> str = <span class="string">"ABCDEFG"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++ )</span><br><span class="line">    {</span><br><span class="line">        str[i] = <span class="built_in">tolower</span>(str[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="to-string-将数值转换为字符串，返回对应的字符串"><a href="#to-string-将数值转换为字符串，返回对应的字符串" class="headerlink" title="to_string 将数值转换为字符串，返回对应的字符串"></a>to_string 将数值转换为字符串，返回对应的字符串</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;     </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="built_in">string</span> pi = <span class="string">"pi is "</span> + <span class="built_in">std</span>::to_string(<span class="number">3.1415926</span>);</span><br><span class="line">  <span class="built_in">string</span> perfect = <span class="built_in">std</span>::to_string(<span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span>+<span class="number">7</span>+<span class="number">14</span>) + <span class="string">" is a perfect number"</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; pi &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; perfect &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结果：<br>pi is 3.141593<br>28 is a perfect number</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set，是一个内部自动有序且不含重复元素的容器。set作为一个容器是用来存储同一数据类型的数据类型，并且能从一个数据结合中取出数据，在set中每个元素的值都是唯一的，</p><p>set常用函数实例<br>1.<code>insert(x)</code><br>  可将x插入set容器中，并自动递增排序和去重，时间复杂度为O(logN),其中N为set内的元素个数。<br>2.<code>find()</code><br>find(value)返回set中对应值为value的迭代器，时间复杂度为O(logN)，N为set内的元素个数。<br>3.<code>erase()</code></p><ul><li>删除单个元素:<br>st.erase(it),it为需要删除元素的迭代器，时间复杂度为O(1)。可结合find()函数一起使用<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    st.insert(<span class="number">100</span>);</span><br><span class="line">    st.insert(<span class="number">200</span>);</span><br><span class="line">    st.insert(<span class="number">100</span>);</span><br><span class="line">    st.insert(<span class="number">300</span>);</span><br><span class="line">    st.erase(st.find(<span class="number">100</span>));<span class="comment">//先利用find()函数找到100，然后用erase删除它</span></span><br><span class="line">    st.erase(st.find(<span class="number">200</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=st.begin();it!=st.end();it++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>st.erase(value)，其中value为需要删除元素的值。时间复杂度为O(logN)。</li><li>删除一个区间内的所有元素<br>st.erase(first,last)可以删除一个区间内的所有元素，其中first为所需要删除区间的起始迭代器，last为待删除区间的末尾迭代器的下一个地址，即为删除[first,last].</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    st.insert(<span class="number">20</span>);</span><br><span class="line">    st.insert(<span class="number">10</span>);</span><br><span class="line">    st.insert(<span class="number">40</span>);</span><br><span class="line">    st.insert(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=st.find(<span class="number">30</span>);</span><br><span class="line">    st.erase(it,st.end()); <span class="comment">//删除元素30至set末尾之间的元素，即30和40</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=st.begin();it!=st.end();it++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>4.<code>size()</code><br>用来获取set内元素的个数，时间复杂度为O(1)。<br>5. <code>clear()</code><br>清空set内的所有元素，复杂度为O(N),其中N为set内元素的个数</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map本质是一个关联式容器，它提供一对一的hash。里面的数据都是成对出现的：</p><ul><li>每一对中的第一个值称为关键字(key），每个关键字只能在map中出现一次；</li><li>第二个称为该关键字的值(value)。<br><code>map</code>以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的，后边我们会见识到有序的好处。<br>map可自动简历key-value的一一对应关系，比如一个班级中，每个学生的学号跟他的姓名就存在着一一映射的关系。</li></ul><p>1.插入元素<br>map的插入有3种方式：用insert函数插入pair数据，用insert函数插入value_type数据和用数组方式插入数据。<br>第一种：用insert函数插入pair数据</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br><span class="line">mapStudent.insert(pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>,“student_one”));</span><br></pre></td></tr></tbody></table></figure><p>第二种：用insert函数插入value_type数据</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br><span class="line">mapStudent.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::value_type (<span class="number">1</span>,<span class="string">"student_one"</span>));</span><br></pre></td></tr></tbody></table></figure><p>用make_pair</p><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mapStudent</span><span class="selector-class">.insert</span>(make_pair(<span class="number">1</span>, <span class="string">"student_one"</span>));</span><br></pre></td></tr></tbody></table></figure><p>第三种：用数组方式插入数据</p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt; mapStudent;</span><br><span class="line">mapStudent[<span class="number">1</span>] = “student_one”;</span><br><span class="line">mapStudent[<span class="number">2</span>] = “student_two”;</span><br></pre></td></tr></tbody></table></figure><p>以上四种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是不能再插入这个数据的，<font color="red">但是用数组方式就不同了，它可以覆盖以前该关键字对应的值</font>,即：如果当前存在该关键字，则覆盖改关键字的值，否则，以改关键字新建一个key—value;<br>2.查找元素<br>用find函数来定位数据出现位置，它返回的一个迭代器，当所查找的关键字key出现时，它返回数据所在对象的位置，如果沒有，返回迭代器等于end函数返回的迭代器。</p><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find 返回迭代器指向当前查找元素的位置否则返回map::end()位置</span></span><br><span class="line">iter = mapStudent.<span class="built_in">find</span>(<span class="string">"123456"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(iter != mapStudent.<span class="built_in">end</span>())</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="string">"Find, the value is"</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">cout</span>&lt;&lt;<span class="string">"Do not Find"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></tbody></table></figure><p>3.删除与清空元素</p><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器刪除</span></span><br><span class="line">iter = mapStudent.<span class="built_in">find</span>(<span class="string">"123"</span>);</span><br><span class="line">mapStudent.erase(iter);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//用关键字刪除</span></span><br><span class="line"><span class="keyword">int</span> n = mapStudent.erase(<span class="string">"123"</span>); <span class="comment">//如果刪除了会返回1，否则返回0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//用迭代器范围刪除 : 把整个map清空</span></span><br><span class="line">mapStudent.erase(mapStudent.<span class="built_in">begin</span>(), mapStudent.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//等同于mapStudent.clear()</span></span><br></pre></td></tr></tbody></table></figure><p>4.map的大小<br>在往map里面插入了数据，我们怎么知道当前已经插入了多少数据呢，可以用size函数，用法如下：<br><code>int nSize = mapStudent.size();</code><br>5.map的基本操作函数<br> C++ maps是一种关联式容器，包含“关键字/值”对</p><p><code>begin()</code>         返回指向map头部的迭代器</p><p><code>clear()</code>        删除所有元素</p><p><code>count()</code>        返回指定元素出现的次数</p><p><code>empty()</code>    如果map为空则返回true</p><p><code>end()</code>           返回指向map末尾的迭代器</p><p><code>equal_range()</code>   返回特殊条目的迭代器对</p><p><code>erase()</code>        删除一个元素</p><p><code>find()</code>          查找一个元素</p><p><code>get_allocator()</code> 返回map的配置器</p><p><code>insert()</code>        插入元素</p><p><code>key_comp()</code>     返回比较元素key的函数</p><p><code>lower_bound()</code>  返回键值&gt;=给定元素的第一个位置</p><p><code>max_size()</code>      返回可以容纳的最大元素个数</p><p><code>rbegin()</code>       返回一个指向map尾部的逆向迭代器</p><p><code>rend()</code>         返回一个指向map头部的逆向迭代器</p><p><code>size()</code>          返回map中元素的个数</p><p><code>swap()</code>          交换两个map</p><p><code>upper_bound()</code>    返回键值&gt;给定元素的第一个位置</p><p><code>value_comp()</code>     返回比较元素value的函数</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNN|CNN|百度paddle学习</title>
      <link href="/posts/d902.html"/>
      <url>/posts/d902.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="深度学习三个步骤："><a href="#深度学习三个步骤：" class="headerlink" title="深度学习三个步骤："></a>深度学习三个步骤：</h3><ul><li>建立模型<ul><li>选择什么样的网络结构</li><li>选择多少层，每层选择多少神经元</li></ul></li><li>损失函数<ul><li>选择常用损失函数，平方误差，交叉熵…..</li></ul></li><li>参数学习<ul><li>梯度下降</li><li>反向传播算法</li></ul></li></ul><hr><!--more--><p>全连接神经网络DNN由于模型结构不够灵活，模型参数太多，通过模型改进，就出现了卷积神经网络CNN。<br>CNN在结构上有三大特性:</p><ol><li><p>局部连接，在我们进行图像识别的时候，不需要对整个图像进行处理，只需要关注图像中某些特殊的区域，一张640x480的图片，可能其中的16x16个像素</p></li><li><p>权重共享</p></li><li><p>下采样，减小图片的尺寸，<br>可以减少网络参数，加快训练速度。<br><img src="https://img-blog.csdnimg.cn/20200407200955527.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200407220711655.png" alt="在这里插入图片描述"><br>Pooling 池化层<br>通过下采样缩减feature map尺度。常用maxpooling和averagepooling.</p><h3 id="卷积神经网络的一般结构"><a href="#卷积神经网络的一般结构" class="headerlink" title="卷积神经网络的一般结构"></a>卷积神经网络的一般结构</h3><ol><li>卷积层+激活层和池化层的组合多次出现，用来提取特征</li><li>多个全连接或特殊的CNN结构作为输出层，用作分类器/检测器/分割器<h4 id="经典的CNN结构"><a href="#经典的CNN结构" class="headerlink" title="经典的CNN结构"></a>经典的CNN结构</h4><img src="https://img-blog.csdnimg.cn/20200407222124164.png" alt="在这里插入图片描述"><h4 id="AlexNet"><a href="#AlexNet" class="headerlink" title="AlexNet"></a>AlexNet</h4><img src="https://img-blog.csdnimg.cn/20200407222315157.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200407222331951.png" alt="在这里插入图片描述"><h4 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h4><img src="https://img-blog.csdnimg.cn/20200407222510204.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200407222521588.png" alt="在这里插入图片描述"><br>在AlexNet中用到一些非常大的卷积核，比如11x11、5x5的，感受野越大，看到的图片信息就越多，获得的特征会越好。但是随着参数和计算量的增加，如何衡量该使用多大的卷积核呢<br>Methods:学习到使用2个3x3的卷积核的组合比仅使用1个5x5的卷积核效果更佳，并且参数量降低。<br><img src="https://img-blog.csdnimg.cn/20200407222857372.png" alt="在这里插入图片描述"></li></ol></li></ol><p>这几天参加了百度飞桨举办的深度学习7日入门-CV疫情特辑课程，通过几个疫情AI实战案例，轻松入门深度学习。</p><h3 id="Day01-新冠疫情可视化"><a href="#Day01-新冠疫情可视化" class="headerlink" title="Day01 新冠疫情可视化"></a>Day01 新冠疫情可视化</h3><p>利用python爬取丁香园公开的统计数据，根据累计确诊数，使用pyecharts绘制疫情分布图，通过查阅Pycharts api比较容易实现</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span> Pie</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span> options <span class="keyword">as</span> opts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读原始数据文件</span></span><br><span class="line">today = datetime.date.today().strftime(<span class="string">'%Y%m%d'</span>)   <span class="comment">#20200315</span></span><br><span class="line">datafile = <span class="string">'data/'</span>+ today + <span class="string">'.json'</span></span><br><span class="line"><span class="keyword">with</span> open(datafile, <span class="string">'r'</span>, encoding=<span class="string">'UTF-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    json_array = json.loads(file.read())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分析全国实时确诊数据：'confirmedCount'字段</span></span><br><span class="line">china_data = []</span><br><span class="line"><span class="keyword">for</span> province <span class="keyword">in</span> json_array:</span><br><span class="line">    china_data.append((province[<span class="string">'provinceShortName'</span>], province[<span class="string">'confirmedCount'</span>]))</span><br><span class="line">china_data = sorted(china_data, key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)                 <span class="comment">#reverse=True,表示降序，反之升序</span></span><br><span class="line"></span><br><span class="line">print(china_data)</span><br><span class="line"><span class="comment"># 全国疫情地图</span></span><br><span class="line"><span class="comment"># 自定义的每一段的范围，以及每一段的特别的样式。</span></span><br><span class="line"></span><br><span class="line">labels = [data[<span class="number">0</span>] <span class="keyword">for</span> data <span class="keyword">in</span> china_data]</span><br><span class="line">counts = [data[<span class="number">1</span>] <span class="keyword">for</span> data <span class="keyword">in</span> china_data]</span><br><span class="line"></span><br><span class="line">m = Pie()</span><br><span class="line">m.add(<span class="string">""</span>, [list(z) <span class="keyword">for</span> z <span class="keyword">in</span> zip(labels, counts)])</span><br><span class="line"></span><br><span class="line"><span class="comment">#系列配置项,可配置图元样式、文字样式、标签样式、点线样式等</span></span><br><span class="line">m.set_series_opts(label_opts=opts.LabelOpts(formatter=<span class="string">"{b}: {c}"</span>)</span><br><span class="line">            )</span><br><span class="line"><span class="comment">#全局配置项,可配置标题、动画、坐标轴、图例等</span></span><br><span class="line">m.set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">'全国实时确诊数据'</span>,</span><br><span class="line">                                            subtitle=<span class="string">'数据来源：丁香园'</span>),</span><br><span class="line">                  legend_opts=opts.LegendOpts(is_show=<span class="literal">False</span>))</span><br><span class="line"><span class="comment">#render（）会生成本地 HTML 文件，默认会在当前目录生成 render.html 文件，也可以传入路径参数，如 m.render("mycharts.html")</span></span><br><span class="line">m.render(path=<span class="string">'/home/aistudio/data/饼状图.html'</span>)</span><br></pre></td></tr></tbody></table></figure><p><strong>结果图：</strong><br><img src="https://img-blog.csdnimg.cn/2020040808513127.png" alt="在这里插入图片描述"></p><h3 id="Day02手势识别"><a href="#Day02手势识别" class="headerlink" title="Day02手势识别"></a>Day02手势识别</h3><p>属于图像分类任务，根据图像的语义信息将不同类别图像区分开，是计算机视觉中重要的基本问题。手势识别属于图像分类中的一个细分类问题。<br>主要步骤：</p><ol><li>准备数据</li><li>配置网络</li><li>训练网络</li><li>模型评估</li><li>模型预测<br>定义的DNN全连接神经网络：</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义DNN网络</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDNN</span><span class="params">(fluid.dygraph.Layer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MyDNN,self).__init__()</span><br><span class="line">        self.hidden1 = Linear(<span class="number">100</span>,<span class="number">300</span>,act=<span class="string">"relu"</span>)</span><br><span class="line">        self.hidden2 = Linear(<span class="number">300</span>,<span class="number">500</span>,act=<span class="string">"relu"</span>)</span><br><span class="line">        self.hidden3 = Linear(<span class="number">500</span>,<span class="number">100</span>,act=<span class="string">"relu"</span>)</span><br><span class="line">        self.hidden4 = Linear(<span class="number">3</span>*<span class="number">100</span>*<span class="number">100</span>, <span class="number">10</span>, act=<span class="string">"softmax"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,input)</span>:</span>   </span><br><span class="line">       x=self.hidden1(input) </span><br><span class="line">      <span class="comment">#print(input.shape)</span></span><br><span class="line">       x=self.hidden2(x)</span><br><span class="line">       x=self.hidden3(x)</span><br><span class="line">       x=fluid.layers.reshape(x,shape=[<span class="number">-1</span>,<span class="number">3</span>*<span class="number">100</span>*<span class="number">100</span>])</span><br><span class="line">       <span class="comment">#print(x.shape)</span></span><br><span class="line">       y=self.hidden4(x)</span><br><span class="line">       <span class="keyword">return</span> y;</span><br></pre></td></tr></tbody></table></figure><p>其中通过查看Paddle API，更改了几种不同的优化器和模型参数，最终accuracy还是达不到90%，还是不太会该如何选取参数。<br>识别结果：<img src="https://img-blog.csdnimg.cn/20200408090753891.png" alt="在这里插入图片描述"></p><h3 id="Day03-车牌识别"><a href="#Day03-车牌识别" class="headerlink" title="Day03-车牌识别"></a>Day03-车牌识别</h3><p>通过对经典的卷积网络模型比如LeNet的解析， 分为多个卷积层，激活层，池化层，然后是全连接层，最后通过Softmax函数将各分类标签通过概率表达出来。学会每一层的维度计算。<br>车牌识别中，需要事先将车牌中每个字符例如’沪’，’C’等切分出来，共形成65个分类，通过深度学习实际上最后预测的是车牌上的每个字符最大概率的预测字符，然后再拼接出来形成最终的识别结果。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义网络</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLeNet</span><span class="params">(fluid.dygraph.Layer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MyLeNet,self).__init__()</span><br><span class="line">        self.hidden1_1 = Conv2D(<span class="number">1</span>,<span class="number">28</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">        self.hidden1_2 = Pool2D(pool_size=<span class="number">2</span>,pool_type=<span class="string">'max'</span>,pool_stride=<span class="number">1</span>)</span><br><span class="line">        self.hidden2_1 = Conv2D(<span class="number">28</span>,<span class="number">32</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">        self.hidden2_2 = Pool2D(pool_size=<span class="number">2</span>,pool_type=<span class="string">'max'</span>,pool_stride=<span class="number">1</span>)</span><br><span class="line">        self.hidden3 = Conv2D(<span class="number">32</span>,<span class="number">32</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">        self.hidden4 = Linear(<span class="number">32</span>*<span class="number">10</span>*<span class="number">10</span>,<span class="number">65</span>,act=<span class="string">'softmax'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,input)</span>:</span></span><br><span class="line">        x=self.hidden1_1(input);</span><br><span class="line">        x=self.hidden1_2(x);</span><br><span class="line">        x=self.hidden2_1(x);</span><br><span class="line">        x=self.hidden2_2(x);</span><br><span class="line">        x=self.hidden3(x);</span><br><span class="line">        x=fluid.layers.reshape(x,shape=[<span class="number">-1</span>,<span class="number">32</span>*<span class="number">10</span>*<span class="number">10</span>])</span><br><span class="line">        y=self.hidden4(x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> y</span><br></pre></td></tr></tbody></table></figure><h3 id="Day04-口罩分类"><a href="#Day04-口罩分类" class="headerlink" title="Day04-口罩分类"></a>Day04-口罩分类</h3><p>检测在密集人流区域中戴口罩和未戴口罩的所有人脸，同时判断该人是否佩戴口罩。<br>vgg模型配置<br><img src="https://img-blog.csdnimg.cn/2020040809293612.png" alt="在这里插入图片描述"><br>vgg网络定义:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VGGNet</span><span class="params">(fluid.dygraph.Layer)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    VGG网络</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(VGGNet, self).__init__()</span><br><span class="line">        self.convpool01=ConvPool(<span class="number">3</span>,<span class="number">64</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,act=<span class="string">"relu"</span>)</span><br><span class="line">        self.convpool02=ConvPool(<span class="number">64</span>,<span class="number">128</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,act=<span class="string">"relu"</span>)</span><br><span class="line">        self.convpool03=ConvPool(<span class="number">128</span>,<span class="number">256</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,act=<span class="string">"relu"</span>)</span><br><span class="line">        self.convpool04=ConvPool(<span class="number">256</span>,<span class="number">512</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,act=<span class="string">"relu"</span>)</span><br><span class="line">        self.convpool05=ConvPool(<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,act=<span class="string">"relu"</span>)</span><br><span class="line">        self.pool_5_shape=<span class="number">512</span>*<span class="number">7</span>*<span class="number">7</span></span><br><span class="line">        self.fc01=fluid.dygraph.Linear(self.pool_5_shape,<span class="number">256</span>,act=<span class="string">"relu"</span>)</span><br><span class="line">        self.fc02=fluid.dygraph.Linear(<span class="number">256</span>,<span class="number">256</span>,act=<span class="string">"relu"</span>)</span><br><span class="line">        self.fc03=fluid.dygraph.Linear(<span class="number">256</span>,<span class="number">2</span>,act=<span class="string">"softmax"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs, label=None)</span>:</span></span><br><span class="line">        <span class="string">"""前向计算"""</span></span><br><span class="line">        <span class="comment">#print(inputs.shape)</span></span><br><span class="line">        x=self.convpool01(inputs)</span><br><span class="line">        <span class="comment">#print(x.shape)</span></span><br><span class="line">        x=self.convpool02(x)</span><br><span class="line">        <span class="comment">#print(x.shape)</span></span><br><span class="line">        x=self.convpool03(x)</span><br><span class="line">        x=self.convpool04(x)</span><br><span class="line">        x=self.convpool05(x)</span><br><span class="line">        x=fluid.layers.reshape(x,shape=[<span class="number">-1</span>,<span class="number">512</span>*<span class="number">7</span>*<span class="number">7</span>])</span><br><span class="line">        x=self.fc01(x)</span><br><span class="line">        x=self.fc02(x)</span><br><span class="line">        x=self.fc03(x)</span><br><span class="line">        <span class="keyword">if</span> label <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            acc=fluid.layers.accuracy(input=x,label=label)</span><br><span class="line">            <span class="keyword">return</span> x, acc</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> x</span><br></pre></td></tr></tbody></table></figure><h3 id="人流密度检测问题"><a href="#人流密度检测问题" class="headerlink" title="人流密度检测问题"></a>人流密度检测问题</h3><p>本竞赛所用训练和测试图片均来自一般监控场景，但包括多种视角（如低空、高空、鱼眼等），图中行人的相对尺寸也会有较大差异。部分训练数据参考了公开数据集（如ShanghaiTech [1], UCF-CC-50 [2], WorldExpo’10 [3]，Mall [4] 等）。</p><p>本竞赛的数据标注均在对应json文件中，每张训练图片的标注为以下两种方式之一：</p><p>（1）部分数据对图中行人提供了方框标注（boundingbox），格式为[x, y, w, h][x,y,w,h]；</p><p>（2）部分图对图中行人提供了头部的打点标注，坐标格式为[x, y][x,y]。</p><p>此外部分图片还提供了忽略区（ignore_region）标注，格式为[x_0, y_0, x_1, y_1, …, x_n, y_n]组成的多边形（注意一张图片可能有多个多边形忽略区），图片在忽略区内的部分不参与训练/测试。<br>人流密度检测网络训练使用的CNN模型网络配置如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNN</span><span class="params">(fluid.dygraph.Layer)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    网络</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(CNN, self).__init__()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        self.conv01_1 = fluid.dygraph.Conv2D(num_channels=<span class="number">3</span>, num_filters=<span class="number">64</span>,filter_size=<span class="number">3</span>,padding=<span class="number">1</span>,act=<span class="string">"relu"</span>)</span><br><span class="line">        self.pool01=fluid.dygraph.Pool2D(pool_size=<span class="number">2</span>,pool_type=<span class="string">'max'</span>,pool_stride=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.conv02_1 = fluid.dygraph.Conv2D(num_channels=<span class="number">64</span>, num_filters=<span class="number">128</span>,filter_size=<span class="number">3</span>, padding=<span class="number">1</span>,act=<span class="string">"relu"</span>)</span><br><span class="line">        self.pool02=fluid.dygraph.Pool2D(pool_size=<span class="number">2</span>,pool_type=<span class="string">'max'</span>,pool_stride=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.conv03_1 = fluid.dygraph.Conv2D(num_channels=<span class="number">128</span>, num_filters=<span class="number">256</span>,filter_size=<span class="number">3</span>, padding=<span class="number">1</span>,act=<span class="string">"relu"</span>)</span><br><span class="line">        self.pool03=fluid.dygraph.Pool2D(pool_size=<span class="number">2</span>,pool_type=<span class="string">'max'</span>,pool_stride=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        self.conv04_1 = fluid.dygraph.Conv2D(num_channels=<span class="number">256</span>, num_filters=<span class="number">512</span>,filter_size=<span class="number">3</span>, padding=<span class="number">1</span>,act=<span class="string">"relu"</span>)</span><br><span class="line"></span><br><span class="line">        self.conv05_1 = fluid.dygraph.Conv2D(num_channels=<span class="number">512</span>, num_filters=<span class="number">512</span>,filter_size=<span class="number">3</span>,padding=<span class="number">1</span>, act=<span class="string">"relu"</span>)</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">        self.conv06 = fluid.dygraph.Conv2D(num_channels=<span class="number">512</span>,num_filters=<span class="number">256</span>,filter_size=<span class="number">3</span>,padding=<span class="number">1</span>,act=<span class="string">'relu'</span>)</span><br><span class="line">        self.conv07 = fluid.dygraph.Conv2D(num_channels=<span class="number">256</span>,num_filters=<span class="number">128</span>,filter_size=<span class="number">3</span>,padding=<span class="number">1</span>,act=<span class="string">'relu'</span>)</span><br><span class="line">        self.conv08 = fluid.dygraph.Conv2D(num_channels=<span class="number">128</span>,num_filters=<span class="number">64</span>,filter_size=<span class="number">3</span>,padding=<span class="number">1</span>,act=<span class="string">'relu'</span>)</span><br><span class="line">        self.conv09 = fluid.dygraph.Conv2D(num_channels=<span class="number">64</span>,num_filters=<span class="number">1</span>,filter_size=<span class="number">1</span>,padding=<span class="number">0</span>,act=<span class="literal">None</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs, label=None)</span>:</span></span><br><span class="line">        <span class="string">"""前向计算"""</span></span><br><span class="line">        out = self.conv01_1(inputs)</span><br><span class="line">        </span><br><span class="line">        out = self.pool01(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv02_1(out)</span><br><span class="line">       </span><br><span class="line">        out = self.pool02(out)</span><br><span class="line">        out = fluid.layers.dropout(x=out,dropout_prob=<span class="number">0.25</span>)</span><br><span class="line">        out = self.conv03_1(out)</span><br><span class="line">        </span><br><span class="line">        out = self.pool03(out)</span><br><span class="line">        out = fluid.layers.dropout(x=out,dropout_prob=<span class="number">0.25</span>)</span><br><span class="line">        out = self.conv04_1(out)    </span><br><span class="line">        out = fluid.layers.dropout(x=out,dropout_prob=<span class="number">0.5</span>)</span><br><span class="line">        out = self.conv05_1(out)</span><br><span class="line">        out = fluid.layers.dropout(x=out,dropout_prob=<span class="number">0.5</span>)</span><br><span class="line">        out = self.conv06(out)</span><br><span class="line">        out = self.conv07(out)</span><br><span class="line">        out = self.conv08(out)</span><br><span class="line">        out = self.conv09(out)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></tbody></table></figure><p>通过几天的实践学习，掌握了训练的一般步骤，按照数据处理，配置网络，训练网络，模型评估和模型预测这样的步骤，再就是本地没GPU加速，运用百度paddle提供免费的算力，进行参数调优，但是对如何调整参数获得更好的效果，还是不太会。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python 卷积神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm汉化之后无法打开setting设置</title>
      <link href="/posts/d098.html"/>
      <url>/posts/d098.html</url>
      
        <content type="html"><![CDATA[<p>我在安装了pycharm汉化包之后，发现pycharm点击设置setting没反应，不能打开。网上找了解决方案：</p><p>一般的问题都是装了中文汉化包resources_cn.jar造成的，解决办法：</p><a id="more"></a><ol><li><p>更换一个汉化包<br>把这里的两个jar包放到PyCharm安装目录里的lib目录里面即可。同时删掉之前的汉化包。<br>链接：<a href="https://pan.baidu.com/s/1khtnNGAkMkwkGsDjzw0_zA" target="_blank" rel="noopener">https://pan.baidu.com/s/1khtnNGAkMkwkGsDjzw0_zA</a><br>提取码：u1zb</p></li><li><p>将汉化包都删除，只留下原版的resources_en.jar   </p></li></ol><p><img src="https://img-blog.csdnimg.cn/20200402103206811.png" alt="在这里插入图片描述"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习|Andrew Ng|学习笔记</title>
      <link href="/posts/4f0c.html"/>
      <url>/posts/4f0c.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><font color="red">Machine Learning(机器学习)</font>是研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。</p><p>有一个算法叫支持向量机，里面有个巧妙的数学技巧，能让计算机处理无限多个特征。</p><!--more--><p><font color="red">监督学习</font>：其基本思想是数据集中的每个样本都有相应的“正确答案”，再根据这些样本作出预测。例如垃圾邮件问题。<br><font color="red">无监督学习</font>：在无监督学习中，不同于监督学习的数据的样子（每条数据都有特定的标签，标明零件是正品还是次品），即无监督学习中没有任何的标签或者是有相同的标签或者就是没标签。<br>针对数据集，无监督学习就能判断出数据有两个不同的聚集簇，无监督学习算法可能会把这些数据分成两个不同的簇，所以叫做聚类算法。例如google新闻<br>聚类只是无监督学习中的一种，</p><p>损失函数（代价函数），也被称作平方误差函数，用J(θ_0,θ_1)表示<br><img src="https://img-blog.csdnimg.cn/2020040111102134.png" alt="在这里插入图片描述"><br>梯度下降是一个用来求函数最小值的算法，我们将使用梯度下降算法来求出代价函数<br>J(θ_0,θ_1)的最小值。<br>梯度下降背后的思想是：开始时我们随机选择一个参数的组合θ_0,θ_1,………….θ_n计算代价函数，然后我们寻找下一个能让代价函数值下降最多的参数组合。我们持续这么做直到找到一个局部最小值（local minimum），因为我们并没有尝试完所有的参数组合，所以不能确定我们得到的局部最小值是否便是全局最小值（global minimum），选择不同的初始参数组合，可能会找到不同的局部最小值。</p><p>同时更新是梯度下降中的一种常用方法。</p><p>假设你将θ_1初始化在局部最低点，结果是局部最优点的导数将等于零，新的θ_1等于原来的θ_1，如果参数已经处于局部最低点，那么梯度下降法更新其实什么都没做，它不会改变参数的值。这也解释了为什么即使学习速率α保持不变时，梯度下降也可以收敛到局部最低点。</p><h4 id="线性回归算法："><a href="#线性回归算法：" class="headerlink" title="线性回归算法："></a>线性回归算法：</h4><p> <img src="https://img-blog.csdnimg.cn/20200401111049338.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200401111055755.png" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200401111110722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>开始随机选择一系列的参数值，计算所有的预测结果后，再给所有的参数一个新的值，如此循环直到收敛。</p><h3 id="逻辑回归："><a href="#逻辑回归：" class="headerlink" title="逻辑回归："></a>逻辑回归：</h3><p><img src="https://img-blog.csdnimg.cn/20200401111126104.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200401111130905.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200401111134444.png" alt="在这里插入图片描述"></p><h4 id="逻辑回归的代价函数："><a href="#逻辑回归的代价函数：" class="headerlink" title="逻辑回归的代价函数："></a>逻辑回归的代价函数：</h4><p> <img src="https://img-blog.csdnimg.cn/20200401111259295.png" alt="在这里插入图片描述"><br>根据这个代价函数，为了拟合出参数，我们要找出让J(θ)取得最小值的参数θ<br><img src="https://img-blog.csdnimg.cn/20200401111314716.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200401111348623.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200401111403574.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200401111416704.png" alt="在这里插入图片描述"><br>线性回归和逻辑回归更新参数的规则看起来基本相同，但由于假设的定义发生了变化，所以逻辑函数的梯度下降，跟线性回归的梯度下降实际上是两个完全不同的东西。<br> <img src="https://img-blog.csdnimg.cn/20200401111435143.png" alt="在这里插入图片描述"></p><h3 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h3><p>线性回归和逻辑回归，它们能够有效地解决许多问题，但是当将它们应用到某些特定的机器学习应用时，会遇到过拟合(over-fitting)的问题，可能会导致它们效果很差，正则化技术可以改善或者减少过度拟合问题。<br> <img src="https://img-blog.csdnimg.cn/20200401111444532.png" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/20200401111458493.png" alt="在这里插入图片描述"></p><p>过拟合问题的处理：1.丢弃一些不能帮助我们正确预测的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙（例如<strong>PCA</strong>）<br>2.正则化。  保留所有的特征，但是减少参数的大小（<strong>magnitude</strong>）</p><p>回归问题中我们的模型是：<img src="https://img-blog.csdnimg.cn/2020040111154276.png" alt="在这里插入图片描述"><br>正是这些高次项导致了过拟合的产生，所以如果我们能让这些高次项的系数接近于 0 的话，就能很好的拟合了。<br>我们要做的就是在一定程度上减小这些参数θ的值，这就是正则化的基本方法。</p><p>特征的直观理解：<br>从本质上讲，神经网络能够通过学习得出其自身的一系列特征。在普通的<font color="red"> 逻辑回归</font>中，我们被限制为使用数据中的原始特征${x_1},{x_2}, \ldots ,{x_n}$，我们虽然可以使用一些二项式项来组合这些特征，但是我们仍然受到这些原始特征的限制。<br>在神经网络中，原始特征只是输入层，在我们上面三层的神经网络例子中，第三层也就是输出层做出的预测利用的是第二层的特征，而非输入层中的原始特征，我们可以认为第二层中的特征是神经网络通过学习后自己得出的一系列用于预测输出变量的新特征。</p><h3 id="反向传播算法"><a href="#反向传播算法" class="headerlink" title="反向传播算法"></a>反向传播算法</h3><p>为了计算代价函数的偏导数<img src="https://img-blog.csdnimg.cn/20200401142148249.png" alt="在这里插入图片描述"> ，我们需要采用一种反向传播算法，首先计算最后一层的误差，然后再一层一层反向求出各层的误差，直到倒数第二层。</p><h4 id="使用神经网络时候的步骤："><a href="#使用神经网络时候的步骤：" class="headerlink" title="使用神经网络时候的步骤："></a>使用神经网络时候的步骤：</h4><p>网络结构：第一件要做的事是选择网络结构，即决定选择多少层以及决定每层分别有多<br>少个单元。<br>第一层的单元数即我们训练集的特征数量。<br>最后一层的单元数是我们训练集的结果的类的数量。<br>如果隐藏层数大于 1，确保每个隐藏层的单元个数相同，通常情况下隐藏层单元的个数<br>越多越好。我们真正要决定的是隐藏层的层数和每个中间层的单元数。<br>训练神经网络：</p><ol><li>参数的随机初始化</li><li>利用正向传播方法计算所有的h_θ (x)</li><li>编写计算代价函数J的代码</li><li>利用反向传播方法计算所有偏导数</li><li>利用数值检验方法检验这些偏导数</li><li>使用优化算法来最小化代价函数<h4 id="应用机器学习，决定下一步该做什么"><a href="#应用机器学习，决定下一步该做什么" class="headerlink" title="应用机器学习，决定下一步该做什么"></a>应用机器学习，决定下一步该做什么</h4></li></ol><p>　　&nbsp; &nbsp;&nbsp;&nbsp; 在开发一个机器学习系统，或者想试着改进一个机器学习系统的性能，应该如何决定接下来应该选择哪条道路？<br>　　为了解释这一问题，我想仍然使用预测房价的学习例子，假如你已经完成了正则化线性回归，也就是最小化代价函数。一种办法是使用更多的训练样本，另一个方法是尝试选用更少的特征集。<br>　　当我们运用训练好了的模型来预测未知数据的时候发现有较大的误差，我们下一步可以做什么？   通常获得更多的训练实例是有效的，但代价较大。</p><p>考虑采用下面的方法:<br>1.尝试减少特征的数量<br>2.尝试获得更多的特征<br>3.尝试增加多项式特征<br>4.尝试减少正则化程度λ<br>5.尝试增加正则化程度λ<br>当你运行一个学习算法时，如果这个算法的表现不理想，那么多半是出现两种情况：要么是偏差比较大，要么是方差比较大。换句话说，出现的情况要么是欠拟合，要么是过拟合问题。<br>将训练集和交叉验证集的代价函数误差与多项式的次数绘制在同一张图表上来分析：<br> <img src="https://img-blog.csdnimg.cn/20200401181606757.png" alt="在这里插入图片描述"><br>上面的曲线是交叉验证集，下面的曲线是训练集。<br>对于训练集，当d较小时，模型拟合程度更低，误差较大；随着d的增长，拟合程度提高，误差减小。<br>对于交叉验证集，当d较小时，模型拟合程度低，误差较大；但是随着d的增长，误差呈现先减小后增大的趋势，转折点是我们的模型开始过拟合训练数据集的时候。<br><img src="https://img-blog.csdnimg.cn/2020040118163087.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><font color="red">训练集误差和交叉验证集误差近似时：偏差/欠拟合<br>交叉验证集误差远大于训练集误差时：方差/过拟合    </font></p><h4 id="正则化和偏差、方差"><a href="#正则化和偏差、方差" class="headerlink" title="正则化和偏差、方差"></a>正则化和偏差、方差</h4><p>在我们在训练模型的过程中，一般会使用一些正则化方法来防止过拟合。但是我们可能<br>会正则化的程度太高或太小了，选择 λ 的值时也需要思考这些问题。</p><p>将训练集和交叉验证集模型的代价函数误差与 λ 的值绘制在一张图表上：<br> <img src="https://img-blog.csdnimg.cn/20200401181732215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当λ较小时，训练集误差较小（过拟合）而交叉验证集误差较大；<br>随着λ的增加，训练集误差不断增加（欠拟合），而交叉验证集误差则是先减小后<br>增加。</p><h4 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h4><p>学习曲线是一种很好的工具，可以用来判断某一个学习算法是否处于偏差、方差问题。学习曲线是学习算法的一个很好的合理检验。<br>学习曲线是将训练集误差和交叉验证集误差作为训练集实例数量（m）的函数绘制的图表</p><h4 id="逻辑回归算法是分类算法"><a href="#逻辑回归算法是分类算法" class="headerlink" title="逻辑回归算法是分类算法"></a>逻辑回归算法是分类算法</h4><p>适用于标签Y取值离散的情况，如1001。</p><p>梯度下降算法的每次迭代受到学习率的影响，如果学习率α过小，则达到收敛所需的迭<br>代次数会非常高；如果学习率α过大，每次迭代可能不会减小代价函数，可能会越过局部最<br>小值导致无法收敛。</p><h4 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a>泛化能力</h4><p>  泛化能力就是模型对未知数据的预测能力。在实际当中，我们通常通过测试误差来评价学习方法的泛化能力。</p><h4 id="机器学习中训练集、交叉验证集、测试集的理解"><a href="#机器学习中训练集、交叉验证集、测试集的理解" class="headerlink" title="机器学习中训练集、交叉验证集、测试集的理解"></a>机器学习中训练集、交叉验证集、测试集的理解</h4><p><font color="red">训练集（train set）</font> —— 用于模型拟合的数据样本。<br><font color="red">验证集（development set）</font>—— 是模型训练过程中单独留出的样本集，它可以用于调整模型的超参数和用于对模型的能力进行初步评估。<br>   在神经网络中， 我们用验证数据集去寻找最优的网络深度（number of hidden layers)，或者决定反向传播算法的停止点或者在神经网络中选择隐藏层神经元的数量；<br>在普通的机器学习中常用的交叉验证（Cross Validation) 就是把训练数据集本身再细分成不同的验证数据集去训练模型。<br><font color="red">测试集</font> —— 用来评估模最终模型的泛化能力。但不能作为调参、选择特征等算法相关的选择的依据。<br> <img src="https://img-blog.csdnimg.cn/20200401181903551.png" alt="在这里插入图片描述"><br>关于训练集、验证集、测试集的一个形象的比喻：</p><pre><code>训练集-----------学生的课本；学生 根据课本里的内容来掌握知识。验证集------------作业，通过作业可以知道 不同学生学习情况、进步的速度快慢。测试集-----------考试，考的题是平常都没有见过，考察学生举一反三的能力。</code></pre><p>传统上，一般三者切分的比例是：6：2：2，验证集并不是必须的</p><h4 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h4><p>构建一个学习算法的推荐方法为：</p><ol><li>从一个简单的能快速实现的算法开始，实现该算法并用交叉验证集数据测试这个算法  </li><li>绘制学习曲线，决定是增加更多数据，或者添加更多特征，还是其他选择</li><li>进行误差分析：人工检查交叉验证集中我们算法中产生预测误差的实例，看看这些实例<br>是否有某种系统化的趋势<br>==推荐在交叉验证集上来实施误差分析，而不是在测试集上。==</li></ol><p>单变量线性回归问题：<br>全局最小点是局部下降算法的最大点，<br>SVM（支持向量机）、奇异值分解。</p><h4 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h4><p>SVM的全称是Support Vector Machine，即支持向量机，主要用于解决模式识别领域中的数据分类问题，属于有监督学习算法的一种。SVM要解决的问题可以用一个经典的二分类问题加以描述。</p><h4 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h4><p> <img src="https://img-blog.csdnimg.cn/20200401181941717.png" alt="在这里插入图片描述"><br>主要是拟合一条直线，使尽可能多的点落在直线上。</p><h4 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h4><p>逻辑回归虽然名字叫做回归，但实际上却是一种分类学习方法。 线性回归完成的是回归拟合任务，而对于分类任务，我们同样需要一条线，但不是去拟合每个数据点，而是把不同类别的样本区分开来。<br>bagging是一种用来提高学习算法准确度的方法</p><h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><p><a href="https://blog.csdn.net/jiaoyangwm/article/details/79525237" target="_blank" rel="noopener">https://blog.csdn.net/jiaoyangwm/article/details/79525237</a></p><pre><code>决策树与随机森林都属于机器学习中监督学习的范畴，主要用于分类问题。</code></pre><p>决策树算法有这几种：ID3、C4.5、CART，基于决策树的算法有bagging、随机森林、GBDT等。决策树是一种利用树形结构进行决策的算法，对于样本数据根据已知条件或叫特征进行分叉，最终建立一棵树，树的叶子结节标识最终决策。新来的数据便可以根据这棵树进行判断。随机森林是一种通过多棵决策树进行优化决策的算法。</p><h4 id="SVM是否属于神经网络"><a href="#SVM是否属于神经网络" class="headerlink" title="SVM是否属于神经网络"></a>SVM是否属于神经网络</h4><p><a href="http://blog.sina.com.cn/s/blog_7ad48fee0100vz2f.html" target="_blank" rel="noopener">参考链接</a><br><img src="https://img-blog.csdnimg.cn/20200401182152994.png" alt="在这里插入图片描述"><br>SVM效果很大程度依赖kernel的设计<br>具体地说，线性SVM的计算部分和一个单层神经网络一样，就是一个矩阵乘积。SVM的关键在于它的Hinge Loss以及maximum margin的想法。其实这个loss也是可以用在神经网络里的（参见object detection的R-CNN方法）。对于处理非线性数据，SVM和神经网络走了两条不同的道路：神经网络通过多个隐层的方法来实现非线性的函数，有一些理论支持（比如说带隐层的神经网络可以模拟任何函数），但是目前而言还不是非常完备；SVM则采用了kernel trick的方法，这个在理论上面比较完备（RKHS，简单地说就是一个泛函的线性空间）。两者各有好坏，神经网络最近的好处是网络设计可以很灵活，但是老被人说跳大神；SVM的理论的确漂亮，但是kernel设计不是那么容易，所以最近没有那么热了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-李宏毅| keras demo | python</title>
      <link href="/posts/33cb.html"/>
      <url>/posts/33cb.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="利用keras实现手写数字辨识"><a href="#利用keras实现手写数字辨识" class="headerlink" title="利用keras实现手写数字辨识"></a>利用keras实现手写数字辨识</h3><p>首先要建一个Network scratch，input是<code>28∗28</code>的dimension，其实就是说这是一张image，image的解析度是<code>28∗28</code>，把它拉成长度是<code>28∗28</code>维的向量。output呢？现在做的是手写数字辨识，所以要决定它是0-9的哪个数字，output就是每一维对应的数字，所以output就是10维。中间假设你要两个layer，每个layer有500个hidden neuro</p><!--more--><h4 id="创建一个network"><a href="#创建一个network" class="headerlink" title="创建一个network"></a>创建一个network</h4><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">model</span>=Sequential()</span><br></pre></td></tr></tbody></table></figure><p>添加第一个hidden layer,  　Dense意思为添加一个全连接网络，Ｃon2d表示添加一个convolution layer卷积层，input_dim表示输入维度，units表示hidden layer的神经元个数，activation表示激活函数，可以为relu，sigmoid，tanh，softmax，hard_sigmoid，linear等</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(<span class="constructor">Dense(<span class="params">input_dim</span>=28<span class="operator">*</span>28,<span class="params">units</span>=500,<span class="params">activation</span>='<span class="params">relu</span>')</span>)</span><br></pre></td></tr></tbody></table></figure><p>再添加一个layer</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(<span class="constructor">Dense(<span class="params">units</span>=500,<span class="params">activation</span>='<span class="params">relu</span>')</span>)</span><br></pre></td></tr></tbody></table></figure><p>最后的输出层，由于是数字识别一共10个数字，所以output是10维，units=10,激活函数选择softmax</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(<span class="constructor">Dense(<span class="params">units</span>=10,<span class="params">activation</span>='<span class="params">softmax</span>')</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="configuration配置"><a href="#configuration配置" class="headerlink" title="configuration配置"></a>configuration配置</h4><p>　　需要定义loss function，选择optimizer，以及评估指标metrics，其实所有的optimizer都是Gradent descent based，只是有不同的方法来决定learning rate，比如Adam，SGD，RMSprop，Adagrad，Adalta，Adamax ，Nadam等，configuration完成之后就可以开始train创建的Network。</p><figure class="highlight gams"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">model</span>.compile(loss=<span class="string">'categorical crossentropy'</span>,optimizer=<span class="string">'adam'</span>,metrics=[<span class="string">'accuracy'</span>])</span><br></pre></td></tr></tbody></table></figure><h4 id="pick-the-best-function"><a href="#pick-the-best-function" class="headerlink" title="pick the best function"></a>pick the best function</h4><p>model.fit方法，开始用Gradent Descent帮你去train你的Network，那么你要给它你的train_data input 和label，这里x_train代表image，y_train代表image的label，关于x_train和y_train的格式，你都要存成numpy array。</p><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">100</span>,epochs=<span class="number">20</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="使用模型"><a href="#使用模型" class="headerlink" title="使用模型"></a>使用模型</h4><p>接下来要拿train的network来使用，使用有两个不同的情景，这两个不同的情景一个是evaluation，意思就是说你的model在test data 上到底表现得怎样，call evaluate这个函数，然后把x_test，y_test喂给它，就会自动给你计算出Accuracy。它会output一个二维的向量，第一个维度代表了在test set上loss，第二个维度代表了在test set上的accuracy，这两个值是不一样的。loss可能用cross_entropy，Accuraccy是对与不对，即正确率。</p><ul><li>case 1<figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">score</span> = model.evaluate(x_test,y_test)</span><br><span class="line"><span class="keyword">print</span>('<span class="keyword">Total</span> loss <span class="keyword">on</span> Testiong <span class="keyword">Set</span> : ',<span class="keyword">score</span>[0])</span><br><span class="line"><span class="keyword">print</span>('Accuracy of Testiong <span class="keyword">Set</span> : ',<span class="keyword">score</span>[1])</span><br></pre></td></tr></tbody></table></figure>第二种是做predict，就是系统上线后，没有正确答案的，call predict进行预测</li><li>case 2<figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">result</span> = model.predict(x_test)</span><br></pre></td></tr></tbody></table></figure><h4 id="快速理解epoch、iteration和batch"><a href="#快速理解epoch、iteration和batch" class="headerlink" title="快速理解epoch、iteration和batch"></a>快速理解epoch、iteration和batch</h4>假设有1000个训练样本，batch_size=20,则iteration就是50，将所有的训练样本在同一个模型中训练5遍<br>batch_size * iteration = 样本数量，epoch=5.<br>所有样本完成一次前向传播+反向传播为一个epoch<blockquote><p>batchsize：简单点说，就是我们一次要将多少个数据扔进模型去训练，这个值介于1和训练样本总个数之间。<br>iteration：迭代的次数（向模型中扔数据的次数）,一个迭代= 同一批batchsize数据的一个正向通过+一个反向通过。<br>Epoch: 训练集中的全部样本都在训练模型中走了一遍，并返回一次（有去有回），为一个epoch。</p></blockquote></li></ul><p>由于这个例子中需要使用MNIST数据集，给出的源码中使用(x_train, y_train), (x_test, y_test) = mnist.load_data()  下载数据集，但是过程中需要翻墙，故我在此先将MNIST数据集的包下载下来，然后稍微修改下代码，完成数据的import.其中，numpy.load() 函数可以读取 .npy .npz 等文件类型，并返回对应的数据类型。<br>1）如果文件类型是 .pny 则返回一个1维数组。<br>2）如果文件类型是 .npz 则返回一个类似字典的数据类型，包含 {filename: array} 键值对。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">'C:\\Users\\Administrator\\Desktop\\mnist.npz'</span></span><br><span class="line">    f = np.load(path)</span><br><span class="line">    x_train, y_train = f[<span class="string">'x_train'</span>], f[<span class="string">'y_train'</span>]</span><br><span class="line">    x_test, y_test = f[<span class="string">'x_test'</span>], f[<span class="string">'y_test'</span>]</span><br><span class="line">    f.close()</span><br></pre></td></tr></tbody></table></figure><p>下载地址：<a href="https://pan.baidu.com/s/1EQdC4QfNL4OeMeWtJk9DEQ" target="_blank" rel="noopener">mnist数据集</a><br>提取码：gyt8 </p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers.core <span class="keyword">import</span> Dense,Dropout,Activation</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD,Adam</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> np_utils</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></span><br><span class="line">    path = <span class="string">'C:\\Users\\Administrator\\Desktop\\mnist.npz'</span></span><br><span class="line">    f = np.load(path)</span><br><span class="line">    x_train, y_train = f[<span class="string">'x_train'</span>], f[<span class="string">'y_train'</span>]</span><br><span class="line">    x_test, y_test = f[<span class="string">'x_test'</span>], f[<span class="string">'y_test'</span>]</span><br><span class="line">    f.close()</span><br><span class="line">    number=<span class="number">10000</span></span><br><span class="line">    x_train=x_train[<span class="number">0</span>:number]</span><br><span class="line">    y_train=y_train[<span class="number">0</span>:number]</span><br><span class="line">    x_train=x_train.reshape(number,<span class="number">28</span>*<span class="number">28</span>)</span><br><span class="line">    x_test=x_test.reshape(x_test.shape[<span class="number">0</span>],<span class="number">28</span>*<span class="number">28</span>)</span><br><span class="line">    x_train=x_train.astype(<span class="string">'float32'</span>)</span><br><span class="line">    x_test=x_test.astype(<span class="string">'float32'</span>)</span><br><span class="line">    y_train=np_utils.to_categorical(y_train,<span class="number">10</span>)</span><br><span class="line">    y_test=np_utils.to_categorical(y_test,<span class="number">10</span>)</span><br><span class="line">    x_train=x_train</span><br><span class="line">    x_test=x_test</span><br><span class="line">    x_train=x_train/<span class="number">255</span></span><br><span class="line">    x_test=x_test/<span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> (x_train,y_train),(x_test,y_test)</span><br><span class="line"></span><br><span class="line">(x_train,y_train),(x_test,y_test)=load_data() <span class="comment">#载入数据</span></span><br><span class="line"></span><br><span class="line">model=Sequential()</span><br><span class="line">model.add(Dense(input_dim=<span class="number">28</span>*<span class="number">28</span>,units=<span class="number">633</span>,activation=<span class="string">'sigmoid'</span>)) <span class="comment">#维度28*28，激活函数为sigmoid</span></span><br><span class="line">model.add(Dense(units=<span class="number">633</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">633</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">model.add(Dense(units=<span class="number">689</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line"></span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,activation=<span class="string">'softmax'</span>)) <span class="comment">#输出层一定要是10维，units=10;</span></span><br><span class="line"></span><br><span class="line">model.compile(loss=<span class="string">'mse'</span>,optimizer=SGD(lr=<span class="number">0.1</span>),metrics=[<span class="string">'accuracy'</span>])  <span class="comment">#config</span></span><br><span class="line"></span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">100</span>,epochs=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">result= model.evaluate(x_test,y_test)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\nTEST ACC:'</span>,result[<span class="number">1</span>])</span><br></pre></td></tr></tbody></table></figure><p>添加10层，发现结果还是11%的accuracy<br><img src="https://img-blog.csdnimg.cn/2020033020550831.png" alt="在这里插入图片描述"><br>首先先看你在train data的performer，如果它在train data上做得好，那么可能是过拟合，如果在train data上做得不好，怎么能让它做到举一反三呢。所以至少先让它在train data 上得到好的结果。<br><img src="https://img-blog.csdnimg.cn/20200330211229389.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200330211316773.png" alt="在这里插入图片描述"><br>由得到的结果发现train data acc 也是差的，就说明train没有train好，并不是overfiting过拟合。<br>接下来进行调参过程:<br>MSE均方误差不适合于分类问题，将loss function改为categorical_crossentropy，看看结果如何：<br><img src="https://img-blog.csdnimg.cn/20200330213935621.png" alt="在这里插入图片描述"><br>发现一换成交叉熵categorical_crossentropy，在train set上的结果就变得很好了。得到86.21%的正确率。</p><h4 id="activation-function"><a href="#activation-function" class="headerlink" title="activation function"></a>activation function</h4><p>把sigmoid都改为relu，发现在train的accuracy就爬起来了，train的acc已经将近100分了，test 上也可以得到95.45%<br><img src="https://img-blog.csdnimg.cn/20200330214539656.png" alt="在这里插入图片描述"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode|剑指offter|面试题6：从尾到头打印链表</title>
      <link href="/posts/103.html"/>
      <url>/posts/103.html</url>
      
        <content type="html"><![CDATA[<h3 id="面试题06-从尾到头打印链表"><a href="#面试题06-从尾到头打印链表" class="headerlink" title="面试题06. 从尾到头打印链表"></a>面试题06. 从尾到头打印链表</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><blockquote><p>输入：<code>head = [1,3,2]</code><br>输出：<code>[2,3,1]</code></p></blockquote><a id="more"></a><p>我们很自然地可以想到把链表中链接节点的指针反转过来，改变链表的方向，然后就可以从头到尾输出了。但是这种方法会改变原来的链表结构，如果要求不修改链表的结构可以有以下方法：</p><p>解法一：<br>遍历链表的顺序是从头到尾，但是题目要求输出的顺序却是从尾到头，第一个遍历到的节点最后一个输出，而最后一个遍历到的节点第一个输出。是典型的”后进先出”，栈这种数据结构具有该特点，我们可以在从头到尾遍历的时候，把经过的每个节点放入栈中，遍历完后，再从栈的顶端开始逐个输出节点的值。</p><h4 id="leetcode解答："><a href="#leetcode解答：" class="headerlink" title="leetcode解答："></a>leetcode解答：</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">         <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s ;</span><br><span class="line">         <span class="keyword">while</span>(head)</span><br><span class="line">         {</span><br><span class="line">             s.push(head-&gt;val);<span class="comment">//循环遍历，入栈</span></span><br><span class="line">             head=head-&gt;next;</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">while</span>(!s.empty())</span><br><span class="line">         {</span><br><span class="line">            result.push_back(s.top()); <span class="comment">//出栈</span></span><br><span class="line">            s.pop();</span><br><span class="line">         }</span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>解法二：<br>递归在本质上就是一个栈结构，可以用递归来实现。当访问到每个节点的时候，先递归输出它后面的节点，再输出该节点，最后链表的输出结果就反过来了。</p><h4 id="leetcode解答：-1"><a href="#leetcode解答：-1" class="headerlink" title="leetcode解答："></a>leetcode解答：</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;<span class="comment">//输出</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        reversePrint(head-&gt;next); <span class="comment">//递归</span></span><br><span class="line">        result.push_back(head-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>解法三：改变链表的结构<br>直接翻转指针。<br><img src="https://img-blog.csdnimg.cn/20200328221130283.png" alt="在这里插入图片描述"><br>  初始状态，pre是NULL，head指向当前的头节点A，next指向A节点的下一个节点B。首先从A节点开始逆序，将A节点的next指针指向pre，因为pre的当前值是NULL，所以A节点就从链表中脱离出来了，然后移动head和next指针，使它们分别指向B节点和B的下一个节点C（因为当前的next已经指向B节点了，因此修改A节点的next指针不会导致链表丢失）。逆向节点A之后，链表的状态如图下图所示：<br>  <img src="https://img-blog.csdnimg.cn/20200328221523995.png" alt="在这里插入图片描述"><br>  经过一轮迭代：<br>  <img src="https://img-blog.csdnimg.cn/20200328221551100.png" alt="在这里插入图片描述"><br>再经过一轮迭代：<br><img src="https://img-blog.csdnimg.cn/20200328221644843.png" alt="在这里插入图片描述"><br>可以看出再经过一轮就可以完成链表的逆序排序，循环的终止条件为head为空NULL</p><p>链表的状态图 参考:<a href="https://blog.csdn.net/lycnjupt/article/details/47103433" target="_blank" rel="noopener">单链表的逆序</a><br>leetcode解答:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode *next;</span><br><span class="line">        ListNode *pre=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        {</span><br><span class="line">            next=head-&gt;next ;<span class="comment">//保存当前节点的下一节点</span></span><br><span class="line">            head-&gt;next=pre;<span class="comment">//当前节点指向前一个节点，反向改变指针。</span></span><br><span class="line">            pre=head;<span class="comment">//更新前一个节点</span></span><br><span class="line">            head=next;<span class="comment">//更新当前节点</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(pre){<span class="comment">//上一个while循环结束后，pre指向新的链表头</span></span><br><span class="line">            result.push_back(pre-&gt;val);</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode|剑指offter|面试题4：二维数组中的查找</title>
      <link href="/posts/1666.html"/>
      <url>/posts/1666.html</url>
      
        <content type="html"><![CDATA[<h3 id="面试题04-二维数组中的查找"><a href="#面试题04-二维数组中的查找" class="headerlink" title="面试题04. 二维数组中的查找"></a>面试题04. 二维数组中的查找</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h4><p>现有矩阵 matrix 如下：</p><blockquote><p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]</p></blockquote><p>给定 target = <code>5</code>，返回 <code>true</code>。<br>给定 target = <code>20</code>，返回<code>false</code>。</p><a id="more"></a><p>解法1：暴力破法</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty())</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">          <span class="keyword">int</span> rows=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> columns=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;columns;j++)</span><br><span class="line">            {<span class="keyword">if</span>(matrix[i][j]==target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>解法2：从给定矩阵的右上角开始查找<br>首先选取数组中右上角的数字，如果该数字等于要查找的数字，则结束查找过程；如果该数字大于要查找的数字，则提出该数字所在的列；如果该数字小于要查找的数字，则提出该数字所在的行。不断剔除一行或者一列，缩小查找范围，直到找到要查找的数字。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">         <span class="keyword">if</span>(matrix.empty())</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> rows=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> columns=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> row=<span class="number">0</span>,column=columns<span class="number">-1</span>;<span class="comment">//从右上角开始判断</span></span><br><span class="line">        <span class="keyword">while</span>(row&lt;rows&amp;&amp;column&gt;=<span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][column]&gt;target)</span><br><span class="line">            column--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][column]&lt;target)</span><br><span class="line">            row++;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>解法3：还可以从给定矩阵的左下角开始查找</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty())  <span class="comment">//异常判断</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">          <span class="keyword">int</span> rows=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> columns=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> row=rows<span class="number">-1</span>,column=<span class="number">0</span>;<span class="comment">//从左下角开始判断</span></span><br><span class="line">        <span class="keyword">while</span>(row&gt;=<span class="number">0</span>&amp;&amp;column&lt;columns)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][column]&gt;target)</span><br><span class="line">            row--;<span class="comment">//要查找的数字比该数字小，则剔除该行，上移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][column]&lt;target)</span><br><span class="line">            column++;<span class="comment">////要查找的数字比该数字大，则剔除该列，右移</span></span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//相等则返回true</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode|剑指offter|面试题3：数组中重复的数字</title>
      <link href="/posts/7093.html"/>
      <url>/posts/7093.html</url>
      
        <content type="html"><![CDATA[<h2 id="面试题03-数组中重复的数字"><a href="#面试题03-数组中重复的数字" class="headerlink" title="面试题03. 数组中重复的数字"></a>面试题03. 数组中重复的数字</h2><p>本题要求找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。<br>示例1：</p><h4 id="输入：-2-3-1-0-2-5-3"><a href="#输入：-2-3-1-0-2-5-3" class="headerlink" title="输入： [2,3,1,0,2,5,3]"></a>输入： [2,3,1,0,2,5,3]</h4><h4 id="输出：-2或3"><a href="#输出：-2或3" class="headerlink" title="输出： 2或3"></a>输出： 2或3</h4><p>限制：2 &lt;= n &lt;= 100000</p><a id="more"></a><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>一个简单的方法是把输入的数组进行排序，遍历排序后的数组找到重复的数字。排序一个长度为n的数字的时间复杂度为O(nlogn),所以这种方法的时间复杂度为O(nlogn)。</p><h3 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h3><p>使用哈希表来解决这个问题。从头到尾顺序扫描数组中的每一个数，没扫描一个数字可以用O(1)的时间判断在哈希表中是否包含此数字，如果哈希表中没有此数字就将此数字加入到哈希表中，如果哈希表中已存在此数字就能找到一个重复的数字。算法的时间复杂度为O(n)，但是空间复杂度也为O(n)，以空间换区时间。</p><h3 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h3><p>数组中的数字为0到n-1的范围内。如果这个数组中没有重复的数字，则对应的i位置的数据也为i。可以重排此数组，扫描数组中的每一个数字，当扫描到下标为i的数字时，首先比较这个数字（用m表示）是不是等于i。如果是，接着扫描下一个数字。如果不是，再拿它和第m个数字比较，如果相等则找到重复的数据。否则就把第i个数字与第m个数字交换。重复这个比较、交换的过程，直到找到一个重复的数字。</p><p><strong>leetcode解答：</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;<span class="number">0</span>||nums[i]&gt;nums.size()<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span>(nums[i]!=i)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(nums[i]==nums[nums[i]])</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> a=nums[i];</span><br><span class="line">                nums[i]==nums[nums[i]];</span><br><span class="line">                nums[nums[i]]=a;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>牛客网解答：</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> {</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(numbers==<span class="literal">nullptr</span>||length&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(numbers[i]&lt;<span class="number">0</span>||numbers[i]&gt;length<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span>(numbers[i]!=i)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(numbers[i]==numbers[numbers[i]])</span><br><span class="line">                {</span><br><span class="line">                    *duplication=numbers[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;             </span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">int</span> a=numbers[i];<span class="comment">//交换</span></span><br><span class="line">                numbers[i]=numbers[a];</span><br><span class="line">                numbers[a]=a;</span><br><span class="line">            }</span><br><span class="line">                </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程练习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda3安装教程(详细)</title>
      <link href="/posts/bf8d.html"/>
      <url>/posts/bf8d.html</url>
      
        <content type="html"><![CDATA[<h2 id="Anaconda3下载"><a href="#Anaconda3下载" class="headerlink" title="Anaconda3下载"></a>Anaconda3下载</h2><p>下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a><br>选择anaconda 3.5.2 对应的python版本是python3.6</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200319185750950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt=" "></p><h2 id="安装anaconda3"><a href="#安装anaconda3" class="headerlink" title="安装anaconda3"></a>安装anaconda3</h2><p><img src="https://img-blog.csdnimg.cn/20200319185859583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt=" "><br>点击next</p><p><img src="https://img-blog.csdnimg.cn/2020031918593948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt=" "><br>点击I Agree</p><p><img src="https://img-blog.csdnimg.cn/20200319190001173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt=" "><br>然后选择Install for All Users，点击Next<br><img src="https://img-blog.csdnimg.cn/2020031919012346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt=" "><br>选择安装位置，建议不要安装在C盘。<br><img src="https://img-blog.csdnimg.cn/20200319200626716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt=" "><br>默认第一项是没有选择的，这里我把它勾上，添加anaconda到系统环境变量中，然后点击Install<br><img src="https://img-blog.csdnimg.cn/20200319200952980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt=" "><br>等待安装完成。<br><img src="https://img-blog.csdnimg.cn/20200319202441221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt=" "><br>接下来有安装VScode的选项，这里选择跳过，点击Skip<br><img src="https://img-blog.csdnimg.cn/20200319202521557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt=" "><br>安装完成，点击Finished</p><h3 id="验证anaconda是否安装成功"><a href="#验证anaconda是否安装成功" class="headerlink" title="验证anaconda是否安装成功"></a>验证anaconda是否安装成功</h3><p>打开cmd命令行，输入conda -V，如果能看到conda版本号，说明anaconda已经安装好了。<br><img src="https://img-blog.csdnimg.cn/20200319202840535.png" alt=" "></p><h2 id="用conda创建python虚拟环境"><a href="#用conda创建python虚拟环境" class="headerlink" title="用conda创建python虚拟环境"></a>用conda创建python虚拟环境</h2><p>  　　使用conda create -n your_env_name python=X.X（2.7、3.6等)命令创建python版本为X.X、名字为your_env_name的虚拟环境。your_env_name文件可以在Anaconda安装目录envs文件下找到。</p><figure class="highlight plain"><figcaption><span>create -n learn python</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">我选择建立一个名为learn的python版本为3.6的虚拟环境</span><br><span class="line"></span><br><span class="line">### activate激活虚拟环境</span><br><span class="line">![ ](https://img-blog.csdnimg.cn/20200320102010525.png)</span><br><span class="line">在这里输入activate tensorflow</span><br><span class="line">显示激活成功。</span><br><span class="line">输入deactivate回到默认环境中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">如果想要删除创建的虚拟环境：</span><br><span class="line">使用conda remove -n your_env_name(虚拟环境名称) --all命令</span><br><span class="line">在虚拟环境中安装额外的包：</span><br><span class="line">使用命令conda install -n your_env_name [package]即可安装package到your_env_name中</span><br><span class="line">用pip安装tensorflow换成国内源快速安装：</span><br><span class="line">```pip install --index-url https://pypi.douban.com/simple tensorflow</span><br></pre></td></tr></tbody></table></figure><h3 id="安装tensorflow和keras"><a href="#安装tensorflow和keras" class="headerlink" title="安装tensorflow和keras"></a>安装tensorflow和keras</h3><p>使用命令<code>conda install -n your_env_name tensorflow</code>安装，如果想要指定tensorflow的版本号，直接tensorflow==X.X.X</p><p><strong>想要在jupyter notebook中import tensorflow</strong><br>需要执行以下命令：</p><figure class="highlight plain"><figcaption><span>install ipython```</span></figcaption><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">```conda install jupyter</span><br></pre></td></tr></tbody></table></figure><p>最后输入<code>conda install keras</code>安装keras<br><img src="https://img-blog.csdnimg.cn/20200320102608665.png" alt=" "><br>检查以下tensorflow和keras是否安装成功<br><img src="https://img-blog.csdnimg.cn/20200320102827481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt=" "><br><img src="https://img-blog.csdnimg.cn/20200320102847141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt=" "><br>cmd命令行输入jupyter notebook，import tensorflow看是否报错<br><img src="https://img-blog.csdnimg.cn/2020032010311961.png" alt=" "><br>没有输出任何信息，证明已经安装好了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> anaconda python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Anaconda在开始菜单找不到navigator和prompt的问题</title>
      <link href="/posts/7f55.html"/>
      <url>/posts/7f55.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>找到Anaconda的安装目录<br><img src="https://img-blog.csdnimg.cn/20200319150507509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><!--more--><p>使用cmd命令打开终端<br>然后输入</p><figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python .\<span class="module-access"><span class="module"><span class="identifier">Lib_nsis</span>.</span></span>py mkmenus</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/20200319150549275.png" alt="在这里插入图片描述"><br><strong>完美解决问题。</strong><br><img src="https://img-blog.csdnimg.cn/20200319150821586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200319150842391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习-李宏毅| 回归演示 | python</title>
      <link href="/posts/c315.html"/>
      <url>/posts/c315.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="回归的定义"><a href="#回归的定义" class="headerlink" title="回归的定义"></a>回归的定义</h2><p>Regression就是指找到一个函数$function$，通过输入特征x，输出一个数值$Scalar$</p><p>看了李宏毅老师的机器学习课程视频，其中的Regression demo部分，关于预测宝可梦的CP值的应用代码，在jupyter notebook中实现。<br>现在假设有10个x_data和y_data，x和y之间的关系是y_data=b+w*x_data。b，w都是参数，是需要学习出来的。现在我们来练习用梯度下降找到b和w。</p><!--more--><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'Simhei'</span>]  <span class="comment"># 显示中文</span></span><br><span class="line">mpl.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span>  <span class="comment"># 解决保存图像是负号'-'显示为方块的问题</span></span><br><span class="line"></span><br><span class="line">x_data= [ <span class="number">338.</span>,  <span class="number">333.</span>, <span class="number">328.</span>, <span class="number">207.</span>, <span class="number">226.</span>, <span class="number">25.</span>, <span class="number">179.</span>, <span class="number">60.</span>, <span class="number">208.</span>, <span class="number">606.</span>]</span><br><span class="line">y_data= [ <span class="number">640.</span>,  <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>] </span><br><span class="line"><span class="comment"># ydata =b + w * xdata</span></span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">-200</span>, <span class="number">-100</span>, <span class="number">1</span>) <span class="comment">#bias</span></span><br><span class="line">y = np.arange(<span class="number">-5</span>,<span class="number">5</span>,<span class="number">0.1</span>) <span class="comment">#weight</span></span><br><span class="line">Z = np.zeros((len(x), len(y)))</span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(y)):</span><br><span class="line">        b = x[i]</span><br><span class="line">        w = y[j]</span><br><span class="line">        Z[j][i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(len(x_data)):</span><br><span class="line">            Z[j][i] = Z[j][i]  + (y_data[n] - b - w*x_data[n]) **<span class="number">2</span></span><br><span class="line">        Z[j][i] =   Z[j][i] /len(x_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ydata = b + w * xdata</span></span><br><span class="line">b = <span class="number">-120</span> <span class="comment"># initial b</span></span><br><span class="line">w = <span class="number">-4</span> <span class="comment">#intial w</span></span><br><span class="line">lr =<span class="number">0.0000001</span> </span><br><span class="line">iteration = <span class="number">100000</span> </span><br><span class="line"><span class="comment"># Store initial values for plotting.</span></span><br><span class="line">b_history = [b]</span><br><span class="line">w_history = [w]</span><br><span class="line"></span><br><span class="line"><span class="comment">#lr_b = 0 #客制化b的learning rate 的初始值</span></span><br><span class="line"><span class="comment">#lr_w = 0 #客制化w的learning rate 的初始值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterations</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">    </span><br><span class="line">    b_grad = <span class="number">0.0</span></span><br><span class="line">    w_grad = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(len(x_data)):</span><br><span class="line">        b_grad = b_grad - <span class="number">2.0</span>*(y_data[n] - b - w*x_data[n]) *<span class="number">1.0</span></span><br><span class="line">        w_grad = w_grad - <span class="number">2.0</span>*(y_data[n] - b - w*x_data[n])*x_data[n]</span><br><span class="line">        </span><br><span class="line">   <span class="comment"># lr_b = lr_b + b_grad ** 2 #客制化b的learning rate</span></span><br><span class="line">   <span class="comment"># lr_w = lr_w + w_grad ** 2 #客制化w的learning rate</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Update parameters.</span></span><br><span class="line">    b = b - lr * b_grad</span><br><span class="line">    w = w - lr * w_grad</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Store parameters for plotting</span></span><br><span class="line">    b_history.append(b)</span><br><span class="line">    w_history.append(w)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the figure</span></span><br><span class="line">plt.contourf(x, y, Z, <span class="number">50</span>, alpha = <span class="number">0.5</span>, cmap=plt.get_cmap(<span class="string">'jet'</span>))</span><br><span class="line">plt.plot([<span class="number">-188.4</span>], [<span class="number">2.67</span>], <span class="string">'x'</span>, ms = <span class="number">12</span>, markeredgewidth = <span class="number">3</span>, color=<span class="string">'orange'</span>)</span><br><span class="line">plt.plot(b_history, w_history, <span class="string">'o-'</span>, ms=<span class="number">3</span>, lw=<span class="number">1.5</span>, color=<span class="string">'black'</span>)</span><br><span class="line">plt.xlim(<span class="number">-200</span>, <span class="number">-100</span>)</span><br><span class="line">plt.ylim(<span class="number">-5</span>,<span class="number">5</span>)</span><br><span class="line">plt.xlabel(<span class="string">r'$b$'</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.ylabel(<span class="string">r'$w$'</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.title(<span class="string">"线性回归"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>输出结果图：<br><img src="https://img-blog.csdnimg.cn/20200312150150723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="  "><br>横坐标是b，纵坐标是w，标记×位最优解，显然，在图中我们并没有运行得到最优解，最优解十分的遥远。那么我们就调大learning rate，lr = 0.000001（调大10倍），得到结果如下图。<br><img src="https://img-blog.csdnimg.cn/20200312150917344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="  "><br>我们再调大learning rate，lr = 0.00001（调大10倍），得到结果如下图。<br><img src="https://img-blog.csdnimg.cn/20200312153648587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="  "><br>结果发现learning rate太大了，结果很不好。<br>所以我们给b和w特制化两种learning rate<br>修改后代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.rcParams[<span class="string">'font.sans-serif'</span>] = [<span class="string">'Simhei'</span>]  <span class="comment"># 显示中文</span></span><br><span class="line">mpl.rcParams[<span class="string">'axes.unicode_minus'</span>] = <span class="literal">False</span>  <span class="comment"># 解决保存图像是负号'-'显示为方块的问题</span></span><br><span class="line"></span><br><span class="line">x_data= [ <span class="number">338.</span>,  <span class="number">333.</span>, <span class="number">328.</span>, <span class="number">207.</span>, <span class="number">226.</span>, <span class="number">25.</span>, <span class="number">179.</span>, <span class="number">60.</span>, <span class="number">208.</span>, <span class="number">606.</span>]</span><br><span class="line">y_data= [ <span class="number">640.</span>,  <span class="number">633.</span>, <span class="number">619.</span>, <span class="number">393.</span>, <span class="number">428.</span>, <span class="number">27.</span>, <span class="number">193.</span>, <span class="number">66.</span>, <span class="number">226.</span>, <span class="number">1591.</span>] </span><br><span class="line"><span class="comment"># ydata =b + w * xdata</span></span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">-200</span>, <span class="number">-100</span>, <span class="number">1</span>) <span class="comment">#bias</span></span><br><span class="line">y = np.arange(<span class="number">-5</span>,<span class="number">5</span>,<span class="number">0.1</span>) <span class="comment">#weight</span></span><br><span class="line">Z = np.zeros((len(x), len(y)))</span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(y)):</span><br><span class="line">        b = x[i]</span><br><span class="line">        w = y[j]</span><br><span class="line">        Z[j][i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(len(x_data)):</span><br><span class="line">            Z[j][i] = Z[j][i]  + (y_data[n] - b - w*x_data[n]) **<span class="number">2</span></span><br><span class="line">        Z[j][i] =   Z[j][i] /len(x_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ydata = b + w * xdata</span></span><br><span class="line">b = <span class="number">-120</span> <span class="comment"># initial b</span></span><br><span class="line">w = <span class="number">-4</span> <span class="comment">#intial w</span></span><br><span class="line">lr =<span class="number">1</span> <span class="comment">#learning rate设为1</span></span><br><span class="line">iteration = <span class="number">100000</span> </span><br><span class="line"><span class="comment"># Store initial values for plotting.</span></span><br><span class="line">b_history = [b]</span><br><span class="line">w_history = [w]</span><br><span class="line"></span><br><span class="line">lr_b = <span class="number">0</span> <span class="comment">#客制化b的learning rate 的初始值</span></span><br><span class="line">lr_w = <span class="number">0</span> <span class="comment">#客制化w的learning rate 的初始值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterations</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(iteration):</span><br><span class="line">    </span><br><span class="line">    b_grad = <span class="number">0.0</span></span><br><span class="line">    w_grad = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(len(x_data)):</span><br><span class="line">        b_grad = b_grad - <span class="number">2.0</span>*(y_data[n] - b - w*x_data[n]) *<span class="number">1.0</span></span><br><span class="line">        w_grad = w_grad - <span class="number">2.0</span>*(y_data[n] - b - w*x_data[n])*x_data[n]</span><br><span class="line">        </span><br><span class="line">    lr_b = lr_b + b_grad ** <span class="number">2</span> <span class="comment">#客制化b的learning rate</span></span><br><span class="line">    lr_w = lr_w + w_grad ** <span class="number">2</span> <span class="comment">#客制化w的learning rate</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Update parameters.</span></span><br><span class="line">    b = b - lr/np.sqrt(lr_b ) * b_grad</span><br><span class="line">    w = w - lr/np.sqrt(lr_w ) * w_grad</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Store parameters for plotting</span></span><br><span class="line">    b_history.append(b)</span><br><span class="line">    w_history.append(w)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot the figure</span></span><br><span class="line">plt.contourf(x, y, Z, <span class="number">50</span>, alpha = <span class="number">0.5</span>, cmap=plt.get_cmap(<span class="string">'jet'</span>))</span><br><span class="line">plt.plot([<span class="number">-188.4</span>], [<span class="number">2.67</span>], <span class="string">'x'</span>, ms = <span class="number">12</span>, markeredgewidth = <span class="number">3</span>, color=<span class="string">'orange'</span>)</span><br><span class="line">plt.plot(b_history, w_history, <span class="string">'o-'</span>, ms=<span class="number">3</span>, lw=<span class="number">1.5</span>, color=<span class="string">'black'</span>)</span><br><span class="line">plt.xlim(<span class="number">-200</span>, <span class="number">-100</span>)</span><br><span class="line">plt.ylim(<span class="number">-5</span>,<span class="number">5</span>)</span><br><span class="line">plt.xlabel(<span class="string">r'$b$'</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.ylabel(<span class="string">r'$w$'</span>, fontsize=<span class="number">16</span>)</span><br><span class="line">plt.title(<span class="string">"线性回归"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>这样有了新的特制化两种learning rate就可以在10w次迭代之内到达最优点了。<br><img src="https://img-blog.csdnimg.cn/20200312154047356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="  "></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> logistic regression python 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32mp1开发板入门pangu</title>
      <link href="/posts/29d1.html"/>
      <url>/posts/29d1.html</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="pangu开发板介绍"><a href="#pangu开发板介绍" class="headerlink" title="pangu开发板介绍"></a>pangu开发板介绍</h2><p><strong>pangu开发板</strong>主芯片基于ST公司STM32MP1系列微处理器（ARM dual Cortex-A7 650Mhz + Cortex-M4）<br> <img src="https://img-blog.csdnimg.cn/20200222114447932.png" alt="  "><br> <img src="https://img-blog.csdnimg.cn/20200222114459216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="  "></p><!--more--><h2 id="开发软件安装，STM32CubeMX"><a href="#开发软件安装，STM32CubeMX" class="headerlink" title="开发软件安装，STM32CubeMX"></a>开发软件安装，STM32CubeMX</h2><p>STM32CubeMX 是 ST 意法半导体近几年来大力推荐的 STM32 芯片图形化配置工具， 允许用户使用图形化向导生成 C 初始化代码，可以大大减轻开发工作，时间和费用。stm32mp1中使用协处理器M4需要安装stm32cubemx：<br>stm32cubemx运行环境搭建，包含两个部分，首先是安装java运行环境（版本必须为v1.7以上），然后是安装stm32cubemx开发软件。<br>简单使用：<br>新建工程第一步，选择mcu型号<br> <img src="https://img-blog.csdnimg.cn/20200222114600172.png#pic_center" alt="  "><br>由于pangu开发板选用的是stm32mp157AAA3芯片，故选择stm32mp157AAAX<br> <img src="https://img-blog.csdnimg.cn/20200222114620944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="  "></p><p>接下来配置时钟源，如果选择使用外部高速时钟（HSE），则需要在System Core中配置RCC；</p><p>如果使用默认内部时钟（HSI），这一步可以略过；这里使用外部时钟，HSE，LSE<br>pangu开发板上的外部时钟<br><img src="https://img-blog.csdnimg.cn/20200222114636918.png" alt="  "><br>下拉框中选择crystal/Ceramic Resonator晶体/陶瓷晶振<br><img src="https://img-blog.csdnimg.cn/20200222114645123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="  "><br>设置开发板上D17灯对应的PH6引脚为输出<br> <img src="https://img-blog.csdnimg.cn/20200222114656882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="  "><br>生成工程设置<br> <img src="https://img-blog.csdnimg.cn/20200222114702610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="  "><br>然后点击Generate code就可生成MDK工程代码。<br>时钟树配置，配置主要是外部晶振大小，分频系数，倍频系统以及选择器。<br> <img src="https://img-blog.csdnimg.cn/20200222114710174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="  "><br><img src="https://img-blog.csdnimg.cn/20200222114716478.png#pic_center" alt="  "></p><p>最后用MDK打开生成的MDK-ARM工程文件，build编译。0error。<br><img src="https://img-blog.csdnimg.cn/20200222114746322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70#pic_center" alt="  "><br>之前使用的STM32F407开发板用的是标准外设库（STD库），  HAL库是硬件抽象层，更加标准化了。所有的函数名和函数体进行了重新定义，重新编写。更加通用。方便移植。近两年新出的STM32芯片，ST只提供HAL库，可用STM32Cube程序生成开发工具+HAL库<br>stm32cube目前几乎支持STM32全系列，我们需要到ST官网下载对应的STM32Cube包<br><img src="https://img-blog.csdnimg.cn/2020022211481192.png" alt="  "><br>包中大致有（1）Drivers文件夹，Drivers 文件夹包含BSP， CMSIS 和 STM32MP1xx_HAL_Driver 三个子文件夹。BSP是板级支持包，提供直接与硬件打交道的API。<br>CMSIS 文件夹是符合 CMSIS 标准的软件抽象层组件相关文件。主要包括 DSP库(DSP_LIB 文件夹)， Cortex-M 内核及其设备文件（Include 文件夹）， 微控制器专用头文件/启动代码/专用系统文件等(Device 文件夹)。<br>STM32MP1xx_HAL_Driver文件夹中包含所有的 STM32MP1xx系列 HAL 库头文件和源文件，也就是所有底层硬件抽象层 API 声明和定义。 它的作用是屏蔽了复杂的硬件寄存器操作，统一了外设的接口函数。 该文件夹包含 Src 和 Inc 两个子文件夹，其中 Src 子文件夹存放的是.c 源文件， Inc 子文件夹存放的是与之对应的.h 头文件。每个.c 源文件对应一个.h 头文件。<br>Middlewares文件夹下有Third_Party文件夹（是第三方中间件）里面有FreeRTOS实时系统支持包和OpenAMP（？）<br>Projects文件夹存放的是一些可以直接编译的实例工程，每个文件夹对应一个ST官方的Demo板，暂时只有SW4STM32的工程，没有MDK的。</p><p>  一般来说，stm32mp1处理器可以在M4上做电机控制，A7上做人机交互界面。</p><h2 id="应用开发环境搭建"><a href="#应用开发环境搭建" class="headerlink" title="应用开发环境搭建"></a>应用开发环境搭建</h2><p><em>linux开发需要在ubuntu下进行，主要是交叉编译器的安装。</em></p><blockquote><p>linux进行C语言开发用的是GCC编译器进行代码编译，但ubuntu自带的GCC编译器是针对X86架构的。我们现在要编译的是ARM架构的代码，需要一个在X86架构的PC机上运行，可以编译ARM架构代码的GCC编译器，这个编译器就叫做交叉编译器。（就是在一个架构上编译另外一个架构的代码）</p></blockquote><p>pangu开发板的开发环境基于Ubuntu16.04 64bit，在虚拟机上安装ubuntu16.04操作系统</p><ul><li>PanGu开发板的应用开发，需要先安装应用开发工具包(SDK)。PanGu开发板提供了两种SDK工具包：i2som-image-qt-openstlinux-eglfs-pangu-x86_64-toolchain-2.6-snapshot.sh和i2som-image-weston-openstlinux-weston-pangu-x86_64-toolchain-2.6-snapshot.sh。</li></ul><p>由于板载的flash预装的是weston系统，在此我选择在ubuntu系统中安装weston系统镜像的应用开发工具链。<br>下面开始安装i2som-image-weston-openstlinux-weston-pangu-x86_64-toolchain-2.6-snapshot.sh工具包</p><ul><li><p>首先运行chmod a+x命令，给所有人加上可执行权限，用ls –lh命令查询文件的大小、权限等详细信息，权限都为rwx（读取、写入、执行）<br><img src="https://img-blog.csdnimg.cn/20200222115039272.png" alt="  "></p></li><li><p>接着在路径下运行安装命令：./i2som-image-weston-openstlinux-weston-pangu-x86_64-toolchain-2.6-snapshot.sh<br><img src="https://img-blog.csdnimg.cn/20200222115050732.png" alt="  "></p></li><li><p>安装路径输入 /opt/st/pangu-i2som-image-weston/2.6-snapshot<br><img src="https://img-blog.csdnimg.cn/20200222115058493.png" alt="  "></p></li><li><p>接着会让你输入管理员密码，之后就等待安装了。<br>当出现SDK has been successfully时证明安装完成了。</p></li><li><p>然后运行如下命令：<br>==. /opt/st/pangu-i2som-image-weston/2.6-snapshot/environment-setup-cortexa7t2hf-neon-vfpv4-openstlinux_weston-linux-gnueabi==<br><img src="https://img-blog.csdnimg.cn/20200222115117851.png" alt="  "></p></li><li><p>通过$CC –version验证开发工具是否正确安装，如图显示了版本信息表示工具链安装完成。</p></li></ul><p>编写测试文件test.c内容如下<br> <img src="https://img-blog.csdnimg.cn/20200222115130646.png" alt="  "><br>编译test应用<br> <img src="https://img-blog.csdnimg.cn/2020022211513545.png" alt="  "><br>然后将输出的 复制到pangu开发板后直接运行</p><p>通过MobaXtern配置ssh登录pangu开发板，可通过sftp服务进行文件的复制拷贝。<br><img src="https://img-blog.csdnimg.cn/2020022211514457.png#pic_center" alt="  "> 上图是pangu开发板的home目录<br>现在将编译输出的test从虚拟机的ubuntu系统复制到home目录下<br><img src="https://img-blog.csdnimg.cn/20200222115156304.png" alt="  "><br> 可以看到此时多了个test文件。<br> <img src="https://img-blog.csdnimg.cn/20200222115206362.png" alt="  "><br>直接运行发现permission denied<br>通过chmod a+x命令修改下权限，紧接着再输入./test<br>输出是hello，I am wangrongyao!</p><blockquote><p>pangu开发板的Micro usb接口可以作为从设备，默认是作为usb以太网设备，可以实现将开发板的usb otg接口作为从设备模式，模拟成为一个网口，通过PC的usb接口连接到开发板。使用Micro USB线连接开发板J5和PC USB Host接口。PanGu开发板上usb0为网络设备，默认IP地址为192.168.7.2<br><img src="https://img-blog.csdnimg.cn/20200222115720532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70" alt="  "></p></blockquote><p>PC通过usb连接开发板后，PC上会出现一个usb虚拟的网络设备，自行手动配置ip地址为192.168.7.10，之后就可以通过ssh登录pangu开发板了。<br><img src="https://img-blog.csdnimg.cn/20200222115727727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM2NDE1MzYy,size_16,color_FFFFFF,t_70#pic_center" alt="  "></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP Congestion性能测试分析</title>
      <link href="/posts/ab61.html"/>
      <url>/posts/ab61.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-实验简介"><a href="#1-实验简介" class="headerlink" title="1.实验简介"></a>1.实验简介</h2><p>  最近在学习《现代计算机网络》，课程布置了一个对tcp拥塞控制性能进行测试的实验，本篇博客就本次实验做一个完整的实验报告及总结。</p><a id="more"></a><h2 id="一-实验环境（详细说明实验运行的操作系统，网络平台，机器的配置）"><a href="#一-实验环境（详细说明实验运行的操作系统，网络平台，机器的配置）" class="headerlink" title="一.实验环境（详细说明实验运行的操作系统，网络平台，机器的配置）"></a>一.实验环境（详细说明实验运行的操作系统，网络平台，机器的配置）</h2><ul><li>操作系统：Windows10</li><li>虚拟机操作系统：SEEDUbuntu 12.04</li><li>虚拟机工具：VirtualBox 5.2.16</li><li>网络虚拟软件：GNS3 2.0.3</li><li>网络性能测试工具：iperf</li></ul><h2 id="二-实验目的"><a href="#二-实验目的" class="headerlink" title="二.实验目的"></a>二.实验目的</h2><ol><li>掌握基础ip网络配置；</li><li>选择 TCP 的三种支持的三种拥塞控制算法 cubic、reno、westwood，通过改变 Seed-Router 的延迟和丢包，来测试三种 TCP 拥塞控制算法在不同情况下（延迟、丢包）的性能。</li><li>深入理解不同TCP拥塞控制算法思路及原理。</li></ol><h2 id="三-实验步骤"><a href="#三-实验步骤" class="headerlink" title="三.实验步骤"></a>三.实验步骤</h2><p>　　本次实验中主要实现SeedUbuntu内核中Cubic、Reno、Westwood三种TCP拥塞控制算法的性能测试分析与比较。实验中采用三台虚拟机SEED-Client、SEED-Router、SEED-Server构建处于两个不同子网网段的可相互通信网络拓扑结构，其中保证SEED-Client和SEED-Serve采用同一TCP拥塞控制算法，通过设置SEED-Router的转发参数（丢包率、延迟、重复包率、损坏包率）模拟不同的网络状态。</p><p>1.导入SEED虚拟机镜像文件，命名为SEED-Client，再复制两个，命名为SEED-Router、SEED-Server（注意勾选重新初始化网卡的MAC地址）。</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200213193756.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200213195510.png" alt=""></p><p>2.在GNS3中新建一个项目，将三台虚拟机按如图方式连接起来</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200213195551.png" alt=""></p><p>3.然后在GNS3中给每台虚拟机配置三个网卡，eth0、eth1、eth2，其中eth0不要作为连接使用，而是将其配置为网络地址转换NAT，用于虚拟机访问外部网络。</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200213195600.png" alt=""></p><p>4.按照下表配置三台主机的ip地址和路由</p><table><thead><tr><th></th><th>SEED-Client</th><th>SEED-Router</th><th>SEED-Server</th></tr></thead><tbody><tr><td>eth0</td><td>/</td><td>/</td><td>/</td></tr><tr><td>eth1</td><td>192.168.1.2/24</td><td>192.168.1.1/24</td><td>192.168.2.2/24</td></tr><tr><td>eth2</td><td>/</td><td>192.168.2.1/24</td><td>/</td></tr></tbody></table><p>5.在SEED-Client端增加默认路由</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200213195608.png" alt=""></p><p>用ip route命令查看</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200213195634.png" alt=""></p><p>Ping <a href="http://www.baidu.com测试能否通过eth0联网" target="_blank" rel="noopener">www.baidu.com测试能否通过eth0联网</a></p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200213195701.png" alt=""></p><p>6.在SEED-Router端启动路由转发功能</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200213195713.png" alt=""></p><p>7.在SEED-Server增加默认路由</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200213195742.png" alt=""></p><p>用ip route命令查看</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214142955.png" alt=""></p><p>测试能否联网，访问外部网络。</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214143027.png" alt=""></p><p>　　经过上述一系列操作步骤，实现SEED-Client与SEED-Server之间能够相互ping通，并且保证三台虚拟机可以通过eth0网卡访问外部网络。</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214143110.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214143120.png" alt=""></p><p>8.然后分别在SEED-Client和SEED-Server上通过sudo apt-get install iperf命令安装iperf软件</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214143223.png" alt=""></p><p>现在实验所需的环境配置完成。</p><h2 id="linux下的拥塞控制算法"><a href="#linux下的拥塞控制算法" class="headerlink" title="linux下的拥塞控制算法"></a>linux下的拥塞控制算法</h2><p>(1)观察Linux内核内已经编译的TCP拥塞控制算法:使用命令行sysctl net.ipv4.tcp_available_congestion_control,可以看到已经直接编译到内核的拥塞控制算法Cubic及Reno</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214143339.png" alt=""></p><p>修改当前的拥塞控制算法</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214143442.png" alt=""></p><p>使用命令ls  /lib/modules/3.5.0-37-generic/kernel/net/ipv4/ 查看Linux支持的拥塞控制算法：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214143604.png" alt=""></p><p>从SEED-Client虚拟机发包测试</p><p>下面以SEED-Client和SEED-Server都设置拥塞算法为cubic</p><p>先在SEED-Server端运行iperf -c命令，让iperf的服务器端运行守护在5001端口：</p><p>​    在SEED-Client端运行下表的命令，让iperf的客户端运行，同时利用Linux内核的tcp probe模块监控特定连接中参数变化：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>modprobe tcp_probe   port=5001</td><td>对端口为5001（源或目的）的tcp连接进行监控</td></tr><tr><td>cat /proc/net/tcpprobe &gt; data.txt   &amp;</td><td>tcpprobe捕捉的信息是持续性的，可以放到后台读</td></tr><tr><td>pid=$!</td><td>保存上一个读命令的pid，用于结束读tcpprobe接口</td></tr><tr><td>iperf -c otherhost –t time</td><td>使用iperf建立一个tcp流</td></tr><tr><td>kill $pid</td><td>杀死进程</td></tr></tbody></table><p>　　修改不同的拥塞控制算法，重复执行上述命令，得到XXX.txt文件保存了TCP的拥塞窗口的变化情况，作为实验数据，方便后续的分析。</p><p>　　下面依次得到cubic、reno和westwood算法在正常情况、不同延迟时间、不同丢包率情况下的测试结果。</p><h3 id="1-CUBIC算法"><a href="#1-CUBIC算法" class="headerlink" title="1.CUBIC算法"></a>1.CUBIC算法</h3><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214143920.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214143932.png" alt=""></p><p>设置cubic算法的loss为2.5%</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214143943.png" alt=""></p><p>设置cubic算法的loss为0.5%</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214143957.png" alt=""></p><p>设置cubic算法的延迟为30ms加减10ms</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214144047.png" alt=""></p><p>设置延迟为100ms加减30ms</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214144057.png" alt=""></p><p>设置延迟为10ms加减3ms</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214144105.png" alt=""></p><h3 id="2-Reno算法"><a href="#2-Reno算法" class="headerlink" title="2.Reno算法"></a>2.Reno算法</h3><p>正常情况：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214150418.png" alt=""></p><p>设置reno算法的loss为2.5%</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214150439.png" alt=""></p><p>设置reno算法的loss为0.5%</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214150448.png" alt=""></p><p>设置reno算法的延迟为30ms加减10ms</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214150458.png" alt=""></p><p>设置reno延迟为100ms加减30ms</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214150529.png" alt=""></p><p>设置reno延迟为10ms加减3ms</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214150544.png" alt=""></p><h3 id="3-Westwood算法"><a href="#3-Westwood算法" class="headerlink" title="3.Westwood算法"></a>3.Westwood算法</h3><p>Client:</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214152822.png" alt=""></p><p>Server:</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214152840.png" alt=""></p><p>正常情况：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214152902.png" alt=""></p><p>设置westwood算法的loss为2.5%</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214152917.png" alt=""></p><p>设置westwood算法的loss为0.5%</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214152930.png" alt=""></p><p>设置westwood算法的延迟为30ms加减10ms</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214152941.png" alt=""></p><p>设置westwood延迟为100ms加减30ms</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214152953.png" alt=""></p><p>设置westwood延迟为10ms加减3ms</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214153008.png" alt=""></p><p>Server：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214153019.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214153032.png" alt=""></p><p>在实验过程中遇到加了delay情况下，生成的.txt文件没有数据，注意此时需要先用modprobe -r命令将tcp_probe模块移除，再重新加载，加载使用额外的参数full=1。</p><p>tcpprobe模块的卸载与加载，modprobe –r tcp_probe </p><p># modprobe tcp_probe full=1 port=5001   // full选项表示每次收到数据包都捕捉信息</p><p>==模拟丢包==</p><p>在 SEED_Route 这台虚拟机连接 SEED_Server 网卡上增加丢包和延迟来改变网络环境。在 SEED_Route 终端中键入命令:</p><p>tc qdisc add dev eth2 root netem loss 2.5%</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214154535.png" alt=""></p><p>模拟丢包</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214154615.png" alt=""></p><p>将add改为del删除相关配置。</p><p>增加延迟：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214154630.png" alt=""></p><p>cwnd拥塞窗口</p><p>重复上述步骤，获得新的数据，命名为data_cubic_delay.txt</p><p>改变拥塞控制算法：</p><p>Client：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214154854.png" alt=""></p><p>Server：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214154906.png" alt=""></p><p>设置丢包和延迟</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214154913.png" alt=""></p><p>运行新的拥塞控制算法：linux支持的拥塞控制算法westwood.ko</p><p>首先加载这些内核模块：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214154930.png" alt=""></p><p>然后在每种拥塞控制算法下重复第获取数据命令，得到三种算法下正常、丢包、延迟共9种情况下的数据进行分析。</p><p>查看已经配置的网络条件：#tc qdisc show dev eth2</p><h3 id="将实验数据文件通过虚拟机共享目录导出"><a href="#将实验数据文件通过虚拟机共享目录导出" class="headerlink" title="将实验数据文件通过虚拟机共享目录导出"></a><strong>将实验数据文件通过虚拟机共享目录导出</strong></h3><p>1、挂载这个目录到linux本地目录</p><p>首先在虚拟机中创建共享文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214155658.png" alt=""></p><p>改为可读可写</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214155710.png" alt=""></p><p>运行命令加载</p><p>sudo mount -t vboxsf -o uid=1000,gid=1000 share /home/share</p><p>share为VirtualBox共享目录的名字</p><p>/home/share为刚刚创建的目标目录。</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214155723.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214155733.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214155744.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214155808.png" alt=""></p><p>这样就把数据从虚拟机复制到物理机上来了。便于后续的数据分析。</p><h2 id="四-实验结果和分析"><a href="#四-实验结果和分析" class="headerlink" title="四.实验结果和分析"></a>四.实验结果和分析</h2><p>当对资源的需求超过了资源的可用部分，网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降，这便是拥塞。TCP作为一个成熟可靠的通信协议，拥有许多具有较优性能的拥塞控制协议，可做到从全局角度，了解网络能够承受的现有网络负载，防止过多的数据注入网络中，保证网络中的路由器或链路不会过载。</p><p>本次实验主要以Linux内核中TCP拥塞控制算法模块Cubic、Reno、Westwood为例通过测试比较采用不同TCP拥塞控制算法在不同网络状态下的网络的吞吐量等性能，并深入分析Cubic、Reno、Westwood三种TCP拥塞控制算法的基本原理，进一步分析现有TCP拥塞控制算法的优缺点和较佳适用的网络环境。</p><p>实验中测试了Linux内核中的TCP拥塞控制算法中基于丢包反馈协议的Cubic、Reno和基于路径延迟反馈协议的Westwood算法，其中Cubic是针对Reno等传统TCP拥塞控制算法进行改进以适应现今高带宽、传输延时大的网络链路，提高TCP带宽利用率。</p><p>TCP作为面向连接全双工可靠服务协议，实现拥塞控制算法主要包括四个阶段有：慢开始、拥塞避免、快速重传以及快速恢复。</p><p>（1）慢开始：在新加入网络时，主机发送数据不是立即将大量数据字节注入网络，而是由小到大逐渐增大发送窗口。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值，在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值，这样，每经过一个传输轮次RTT，拥塞窗口 cwnd 就加倍，即拥塞控制窗口呈指数增长。为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。 当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。 当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p><p>（2）拥塞避免：当发送窗口达到慢开始阈值ssthresh时，为避免拥塞窗口增长过快导致网络拥塞，现采用拥塞控制算法，使发送窗口线性缓慢增加，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214163055.png" alt=""></p><p>　　　　　　　　　图4.1 采用慢开始及拥塞避免策略</p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认ACK），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2），然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p><p>慢开始和拥塞控制算法常常作为一个整体使用，而快速重传和快速恢复则是为了减少因为拥塞导致的数据包丢失带来的重传时间，从而避免传递没有用的数据包到网络。</p><p>(3)快速重传：快重传机制要求接收方每收到一个失序的TCP报文段后就立即发出重复确认(为了使发送方及早知道没有到达对方)而不要等待自己发送数据时才进行确认，发送方只要连续收到3个重复确认就应当立即重传未被确认的报文段。</p><p>(4)快速恢复：当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法，而是认定网络现在可能没有出现拥塞，不执行慢开始算法，而是执行拥塞避免算法。</p><p>根据得到的数据进行绘图：</p><p><strong>采用Cubic算法实验结果图：</strong></p><p>正常情况下：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214163241.png" alt=""></p><p>丢包率为2.5%的情况： </p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214163250.png" alt=""></p><p>丢包率为0.5%:</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214164119.png" alt=""></p><p>设置延迟为30ms±10ms：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214164129.png" alt=""></p><p>设置延迟为100ms±30ms：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214164141.png" alt=""></p><p>设置延迟为10ms±3ms：  </p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214164219.png" alt=""></p><p><strong>采用Reno算法实验结果图：</strong></p><p>正常情况下：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214164431.png" alt=""></p><p>丢包率为2.5%的情况：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214164445.png" alt=""></p><p>丢包率为0.5%:</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214165104.png" alt=""></p><p>设置延迟为30ms±10ms：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214165116.png" alt=""></p><p>设置延迟为100ms±30ms：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214165129.png" alt=""></p><p>设置延迟为10ms±3ms：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214165137.png" alt=""></p><p><strong>采用Westwood算法实验结果图：</strong></p><p>正常情况下：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214165419.png" alt=""></p><p>丢包率为2.5%的情况：   </p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214165443.png" alt=""></p><p>丢包率为0.5%:</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214165451.png" alt=""></p><p>设置延迟为30ms±10ms：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214165459.png" alt=""></p><p>设置延迟为100ms±30ms：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214165517.png" alt=""></p><p>设置延迟为10ms±3ms：  </p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214165524.png" alt=""></p><p>对上述绘制的图像作如下分析：</p><p>　　通过对比正常情况下的Cubic和Reno图，可以发现cubic在稳定状态下的拥塞窗口cwnd的总体增长趋势更平缓。在发送端检测到链路中出现丢包时，cubic和reno都会立刻减小cwnd以缓解拥塞现象，之后cwnd开始进入恢复阶段。通过对比可以明显观察到cubic相比于reno，拥塞窗口增长的更为平缓，而reno的拥塞窗口呈现指数趋势增长。在丢包率为0.5%时，reno算法的吞吐量和cubic算法相比有着一定的优势，而当丢包率为2.5%时，cubic比reno此时有更高的带宽利用率。</p><p>　　通过对比正常情况下的reno和westwood图，可以看出慢启动阶段westwood的拥塞窗口增加的较为迅速，而在拥塞避免阶段其增长趋势有所放缓。在高丢包率链路中由于频繁的丢包reno需要降低自己的发送端cwnd，不断将当前的cwnd置为一般，而且对比发现高延时环境下reno的拥塞窗口增长比低延时来的慢一些。</p><p>　　对上述三种拥塞控制算法进行性能分析，主要关注性能指标是发送端的cwnd，ssthresh以及整个连接过程中的吞吐量。下表是不同丢包率和延时时间下的吞吐率：</p><table><thead><tr><th>拥塞控制算法</th><th>正常情况   （Mbit/s）</th><th>loss   为0.5%</th><th>loss   为2.5%</th><th>delay为   30ms±10ms</th><th>delay为   100ms±30ms</th><th>delay为   10ms±3ms</th></tr></thead><tbody><tr><td>cubic</td><td>31.7</td><td>20.9</td><td>14.6</td><td>15.5</td><td>12.3</td><td>23</td></tr><tr><td>reno</td><td>41</td><td>21.5</td><td>13.9</td><td>17.1</td><td>7.99</td><td>21.4</td></tr><tr><td>westwood</td><td>39.1</td><td>22.3</td><td>16.8</td><td>16.9</td><td>3.98</td><td>21.6</td></tr></tbody></table><p>绘制如图所示柱状图：</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214165656.png" alt=""></p><p>　　分析上图可知，当网络存在随机丢包时，采用Westwood基于时延反馈的拥塞控制机制效果最佳，采用适用于高带宽的基于丢包反馈的Cubic拥塞控制机制和采用Reno拥塞控制算法的效果较差，这是由于存在丢包后，Cubic算法和Reno算法受丢包事件驱动，采用拥塞控制，使得发送窗口乘性回退，最终反映为网络的吞吐量的下降，而Westwood则是通过测量估计可用带宽动态调整慢开始阈值，可实现更快的快速恢复。</p><p><img src="https://cdn.jsdelivr.net/gh/honor-ry/honor-imgs/images/20200214165707.png" alt=""></p><p>　　分析上图：当网络存在7-13ms的随机延迟时，cubic算法表现出最佳的吞吐率。Cubic算法的有点在于只要没有出现丢包，就不会主动降低自己的发送速度，可以最大程度的利用网络剩余带宽，提高吞吐量。可以在在高带宽、低丢包率的网络中可以发挥较好的性能。而Westwood由于检测到了连接超时，会认为网络拥塞，发送窗口乘性减少回退，大大降低了网络利用率，但由于其可实现更快的快恢复阶段，因此性能相比于Reno要好一点。</p><p>　　综合上述分析，对cubic、reno、westwood三种拥塞控制算法有了较深的了解。其中Cubic、Reno算法是基于丢包反馈协议的（将丢包视为出现拥塞，采取缓慢探测的方式，逐渐增大拥塞窗口，当出现丢包时，将拥塞窗口减小），Westwood算法是基于延迟反馈协议的（将时延增加视为出现拥塞，延时增加时增大拥塞窗口，延时减小时减小拥塞窗口）。</p><p>　　Cubic算法适用于高带宽，低丢包率的网络，能够有效利用带宽。</p><p>　　Reno算法适用于低延时，低带宽的网络。</p><p>　　Westwood算法是在tcp-reno算法的基础上针对高带宽大延时提出的，尤其在无线网络中相较reno有更快的恢复速度，对可用带宽的利用率很高。通过测量估算出网络的可用带宽，对拥塞窗口cwnd进行适当调整，实现更快速的恢复。与Reno相比吞吐量成倍提高。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown测试</title>
      <link href="/posts/ff42.html"/>
      <url>/posts/ff42.html</url>
      
        <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><hr><h3 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a>1. 斜体和粗体</h3><p>使用 * 和 ** 表示斜体和粗体。</p><p>示例：</p><p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p><a id="more"></a><h3 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a>2. 分级标题</h3><p>使用 === 表示一级标题，使用 — 表示二级标题。</p><p>示例：</p><figure class="highlight asciidoc"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这是一个一级标题</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line">这是一个二级标题</span><br><span class="line">--------------------------------------------------</span><br><span class="line"></span><br><span class="line">### 这是一个三级标题</span><br></pre></td></tr></tbody></table></figure><p>你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。</p><h3 id="3-外链接"><a href="#3-外链接" class="headerlink" title="3. 外链接"></a>3. 外链接</h3><p>使用 [描述](链接地址) 为文字增加外链接。</p><p>示例：</p><p>这是去往 <a href="http://Shen-Yu.github.com" target="_blank" rel="noopener">本人博客</a> 的链接。</p><p><img src="https://n1-q.mafengwo.net/s15/M00/65/BB/CoUBGV3brtOAMKOdAAsHBZ8nyQk791.jpg?imageMogr2%2Fthumbnail%2F1360x%2Fstrip%2Fquality%2F90" alt=""></p><h3 id="4-无序列表"><a href="#4-无序列表" class="headerlink" title="4. 无序列表"></a>4. 无序列表</h3><p>使用 *，+，- 表示无序列表。</p><p>示例：</p><ul><li>无序列表项 一</li><li>无序列表项 二</li><li>无序列表项 三</li></ul><h3 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. 有序列表</h3><p>使用数字和点表示有序列表。</p><p>示例：</p><ol><li>有序列表项 一</li><li>有序列表项 二</li><li>有序列表项 三</li></ol><h3 id="6-文字引用"><a href="#6-文字引用" class="headerlink" title="6. 文字引用"></a>6. 文字引用</h3><p>使用 &gt; 表示文字引用。</p><p>示例：</p><blockquote><p>野火烧不尽，春风吹又生。</p></blockquote><h3 id="7-行内代码块"><a href="#7-行内代码块" class="headerlink" title="7. 行内代码块"></a>7. 行内代码块</h3><p>使用 `代码` 表示行内代码块。</p><p>示例：</p><p>让我们聊聊 <code>html</code>。</p><h3 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8.  代码块"></a>8.  代码块</h3><p>使用 四个缩进空格 表示代码块。</p><p>示例：</p><pre><code>这是一个代码块，此行左侧有四个不可见的空格。</code></pre><h3 id="9-插入图像"><a href="#9-插入图像" class="headerlink" title="9.  插入图像"></a>9.  插入图像</h3><p>使用 ![描述](图片链接地址) 插入图像。</p><p>示例：</p><p><img src="https://www.zybuluo.com/static/img/my_head.jpg" alt="我的头像"></p><h1 id="Cmd-Markdown-高阶语法手册"><a href="#Cmd-Markdown-高阶语法手册" class="headerlink" title="Cmd Markdown 高阶语法手册"></a>Cmd Markdown 高阶语法手册</h1><h3 id="1-内容目录"><a href="#1-内容目录" class="headerlink" title="1. 内容目录"></a>1. 内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p><p>[TOC]</p><h3 id="2-标签分类"><a href="#2-标签分类" class="headerlink" title="2. 标签分类"></a>2. 标签分类</h3><p>在编辑区任意行的列首位置输入以下代码给文稿标签：</p><p>标签： 数学 英语 Markdown</p><p>或者</p><p>Tags： 数学 英语 Markdown</p><h3 id="3-删除线"><a href="#3-删除线" class="headerlink" title="3. 删除线"></a>3. 删除线</h3><p>使用 ~~ 表示删除线。</p><p><del>这是一段错误的文本。</del></p><h3 id="4-注脚"><a href="#4-注脚" class="headerlink" title="4. 注脚"></a>4. 注脚</h3><p>使用 [^keyword] 表示注脚。</p><p>这是一个注脚[^footnote]的样例。</p><p>这是第二个注脚[^footnote2]的样例。</p><h3 id="5-LaTeX-公式"><a href="#5-LaTeX-公式" class="headerlink" title="5. LaTeX 公式"></a>5. LaTeX 公式</h3><p>$ 表示行内公式： </p><p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p><p>$$ 表示整行公式：</p><p>$$\sum_{i=1}^n a_i=0$$</p><p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</p><p>$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p><p>访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。</p><h3 id="6-加强的代码块"><a href="#6-加强的代码块" class="headerlink" title="6. 加强的代码块"></a>6. 加强的代码块</h3><p>支持四十一种编程语言的语法高亮的显示，行号显示。</p><p>非代码示例：</p><figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-<span class="builtin-name">get</span> install vim-gnome</span><br></pre></td></tr></tbody></table></figure><p>Python 示例：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">'''A docstring'''</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt'''</span></span><br></pre></td></tr></tbody></table></figure><p>JavaScript 示例：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* nth element in the fibonacci series.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>n &gt;= 0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return </span>the nth element, &gt;= 0.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) {</span><br><span class="line">    tmp = a;</span><br><span class="line">    a += b;</span><br><span class="line">    b = tmp;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(fib(<span class="number">10</span>));</span><br></pre></td></tr></tbody></table></figure><h3 id="7-流程图"><a href="#7-流程图" class="headerlink" title="7. 流程图"></a>7. 流程图</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Start:&gt;https://www.zybuluo.com</span><br><span class="line">io=&gt;inputoutput: verification</span><br><span class="line">op=&gt;operation: Your Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">sub=&gt;subroutine: Your Subroutine</span><br><span class="line">e=&gt;end</span><br><span class="line"></span><br><span class="line">st-&gt;io-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;sub-&gt;io</span><br></pre></td></tr></tbody></table></figure><h4 id="更多语法参考：流程图语法参考"><a href="#更多语法参考：流程图语法参考" class="headerlink" title="更多语法参考：流程图语法参考"></a>更多语法参考：<a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="noopener">流程图语法参考</a></h4><h3 id="8-序列图"><a href="#8-序列图" class="headerlink" title="8. 序列图"></a>8. 序列图</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></tbody></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Title: Here is a title</span><br><span class="line">A-&gt;B: Normal line</span><br><span class="line">B--&gt;C: Dashed line</span><br><span class="line">C-&gt;&gt;D: Open arrow</span><br><span class="line">D--&gt;&gt;A: Dashed open arrow</span><br></pre></td></tr></tbody></table></figure><h4 id="更多语法参考：序列图语法参考"><a href="#更多语法参考：序列图语法参考" class="headerlink" title="更多语法参考：序列图语法参考"></a>更多语法参考：<a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">序列图语法参考</a></h4><h3 id="9-甘特图"><a href="#9-甘特图" class="headerlink" title="9. 甘特图"></a>9. 甘特图</h3><p>甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">title 项目开发流程</span><br><span class="line">section 项目确定</span><br><span class="line">    需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">    可行性报告     :after a1, 5d</span><br><span class="line">    概念验证       : 5d</span><br><span class="line">section 项目实施</span><br><span class="line">    概要设计      :2016-07-05  , 5d</span><br><span class="line">    详细设计      :2016-07-08, 10d</span><br><span class="line">    编码          :2016-07-15, 10d</span><br><span class="line">    测试          :2016-07-22, 5d</span><br><span class="line">section 发布验收</span><br><span class="line">    发布: 2d</span><br><span class="line">    验收: 3d</span><br></pre></td></tr></tbody></table></figure><h4 id="更多语法参考：甘特图语法参考"><a href="#更多语法参考：甘特图语法参考" class="headerlink" title="更多语法参考：甘特图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#gant-diagrams" target="_blank" rel="noopener">甘特图语法参考</a></h4><h3 id="10-Mermaid-流程图"><a href="#10-Mermaid-流程图" class="headerlink" title="10. Mermaid 流程图"></a>10. Mermaid 流程图</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A[Hard edge] --&gt;|Link text| B(Round edge)</span><br><span class="line">B --&gt; C{Decision}</span><br><span class="line">C --&gt;|One| D[Result one]</span><br><span class="line">C --&gt;|Two| E[Result two]</span><br></pre></td></tr></tbody></table></figure><h4 id="更多语法参考：Mermaid-流程图语法参考"><a href="#更多语法参考：Mermaid-流程图语法参考" class="headerlink" title="更多语法参考：Mermaid 流程图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#flowcharts-basic-syntax" target="_blank" rel="noopener">Mermaid 流程图语法参考</a></h4><h3 id="11-Mermaid-序列图"><a href="#11-Mermaid-序列图" class="headerlink" title="11. Mermaid 序列图"></a>11. Mermaid 序列图</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Alice-&gt;John: Hello John, how are you?</span><br><span class="line">loop every minute</span><br><span class="line">    John--&gt;Alice: Great!</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><h4 id="更多语法参考：Mermaid-序列图语法参考"><a href="#更多语法参考：Mermaid-序列图语法参考" class="headerlink" title="更多语法参考：Mermaid 序列图语法参考"></a>更多语法参考：<a href="https://knsv.github.io/mermaid/#sequence-diagrams" target="_blank" rel="noopener">Mermaid 序列图语法参考</a></h4><h3 id="12-表格支持"><a href="#12-表格支持" class="headerlink" title="12. 表格支持"></a>12. 表格支持</h3><table><thead><tr><th>项目</th><th align="right">价格</th><th align="center">数量</th></tr></thead><tbody><tr><td>计算机</td><td align="right">$1600</td><td align="center">5</td></tr><tr><td>手机</td><td align="right">$12</td><td align="center">12</td></tr><tr><td>管线</td><td align="right">$1</td><td align="center">234</td></tr></tbody></table><h3 id="13-定义型列表"><a href="#13-定义型列表" class="headerlink" title="13. 定义型列表"></a>13. 定义型列表</h3><dl><dt>名词 1</dt><dd>定义 1（左侧有一个可见的冒号和四个不可见的空格）</dd></dl><dl><dt>代码块 2</dt><dd>这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</dd></dl><pre><code>代码块（左侧有八个不可见的空格）</code></pre><h3 id="14-Html-标签"><a href="#14-Html-标签" class="headerlink" title="14. Html 标签"></a>14. Html 标签</h3><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：</p><pre><code>&lt;table&gt;    &lt;tr&gt;        &lt;th rowspan="2"&gt;值班人员&lt;/th&gt;        &lt;th&gt;星期一&lt;/th&gt;        &lt;th&gt;星期二&lt;/th&gt;        &lt;th&gt;星期三&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;李强&lt;/td&gt;        &lt;td&gt;张明&lt;/td&gt;        &lt;td&gt;王平&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><table>    <tbody><tr>        <th rowspan="2">值班人员</th>        <th>星期一</th>        <th>星期二</th>        <th>星期三</th>    </tr>    <tr>        <td>李强</td>        <td>张明</td>        <td>王平</td>    </tr></tbody></table><h3 id="15-内嵌图标"><a href="#15-内嵌图标" class="headerlink" title="15. 内嵌图标"></a>15. 内嵌图标</h3><p>本站的图标系统对外开放，在文档中输入</p><pre><code>&lt;i class="icon-weibo"&gt;&lt;/i&gt;</code></pre><p>即显示微博的图标： <i class="icon-weibo icon-2x"></i></p><p>替换 上述 <code>i 标签</code> 内的 <code>icon-weibo</code> 以显示不同的图标，例如：</p><pre><code>&lt;i class="icon-renren"&gt;&lt;/i&gt;</code></pre><p>即显示人人的图标： <i class="icon-renren icon-2x"></i></p><p>更多的图标和玩法可以参看 <a href="http://fortawesome.github.io/Font-Awesome/3.2.1/icons/" target="_blank" rel="noopener">font-awesome</a> 官方网站。</p><h3 id="16-待办事宜-Todo-列表"><a href="#16-待办事宜-Todo-列表" class="headerlink" title="16. 待办事宜 Todo 列表"></a>16. 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p><pre><code>- [ ] **Cmd Markdown 开发**    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率    - [ ] 支持以 PDF 格式导出文稿    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)    - [x] 改进 LaTex 功能        - [x] 修复 LaTex 公式渲染问题        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)- [ ] **七月旅行准备**    - [ ] 准备邮轮上需要携带的物品    - [ ] 浏览日本免税店的物品    - [x] 购买蓝宝石公主号七月一日的船票</code></pre><p>对应显示如下待办事宜 Todo 列表：</p><ul><li><input disabled="" type="checkbox"> <strong>Cmd Markdown 开发</strong><ul><li><input disabled="" type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li><input disabled="" type="checkbox"> 支持以 PDF 格式导出文稿</li><li><input checked="" disabled="" type="checkbox"> 新增Todo列表功能 <a href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments" target="_blank" rel="noopener">语法参考</a></li><li><input checked="" disabled="" type="checkbox"> 改进 LaTex 功能<ul><li><input checked="" disabled="" type="checkbox"> 修复 LaTex 公式渲染问题</li><li><input checked="" disabled="" type="checkbox"> 新增 LaTex 公式编号功能 <a href="http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers" target="_blank" rel="noopener">语法参考</a></li></ul></li></ul></li><li><input disabled="" type="checkbox"> <strong>七月旅行准备</strong><ul><li><input disabled="" type="checkbox"> 准备邮轮上需要携带的物品</li><li><input disabled="" type="checkbox"> 浏览日本免税店的物品</li><li><input checked="" disabled="" type="checkbox"> 购买蓝宝石公主号七月一日的船票</li></ul></li></ul><p>[^footnote]: 这是一个 <em>注脚</em> 的 <strong>文本</strong>。</p><p>[^footnote2]: 这是另一个 <em>注脚</em> 的 <strong>文本</strong>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SYN flood攻击及SYN cookie原理分析</title>
      <link href="/posts/77c3.html"/>
      <url>/posts/77c3.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-实验简介"><a href="#1-实验简介" class="headerlink" title="1.实验简介"></a>1.实验简介</h2><p>　　最近在学习《计算机网络》，课程布置了一个网络攻击的作业 SYN Flooding Attack ，本篇博客就本次实验做一个完整的实验报告及总结。</p><a id="more"></a><h2 id="所用平台seed简介"><a href="#所用平台seed简介" class="headerlink" title="所用平台seed简介"></a>所用平台seed简介</h2><ol><li>SEED：计算机安全教育的教学实验平台</li><li><a href="http://www.cis.syr.edu/~wedu/seed/" target="_blank" rel="noopener">http://www.cis.syr.edu/~wedu/seed/</a></li><li>纽约雪城大学 杜文亮 (Du, Wenliang)教授设计和实现，从2002年开始得到NSF 1.2M$的资助</li></ol><!-- more --><h2 id="一-实验环境（详细说明实验运行的操作系统，网络平台，机器的配置）"><a href="#一-实验环境（详细说明实验运行的操作系统，网络平台，机器的配置）" class="headerlink" title="一.实验环境（详细说明实验运行的操作系统，网络平台，机器的配置）"></a>一.实验环境（详细说明实验运行的操作系统，网络平台，机器的配置）</h2><p>操作系统：Windows10<br>虚拟机操作系统：SEEDUbuntu 12.04<br>虚拟机工具：VirtualBox 5.2.16<br>网络虚拟软件：GNS3 2.0.3</p><h2 id="二-实验目的"><a href="#二-实验目的" class="headerlink" title="二.实验目的"></a>二.实验目的</h2><ol><li>掌握基础ip网络配置；</li><li>掌握GNS3和使用WireShark对流量进行抓包分析；</li><li>实现SYN flood攻击，理解其表现形式和产生的影响；</li><li>深入观察理解linux内核tcp SYN cookie机制，理解其在SYN flood攻击中的作用。</li></ol><h2 id="三-实验步骤"><a href="#三-实验步骤" class="headerlink" title="三.实验步骤"></a>三.实验步骤</h2><ol><li>导入SEED虚拟机镜像文件，命名为SEED ubuntu，复制一个，命名为SEED ubuntu target（注意勾选重新初始化网卡的MAC地址）。<br><img src="https://i.loli.net/2020/02/10/o9mBiqw6ElF3b81.png" alt="01.png"><br><img src="https://i.loli.net/2020/02/10/RK6YpAUMm5XtTbn.png" alt="02.png"><br><img src="https://i.loli.net/2020/02/10/DPbZmHJYWUvT9fn.png" alt="03.png"><br><img src="https://i.loli.net/2020/02/10/cVIMzFqChb9SkoZ.png" alt="04.png"></li></ol><ol start="2"><li><p>利用GNS3配置如图所示网络<br><img src="https://i.loli.net/2020/02/10/F51tw4KbjaiXe8P.png" alt="01.png"></p></li><li><p>配置两台主机的ip地址和路由，一个为192.168.1.1，另一个为192.168.1.2.默认的路由为192.168.1.0<br><img src="https://i.loli.net/2020/02/10/K45RJ9dq3bizWCk.png" alt="02.png"><br><img src="https://i.loli.net/2020/02/10/EJKW9D8gPFOQdHZ.png" alt="03.png"></p></li><li><p>测试连通性<br><img src="https://i.loli.net/2020/02/10/3ifuPty94hvkweM.png" alt="04.png"><br><img src="https://i.loli.net/2020/02/10/MxYHlJRseKuWLVm.png" alt="05.png"></p></li><li><p>在SEED Ubuntu target上启动telnet服务<br><img src="https://i.loli.net/2020/02/10/Bl7wKHhRAsLgEcz.png" alt="06.png"></p></li><li><p>在SEED Ubuntu主机上输入攻击命令<br><img src="https://i.loli.net/2020/02/10/9R5nGNSlUiQd6Tu.png" alt="07.png"></p></li><li><p>在seed Ubuntu target上用wireshark观察攻击报文<br><img src="https://i.loli.net/2020/02/10/chOIQatpP7qYSg3.png" alt="08.png"></p></li><li><p>用netstat –n –tcp命令观察建立的连接，显示的状态为established<br><img src="https://i.loli.net/2020/02/10/qfnNbBGc1kPp7TZ.png" alt="09.png"></p></li><li><p>此时seed ubuntu可以通过telnet登录seed Ubuntu target<br><img src="https://i.loli.net/2020/02/10/cLSAQYJipUw8szO.png" alt="10.png"></p></li><li><p>进一步观察linux内核tcp syn cookie机制<br>通过echo 0 &gt; /proc/sys/net/ipv4/tcp_syncookies命令关闭syn cookies<br>通过sysctl -w net.ipv4.tcp_max_syn_backlog = 5指定所能接受SYN同步包的最大客户端数量为5<br><img src="https://i.loli.net/2020/02/10/R3IEKrmyftcobM9.png" alt="11.png"></p></li><li><p>再次从SEED Ubuntu 上用netwox的syn flood攻击SEED Ubuntu target<br><img src="https://i.loli.net/2020/02/10/embRT7JGZnAvrSO.png" alt="12.png"></p></li><li><p>此时发现不能用telnet登录seed ubuntu target<br><img src="https://i.loli.net/2020/02/10/6JCzFa8oDY5OgGZ.png" alt="13.png"></p></li><li><p>再次打开SEED Ubuntu target内核tcp syn cookie参数(将tcp_syncookies设置为1)，同时从SEED Ubuntu 上用telnet连接主机 SEED Ubuntu target<br><img src="https://i.loli.net/2020/02/10/1EuwVbAZGXHiYSj.png" alt="14.png"></p></li></ol><p>发现可以通过telnet建立连接<br><img src="https://i.loli.net/2020/02/10/ZmfCsdTySpWU298.png" alt="15.png"></p><ol start="14"><li>用netstat –n –tcp查看tcp网络的连接情况。<br><img src="https://i.loli.net/2020/02/10/VNpCqYZdyztFT7o.png" alt="16.png"></li></ol><p>　　在seed ubuntu target查看连接情况<br><img src="https://i.loli.net/2020/02/10/BUdzThlMxGbpZQD.png" alt="17.png"></p><h2 id="四-实验结果分析"><a href="#四-实验结果分析" class="headerlink" title="四.实验结果分析"></a>四.实验结果分析</h2><h3 id="1-SYN-Flood攻击原理"><a href="#1-SYN-Flood攻击原理" class="headerlink" title="1. SYN Flood攻击原理"></a>1. SYN Flood攻击原理</h3><p>　　SYN Flood 攻击是一种典型的拒绝服务型(Denial of Service,DoS)攻击。所谓拒绝服务型攻击就是通过对网络带宽进行消耗性攻击，使受害主机或网络不能够良好的提供服务，从而间接达到攻击的目的。SYN Flood攻击就是利用了“三次握手”的漏洞。假设一个用户向服务器发送了SYN报文后突然死机或掉线，那么服务器在发出 SYN+ACK 应答报文后是无法收到客户端的 ACK 报文的(第三次握手无法完成)，一般把服务器收到 SYN 包而还未收到 ACK 包时的连接状态成为半开连接。这时服务器端一般会重试(再次发送 SYN+ACK 给客户端)并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为 SYN Timeout，一般来说这个时间是分钟的数量级(大约为30秒-2分钟)。如果有一个恶意的攻击者大量模拟这种情况，服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源—-数以万计的半连接，即使是简单的保存并遍历也会消耗非常多的 CPU 时间和内存，何况还要不断对这个列表中的 IP 进行 SYN+ACK 的重试。服务器端将忙于处理攻击者伪造的 TCP 连接请求而无暇理睬客户的正常请求，此时从正常客户的角度看来，服务器失去响应，这种情况就称作服务器端受到了SYN Flood攻击(SYN 洪范攻击)。</p><h3 id="2-SYN-Cookies原理"><a href="#2-SYN-Cookies原理" class="headerlink" title="2. SYN Cookies原理"></a>2. SYN Cookies原理</h3><p>　　SYN cookie就是用一个cookie来响应 TCP SYN请求的TCP实现，根据上面的描述，在正常的TCP实现中，当服务器接收到一个SYN数据包，它返回一个SYN+ACK包来应答，然后进入TCP_SYN_RECV(半开放连接)状态来等待最后返回的ACK包。服务器用一个数据空间来描述所有未决的连接，然而这个数据空间的大小是有限的，所以攻击者将塞满这个空间。SYN Cookie是对TCP服务器端的三次握手协议作一些修改，专门用来防范SYN Flood 攻击的一种手段。它的原理是，在TCP服务器收到 TCP SYN包并返回 TCP SYN+ACK 包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值,并将这个cookie作为将要返回的 SYN+ACK 包的初始序列号。在收到 TCP ACK包时，TCP服务器再根据报头信息获取cookie值，并通过这个cookie值检查这个TCP ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接。 由此可见，cookie的实现要求cookie 必须与每次TCP连接紧密对应，攻击者无法伪造cookie，同时cookie中包含连接的状态信息。</p><h3 id="3-实验结果"><a href="#3-实验结果" class="headerlink" title="3. 实验结果"></a>3. 实验结果</h3><p>　　当打开SEED Ubuntu target内核的tcp syn cookie参数时，在target机器遭受syn flood 攻击后，源主机(SEED Ubuntu)可以用telnet登录target主机，即可以建立正常的TCP连接。<br>当内核关闭tcp syn cookie参数时，target主机在遭受flood攻击后，源主机(SEED Ubuntu)telnet不能正常登录target主机，无法建立正常的TCP连接。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实验 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
